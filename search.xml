<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>双指针滑动窗口算法总结</title>
    <url>/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>滑动窗口算法，这个算法技巧的思路非常简单，就是利用双指针维护一个窗口，不断滑动，然后更新答案。LeetCode上有差不多10道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法技巧的时间复杂度是 O(N)，比一般的字符串暴力算法要高效。</p>
<p>要注意各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果等。算法基本框架如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"window: [%d, %d)\n"</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个…处的操作分别是右移和左移窗口更新操作，它们操作是完全对称的。</p>
<p>下面以四道 LeetCode 原题为例来套这个框架</p>
<h3 id="1、最小覆盖子串"><a href="#1、最小覆盖子串" class="headerlink" title="1、最小覆盖子串"></a>1、最小覆盖子串</h3><p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1.png" alt></p>
<p>使用暴力解法，代码大概是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++)</span><br><span class="line">        <span class="keyword">if</span> s[i:j] 包含 t 的所有字母:</span><br><span class="line">            更新答案</span><br></pre></td></tr></table></figure>

<p><strong>滑动窗口算法思路：</strong></p>
<p>1、在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，<strong>把索引左闭右开区间[left, right)称为一个「窗口」。</strong> </p>
<p>2、先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。</p>
<p>3、此时，停止增加right，转而不断增加left指针缩小窗口[left, right)，直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。</p>
<p>4、重复第 2 和第 3 步，直到right到达字符串S的尽头。</p>
<p><strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解</strong>，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p>
<p>下面画图理解一下，needs和window相当于计数器，分别记录T中字符出现次数和「窗口」中的相应字符的出现次数。</p>
<p>初始状态：</p>
<p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/2.webp" alt></p>
<p>增加right，直到窗口[left, right)包含了T中所有字符：</p>
<p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/3.webp" alt></p>
<p>现在开始增加left，缩小窗口[left, right)。</p>
<p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/4.webp" alt></p>
<p>直到窗口中的字符串不再符合要求，left不再继续移动。</p>
<p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/5.webp" alt></p>
<p>之后重复上述过程，先移动right，再移动left…… 直到right指针到达字符串S的末端，算法结束。</p>
<p>首先，初始化window和need两个哈希表，记录窗口中的字符和需要凑齐的字符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br></pre></td></tr></table></figure>

<p>然后，使用left和right变量初始化窗口的两端，不要忘了，区间[left, right)是左闭右开的，所以初始情况下窗口没有包含任何元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 开始滑动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中valid变量表示窗口中满足need条件的字符个数</strong>，如果valid和need.size()的大小相同，则说明窗口已满足条件，已经完全覆盖了串T。</p>
<p>现在开始套模板，只需要思考以下四个问题：</p>
<p>1、当移动right扩大窗口，即加入字符时，应该更新哪些数据？</p>
<p>2、什么条件下，窗口应该暂停扩大，开始移动left缩小窗口？</p>
<p>3、当移动left缩小窗口，即移出字符时，应该更新哪些数据？</p>
<p>4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p>
<p>如果一个字符进入窗口，应该增加window计数器；如果一个字符将移出窗口的时候，应该减少window计数器；当valid满足need时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p>
<p>下面是完整代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, len = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) </span><br><span class="line">        &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在这里更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; len)</span><br><span class="line">            &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最小覆盖子串</span></span><br><span class="line">    <span class="keyword">return</span> len == n+<span class="number">1</span> ? <span class="string">""</span> : s.substr(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、字符串排列"><a href="#2、字符串排列" class="headerlink" title="2、字符串排列"></a>2、字符串排列</h3><p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/2.png" alt> </p>
<p>注意哦，输入的s1是可以包含重复字符的，所以这个题难度不小。</p>
<p>这种题目，是明显的滑动窗口算法，相当给你一个S和一个T，请问你S中是否存在一个子串，包含T中所有字符且不包含其他字符？</p>
<p>首先，先套用滑动窗口算法框架代码，然后明确刚才提出的 4 个问题，写出如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 s 中是否存在 t 的排列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> t, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= t.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在这里判断是否找到了合法的子串</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到符合条件的子串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3、找到字符串中所有字母异位词"><a href="#3、找到字符串中所有字母异位词" class="headerlink" title="3、找到字符串中所有字母异位词"></a>3、找到字符串中所有字母异位词</h3><p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/3.png" alt></p>
<p>相当于，输入一个串S，一个串T，找到S中所有T的排列，并返回它们的起始索引。直接套用刚才的框架。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; needs, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (needs.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == needs[c]) </span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left == t.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当窗口符合条件时，把起始索引加入 res</span></span><br><span class="line">            <span class="keyword">if</span> (valid == needs.<span class="built_in">size</span>())</span><br><span class="line">                res.push_back(left);</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入res即可。</p>
<h3 id="4、最长无重复子串"><a href="#4、最长无重复子串" class="headerlink" title="4、最长无重复子串"></a>4、最长无重复子串</h3><p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/4.png" alt></p>
<p>根据提出的四个问题，依次根据具体情况填入框架即可，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right++];</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        m[c]++;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (m[c] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> d = s[left++];</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            m[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这里更新答案</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当m[c]值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动left缩小窗口。</p>
<p>要在收缩窗口完成后更新res，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复元素了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485141&idx=1&sn=0e4583ad935e76e9a3f6793792e60734&chksm=9bd7f8ddaca071cbb7570b2433290e5e2628d20473022a5517271de6d6e50783961bebc3dd3b&scene=126&sessionid=1587516905&key=90f15a20186b1d46c2992f11e82b01a0cda6178792cdef35f4436e8185c7cc6e973a629da69bafba62e0b6551c49abdf6c71bd261ba3c3acf9539e3ecf9390d5761103a4d3a3c3eb9f0c41aadad3a4c5&ascene=1&uin=MjE1ODMxOTYzOA%3D%3D&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=A4FXMMlE%2Bef9sSA4mIuJSO0%3D&pass_ticket=ppDnFMJpc9c%2Bn6RJFcuQ6KqAmN5hl%2BcvIiSNRu3bA2J3Np0Zr%2Fv7M6xJCQYQC60l" target="_blank" rel="noopener external nofollow noreferrer"> labuladong公众号</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL容器整理</title>
    <url>/2020/04/18/STL%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>容器是储存其他对象的对象。被储存的对象必须是同一类型。</p>
<p>分类：</p>
<p>与java的集合不同!STL容器主要被分为两个部分：</p>
<p>一是序列容器（是一种各元素之间有顺序关系的线性表，是一种线性结构的可序群集。顺序性容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定）（<code>forword_list,list,queue,priority_queue,stack,deque,vector,array</code>）。</p>
<a id="more"></a>
<p>另一个是关联容器（关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。但是关联式容器提供了另一种根据元素特点排序的功能，这样迭代器就能根据元素的特点“顺序地”获取元素。元素是有序的集合，默认在插入的时候按升序排列（<code>set,multiset,map,multimap</code>）！</p>
<p>C++11之后还有一种无序关联容器！(<code>unordered_map, unordered_set, unordered_multiset, unordered_multimap</code>)</p>
<h3 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h3><p>序列的要求：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">X <span class="title">a</span><span class="params">(n,t)</span>  <span class="comment">//声明一个名为a的有n个t组成的序列</span></span></span><br><span class="line"><span class="function"><span class="title">X</span><span class="params">(n,t)</span>     <span class="comment">//匿名序列（这里不做过多的解释）</span></span></span><br><span class="line"><span class="function">X <span class="title">a</span><span class="params">(i,j)</span>   <span class="comment">//声明一个名为a的序列，并且初始化[i,j）的内容</span></span></span><br><span class="line"><span class="function"><span class="title">X</span><span class="params">(i,j)</span>      <span class="comment">//匿名序列</span></span></span><br><span class="line">v.insert()   //由于insert重载方法比较多</span><br><span class="line">   <span class="number">1.</span>v.insert(p,t)<span class="comment">//将t插到p的前面</span></span><br><span class="line">   <span class="number">2.</span>v.insert(p,n,t)<span class="comment">//将n个t插入p之前</span></span><br><span class="line">   <span class="number">3.</span>v.insert(p,i.j)<span class="comment">//将区间[i,j)的元素插入到p之前</span></span><br><span class="line">v.erase(t,k)</span><br><span class="line">   <span class="number">1.</span>v.erase(t,k)<span class="comment">//删除他们之间的元素</span></span><br><span class="line">   <span class="number">2.</span>v.erase(p)<span class="comment">//删除p指向的元素</span></span><br><span class="line">v.<span class="built_in">clear</span>===v.erase(<span class="built_in">begin</span>(),<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>下面我们来看一下这些容器的特点！</p>
<h4 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. vector</h4><p>vector是数组的一种类表示，vector表示一段连续的内存，基于数组实现，他有自动的内存管理功能!可以动态的改变vector的长度，并随着元素的增加与减小来自动改变数组大小，它提供了直接添加尾部元素或者删除元素的方法！所以它的时间是固定的！然而他要在头部与中间插入或者删除元素是线性的时间复杂度！</p>
<p>特点：<br>他可以反转序列，所以它可以反向遍历可反转序列！（基于他的rbegin,rend）</p>
<p>调用头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>定义与初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;<span class="comment">//默认初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(v1)</span></span>;<span class="comment">//用v1初始化v</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>());<span class="comment">//用v1初始化v</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//定义一个大小为10的数组！</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span><span class="comment">//定义个全为1而且长度为10的数组</span></span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b.<span class="built_in">begin</span>(),b.<span class="built_in">begin</span>+<span class="number">3</span>)</span></span>; <span class="comment">//定义了a值为b中第0个到第2个（共3个）元素</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>)</span></span>; <span class="comment">//从数组中获得初值</span></span><br></pre></td></tr></table></figure>

<p>方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）a.assign(b.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//b为向量，将b的0~2个元素构成的向量赋给a</span></span><br><span class="line">（<span class="number">2</span>）a.assign(<span class="number">4</span>,<span class="number">2</span>); <span class="comment">//是a只含4个元素，且每个元素为2</span></span><br><span class="line">（<span class="number">3</span>）a.back(); <span class="comment">//返回a的最后一个元素</span></span><br><span class="line">（<span class="number">4</span>）a.front(); <span class="comment">//返回a的第一个元素</span></span><br><span class="line">（<span class="number">5</span>）a[i]; <span class="comment">//返回a的第i个元素，当且仅当a[i]存在2013-12-07</span></span><br><span class="line">（<span class="number">6</span>）a.<span class="built_in">clear</span>(); <span class="comment">//清空a中的元素</span></span><br><span class="line">（<span class="number">7</span>）a.empty(); <span class="comment">//判断a是否为空，空则返回ture,不空则返回false</span></span><br><span class="line">（<span class="number">8</span>）a.pop_back(); <span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">（<span class="number">9</span>）a.erase(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）</span></span><br><span class="line">（<span class="number">10</span>）a.push_back(<span class="number">5</span>); <span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">（<span class="number">11</span>）a.insert(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4</span></span><br><span class="line">（<span class="number">12</span>）a.insert(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</span></span><br><span class="line">（<span class="number">13</span>）a.insert(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>); <span class="comment">//b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8 ，插入元素后为1,4,5,9,2,3,4,5,9,8</span></span><br><span class="line">（<span class="number">14</span>）a.<span class="built_in">size</span>(); <span class="comment">//返回a中元素的个数；</span></span><br><span class="line">（<span class="number">15</span>）a.capacity(); <span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">（<span class="number">16</span>）a.resize(<span class="number">10</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值随机</span></span><br><span class="line">（<span class="number">17</span>）a.resize(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值为2</span></span><br><span class="line">（<span class="number">18</span>）a.reserve(<span class="number">100</span>); <span class="comment">//将a的容量（capacity）扩充至100，也就是说现在测试a.capacity();的时候返回值是100.这种操作只有在需要给a添加大量数据的时候才  显得有意义，因为这将避免内存多次容量扩充操作（当a的容量不足时电脑会自动扩容，当然这必然降低性能） </span></span><br><span class="line">（<span class="number">19</span>）a.swap(b); <span class="comment">//b为向量，将a中的元素和b中的元素进行整体性交换</span></span><br><span class="line">（<span class="number">20</span>）a==b; <span class="comment">//b为向量，向量的比较操作还有!=,&gt;=,&lt;=,&gt;,&lt;</span></span><br></pre></td></tr></table></figure>

<p>遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下标法</span></span><br><span class="line"><span class="keyword">int</span> length = v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//迭代器法</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator iterator = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(;iterator != v.<span class="built_in">end</span>();iterator++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*iterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几种常用重要的算法，使用时需要包含头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">（<span class="number">1</span>）sort(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span></span><br><span class="line">（<span class="number">2</span>）reverse(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span></span><br><span class="line">（<span class="number">3</span>）copy(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),b.<span class="built_in">begin</span>()+<span class="number">1</span>); <span class="comment">//把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素</span></span><br><span class="line">（<span class="number">4</span>）<span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>); <span class="comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span></span><br></pre></td></tr></table></figure>

<h4 id="2-deque"><a href="#2-deque" class="headerlink" title="2. deque"></a>2. deque</h4><p>双端队列，他的实现类似与vector,支持随机访问，但是它访问首元素的插入（push_front()）与删除（pop_front()）的时间是固定的！而且他的执行速度要比vector快很多！所以需要有大量的操作发生在序列的起始位置与结尾处，我们就要考虑用deque!</p>
<p>调用头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>初始化与定义已经在序列要求里面，而且方法与vector类似，只是多了push_front(),pop_front(),不做过多的阐述</p>
<h4 id="3-list"><a href="#3-list" class="headerlink" title="3. list"></a>3. list</h4><p>双向链表，list在链表中的任意一个位置插入与删除一个元素时间是固定的！但是他不能随机访问，优点是元素的快速插入与删除！从容器中插入与删除元素之后i，迭代器指向元素将不变，不会移动已有元素，只是修改链表信息。</p>
<p>调用头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>链表独有成员函数:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span>   <span class="comment">//使用&lt;运算符对链表进行排序，时间复杂度O（NlogN）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">list</span>&lt;T,Alloc&gt;&amp;x)</span>  <span class="comment">//将x与调用链表合并，要求：两个链表必须要已经排好序！元素将保存在调用链表中，x为空，这个时间复杂度为线性！</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span><span class="comment">//删除val的所有实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator pos,<span class="built_in">list</span>&lt;T,Alloc&gt;x)</span><span class="comment">//将链表x的内容加到pos的前面，时间复杂度为固定时间</span></span></span><br><span class="line">void unique（） //去重，线性时间</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><br>algorithm头文件中有sort函数，这个list也有自己的sort函数，排序时都可以用，不过使用自带的效率会更高一点。</p>
<h4 id="4-forword-list"><a href="#4-forword-list" class="headerlink" title="4. forword_list"></a>4. forword_list</h4><p>主要实现单向链表，与list类似，只需要正向迭代器，他是不可逆转容器，他功能比较少，比较简单</p>
<h4 id="5-queue"><a href="#5-queue" class="headerlink" title="5. queue"></a>5. queue</h4><p>他是一个适配器类，可以用数组也可以用链表实现队列，它不允许随机访问元素，而且不能遍历队列！元素只能先进先出（FIFO）.</p>
<p>调用头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>queue的定义，queue<typename> q;其中typename可以为任何类型或容器。</typename></p>
<p>queue的访问，由于队列是一种先进先出的限制性数据结构，因此在STL中只能通过front()来访问队首元素，或是通过back()来访问队尾元素。</p>
<p>方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="comment">//判断是否为空</span></span></span><br><span class="line"><span class="function"><span class="title">front</span><span class="params">()</span><span class="comment">//队首元素的访问</span></span></span><br><span class="line"><span class="function"><span class="title">back</span><span class="params">()</span><span class="comment">//队尾元素的访问</span></span></span><br><span class="line"><span class="function"><span class="title">push</span><span class="params">(x)</span><span class="comment">//队尾插入x</span></span></span><br><span class="line"><span class="function"><span class="title">pop</span><span class="params">()</span><span class="comment">//删除队首元素</span></span></span><br></pre></td></tr></table></figure>

<h4 id="6-priority-queue"><a href="#6-priority-queue" class="headerlink" title="6. priority_queue"></a>6. priority_queue</h4><p>优先队列，其底层是用堆来进行实现的。在优先队列中，队首的元素一定是当前队列中优先级最高的那一个。C++中的堆默认是大顶堆。</p>
<p>调用头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>priority_queue的定义，priority_queue<typename> q,typename可以为任意类型的元素。</typename></p>
<p>priority_queue只能通过top()函数来访问队首元素(堆顶元素)，也就是优先级最高的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; X <span class="comment">//大根堆,默认初始化</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; x  <span class="comment">//小根堆,运用了预定义函数greater&lt;int&gt;！</span></span><br></pre></td></tr></table></figure>

<p>以下内容摘自C++API：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">包含priority_queue 的头文件是 &lt;<span class="built_in">queue</span>&gt;</span><br><span class="line">priority_queue类的主要成员：</span><br><span class="line">priority_queue();    <span class="comment">//默认构造函数，生成一个空的排序队列</span></span><br><span class="line">priority_queue(<span class="keyword">const</span> <span class="built_in">queue</span>&amp;);    <span class="comment">//拷贝构造函数</span></span><br><span class="line">priority_queue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> priority_queue &amp;);    <span class="comment">//赋值运算符重载</span></span><br><span class="line">priority_queue 的私有成员：</span><br><span class="line">value_type;   <span class="comment">//priority_queue中存放的对象类型，它和priority_queue中的T类型相同</span></span><br><span class="line">priority_queue(<span class="keyword">const</span> Compare&amp; comp);    <span class="comment">//构造生成一个空的priority_queue对象，使用comp作为priority_queue的comparison</span></span><br><span class="line">priority_queue(<span class="keyword">const</span> value_type* first, <span class="keyword">const</span> value_type* last);    <span class="comment">//带有两个参数的构造 函数，使用默认的Comparison作为第三个参数</span></span><br><span class="line">size_type;    <span class="comment">//正整数类型，和Sequence::size_type类型一样。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//判断优先级队列是否为空，为空返回true，否则返回false</span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//返回优先级队列中的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> value_type&amp; <span class="title">top</span><span class="params">()</span> <span class="title">const</span><span class="params">()</span></span>;    <span class="comment">//返回优先级队列中第一个元素的参考值。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span></span>;    <span class="comment">//把元素x插入到优先级队列的尾部，队列的长度加1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;    <span class="comment">//删除优先级队列的第一个值，前提是队列非空，删除后队列长度减1</span></span><br></pre></td></tr></table></figure>

<h4 id="7-stack"><a href="#7-stack" class="headerlink" title="7. stack"></a>7. stack</h4><p>栈，是STL中实现一个后进先出的容器.</p>
<p>调用头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>stack的定义，stack<typename> name要使用stack需要加上头文件#include<stack>。</stack></typename></p>
<p>stack容器内元素的访问，由于栈本身就是一种后进先出的数据结构，在STL的stack中只能通过top()来访问栈顶元素</p>
<p>方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） push(x)<span class="comment">//将x压入栈中，时间复杂度O(1)</span></span><br><span class="line">（<span class="number">2</span>） top()<span class="comment">//获得栈顶元素，时间复杂度O(1)</span></span><br><span class="line">（<span class="number">3</span>） pop()<span class="comment">//将栈顶元素弹出，时间复杂度O(1)</span></span><br><span class="line">（<span class="number">4</span>） empty()<span class="comment">//判断栈是否为空，若为空，返回true，否则返回false，时间复杂度O(1)</span></span><br><span class="line">（<span class="number">5</span>） <span class="built_in">size</span>()<span class="comment">//返回栈中元素的个数，时间复杂度O(1)</span></span><br></pre></td></tr></table></figure>

<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++内存管理</title>
    <url>/2020/04/16/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。
　　</p>
<ul>
<li><p><strong>栈：</strong>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
</li>
<li><p><strong>堆：</strong>是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。。</p>
</li>
<li><p><strong>自由存储区：</strong>是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。</p>
</li>
<li><p><strong>全局/静态存储区：</strong>全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p>
</li>
<li><p><strong>常量存储区：</strong>这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p>
<a id="more"></a>
<p>PS：</p>
<p>  自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>
</li>
</ul>
<h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><p>栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b;				<span class="comment">//栈</span></span><br><span class="line">	<span class="keyword">char</span> s[] = <span class="string">"abc"</span>; 	<span class="comment">//栈</span></span><br><span class="line">	<span class="keyword">char</span> *p2;			<span class="comment">//栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式类似于链表。<br>如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// C 中用 malloc() 函数申请</span></span><br><span class="line">	<span class="keyword">char</span>* p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>*)p1&lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//输出：00000000003BA0C0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用 free() 函数释放</span></span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">   </span><br><span class="line">	<span class="comment">// C++ 中用 new 运算符申请</span></span><br><span class="line">	<span class="keyword">char</span>* p2 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)p2 &lt;&lt; <span class="built_in">endl</span>;		<span class="comment">//输出：00000000003BA0C0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用 delete 运算符释放</span></span><br><span class="line">	<span class="keyword">delete</span>[] p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆和栈的具体区别：</p>
<p>（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏。</p>
<p>（2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，<br>进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</p>
<p>（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。</p>
<p>（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。<br>静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，<br>但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。</p>
<p>（5）分配效率不同。堆的效率比栈要低得多</p>
<p>（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。而堆中具体存放内容是由程序员来填充的。</p>
<h3 id="常见的内存错误及其对策"><a href="#常见的内存错误及其对策" class="headerlink" title="常见的内存错误及其对策"></a>常见的内存错误及其对策</h3>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++优先队列的使用方法（自定义排序）</title>
    <url>/2020/04/13/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
    <content><![CDATA[<p>priority_queue本质是一个堆。</p>
<p>1.头文件是<code>#include&lt;queue&gt;</code></p>
<p>2.关于priority_queue中元素的比较</p>
<p>模板申明带3个参数：priority_queue&lt;Type, Container, Functional&gt;，其中Type 为数据类型，Container为保存数据的容器，Functional 为元素比较方式。</p>
<p>Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector。</p>
<a id="more"></a>
<p>基本操作有：</p>
<p>empty( )  //判断一个队列是否为空</p>
<p>pop( )  //删除队顶元素</p>
<p>top( )  //返回优先队列的队顶元素</p>
<p>push( )  //加入一个元素</p>
<p>size( )  //返回优先队列中拥有的元素个数</p>
<p>优先队列的时间复杂度为O（logn），n为队列中元素的个数，其存取都需要时间。</p>
<p>在默认的优先队列中，优先级最高的先出队。默认的int类型的优先队列中先出队的为队列中较大的数。</p>
<p>2.1 第一种用法（默认从大到小排序）：</p>
<p>如果元素是pair的话，先按照pair的first元素降序，first元素相等时，再按照second元素降序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q1;<span class="comment">//默认从大到小排序，整数中元素大的优先级高</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q1;<span class="comment">//默认从大到小排序 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">		q1.push(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q1.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;q1.top()&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		q1.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<p><img src="/2020/04/13/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%EF%BC%89/1.png" alt></p>
<p>2.2 第二种用法（从小到大排序）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;q1;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;q1;<span class="comment">//从大到小排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">		q1.push(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q1.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;q1.top()&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		q1.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2020/04/13/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%EF%BC%89/2.png" alt></p>
<p>2.3 第三种用法：自定义排序规则<br>对于自定义类型，则必须重载operator&lt;或者重写仿函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">100</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp1</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x&gt;y;<span class="comment">//小的优先级高 ,从小到大排 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp2</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> tmp[x]&gt;tmp[y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node a,node b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a.x&gt;b.x;<span class="comment">//按x从小到大排 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt;q1;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp1&gt;q2;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp2&gt;q3;</span><br><span class="line">priority_queue&lt;node&gt;q4;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,k,m,n;</span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	node a;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a.y&gt;&gt;a.x;</span><br><span class="line">			q4.push(a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">while</span>(!q4.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;q4.top().y&lt;&lt;<span class="string">" "</span>&lt;&lt;q4.top().x&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			q4.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">			q2.push(t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!q2.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;q2.top()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			q2.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2020/04/13/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%EF%BC%89/3.png" alt></p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/ac_gibson/article/details/44200411" target="_blank" rel="noopener external nofollow noreferrer">c++STL中优先队列的使用</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>线程与进程的区别及其通信方式</title>
    <url>/2020/04/10/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%85%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>线程：是操作系统能够进行运算调度的最小单位。是进程中的一个执行流程，一个进程中可以运行多个线程。</p>
<p>进程：是操作系统中资源分配的基本单元，一个执行中的程序的实例。</p>
<a id="more"></a>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li>进程是操作系统中资源分配的基本单元，是运行中的程序，线程是是操作系统能够进行运算调度的最小单位，是进程的一个执行流程</li>
<li><strong>地址空间和其它资源：</strong> 进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li>
<li><strong>调度和切换：</strong> 线程上下文切换比进程上下文切换要快得多。</li>
<li><strong>通信：</strong> 进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</li>
</ul>
<p><strong>补充：</strong></p>
<p>线程一般是<code>New</code>出来的，而进程一般<code>fork</code>某个母体而产生的。</p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>在 linux 下进程间通信的几种主要手段简介：</p>
<ol>
<li><p>管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p>
</li>
<li><p>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；</p>
</li>
</ol>
<p>消息队列（Message）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<p>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</p>
<p>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</p>
<p>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格</title>
    <url>/2020/04/10/5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>在网络编程中，如果URL参数中含有特殊字符，如空格、’#’等，可能导致服务器端无法获得正确的参数值。我们需要将这些特殊符号转换成服务器可以识别的字符。转换的规则是在’%’后面跟上ASCII码的两位十六进制的表示。比如空格的ASCII码是32，即十六进制的0x20，因此空格被替换成”%20”。再比如’#’的ASCII码为35，即十六进制的0x23，它在URL中被替换为”%23”。</p>
<a id="more"></a>
<p><img src="/2020/04/10/5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/1.jpg" alt></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h2><p>  1.) 直接法。最直观的做法是从头到尾扫描字符串，每一次碰到空格字符的时候做替换。由于是把1个字符替换成3个字符，我们必须要把空格后面所有的字符都后移两个字节，否则就有两个字符被覆盖了。下图展示了从前往后把字符串中的空格替换成’%20’的过程：</p>
<p>  <img src="/2020/04/10/5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/2.jpg" alt="2"></p>
<p>  假设字符串的长度是n。对每个空格字符，需要移动后面O(n)个字符，因此对含有O(n)个空格字符的字符串而言总的时间效率是O(n<sup>2</sup>),所以时间复杂度:O(n<sup>2</sup>),空间复杂度:O(n)</p>
<p>  2.) Step1.先遍历一次字符串，这样就能统计出字符串中空格的总数，并可以由此计算出替换之后的字符串的总长度。</p>
<p>　　以前面的字符串”We arehappy.”为例，”We are happy.”这个字符串的长度是14（包括结尾符号’\0’），里面有两个空格，因此替换之后字符串的长度是18。</p>
<p>  Step2.从字符串的后面开始复制和替换。</p>
<p>　　准备两个指针，P1和P2。P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾。接下来向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。接着向前复制，直到碰到第二、三或第n个空格。<br>  <img src="/2020/04/10/5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/3.jpg" alt="3"></p>
<p> 从上面的分析我们可以看出，所有的字符都只复制（移动）一次，因此这个算法的时间效率是O(n)，比第一个思路要快。</p>
<p> 时间复杂度为O(n)，空间复杂度为O(n)</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;     <span class="comment">//字符数组</span></span><br><span class="line">        <span class="built_in">string</span> res;   <span class="comment">//存储结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)&#123;   <span class="comment">//遍历原字符串</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">' '</span>)&#123;</span><br><span class="line">                res.push_back(<span class="string">'%'</span>);</span><br><span class="line">                res.push_back(<span class="string">'2'</span>);</span><br><span class="line">                res.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="模拟直接法-原地修改"><a href="#模拟直接法-原地修改" class="headerlink" title="模拟直接法(原地修改)"></a>模拟直接法(原地修改)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i]==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n+=<span class="number">2</span>;<span class="comment">//长度+2</span></span><br><span class="line">                s+=<span class="string">"  "</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;i+<span class="number">2</span>;j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    s[j]=s[j<span class="number">-2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                s[i] = <span class="string">'%'</span>;</span><br><span class="line">                s[i+<span class="number">1</span>] = <span class="string">'2'</span>;</span><br><span class="line">                s[i+<span class="number">2</span>] = <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：双指针法，先计算空格的个数，然后计算新字符串的长度，再从后向前进行替换，时间复杂度O-n"><a href="#方法二：双指针法，先计算空格的个数，然后计算新字符串的长度，再从后向前进行替换，时间复杂度O-n" class="headerlink" title="方法二：双指针法，先计算空格的个数，然后计算新字符串的长度，再从后向前进行替换，时间复杂度O(n);"></a>方法二：双指针法，先计算空格的个数，然后计算新字符串的长度，再从后向前进行替换，时间复杂度O(n);</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">NULL</span> || length &lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oldLength = <span class="number">0</span>; <span class="comment">// 原字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> newLength = <span class="number">0</span>; <span class="comment">// 替换后字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> numberofBlank = <span class="number">0</span>; <span class="comment">//空格数量</span></span><br><span class="line">        <span class="keyword">while</span>(str[i]!=<span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            oldLength++;</span><br><span class="line">            <span class="keyword">if</span> (str[i]==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                numberofBlank++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        newLength = oldLength + numberofBlank*<span class="number">2</span>; <span class="comment">// 计算替换后字符串的长度</span></span><br><span class="line">        <span class="keyword">if</span> (newLength &gt; length)  <span class="comment">// 如果大于最大长度直接返回 因为无法插入</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 设置两个指针，一个指向原始字符串的末尾，另一个指向替换之后的字符串的末尾 注意不要减一</span></span><br><span class="line">        <span class="keyword">int</span> p = oldLength; <span class="comment">//设置p指针指向旧字符串的末尾</span></span><br><span class="line">        <span class="keyword">int</span> q = newLength; <span class="comment">//设置q指针指向新字符串的末尾</span></span><br><span class="line">        <span class="keyword">while</span> (p&gt;=<span class="number">0</span> &amp;&amp; p&lt;q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[p]==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                str[q--] = <span class="string">'0'</span>;</span><br><span class="line">                str[q--] = <span class="string">'2'</span>;</span><br><span class="line">                str[q--] = '/%';</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                str[q--] = str[p];</span><br><span class="line">            &#125;</span><br><span class="line">            p--;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>左旋转字符串</title>
    <url>/2020/04/10/58-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h2><p>  方法一：直接法，定义一个左移一位函数leftmove，先定义一个<code>char temp = s[0];</code>。其余<code>s[i]==s[i+1];</code>，n-1位置最后一个字符替换为temp。左移几位就循环几次左移函数。</p>
<p>  方法二：利用reverse函数，原理：YX=(X<sup>T</sup> Y<sup>T</sup>)<sup>T</sup></p>
<p>  以”abcdefg“为例，我们可以把它分为两部分。由于想把它的前两个字.符移到后面，我们就把前两个字符分到第一部分， 把后面的所有字符分到第二部分。我们先分别翻转这两部分，于是就得到”bagfedc“。接下来翻转整个字符串，得到的”cdefgab“刚好就是把原始字符串左旋转两位的结果。</p>
<p>  方法三：取巧法，<code>s+=s;</code>，复制一遍字符串，从n开始处截取原字符串长度返回即可。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ol>
<li><p>O(kn) n为字符串长度，k旋转位数</p>
</li>
<li><p>O(n)</p>
</li>
<li><p>O(n)</p>
</li>
</ol>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><ol>
<li><p>O(1)</p>
</li>
<li><p>O(1)</p>
</li>
<li><p>O(n)</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一：直接左移-超时"><a href="#方法一：直接左移-超时" class="headerlink" title="方法一：直接左移(超时)"></a>方法一：直接左移(超时)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            leftMove(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">leftMove</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m  = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">char</span> temp = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i!=m<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s[i]=s[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：YX-XT-YT-T"><a href="#方法二：YX-XT-YT-T" class="headerlink" title="方法二：YX=(XT YT)^T"></a>方法二：YX=(X<sup>T</sup> Y<sup>T</sup>)^<sup>T</sup></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(),s.<span class="built_in">begin</span>()+n); </span><br><span class="line">        <span class="comment">//reverse函数反转的范围是[first,last)</span></span><br><span class="line">        reverse(s.<span class="built_in">begin</span>()+n,s.<span class="built_in">end</span>());</span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：s-s"><a href="#方法三：s-s" class="headerlink" title="方法三：s+=s"></a>方法三：s+=s</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        s+=s;</span><br><span class="line">        s = s.substr(n,m);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>空间复杂度改善为O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;n+m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=s[i%m];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转单词顺序</title>
    <url>/2020/04/10/58-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p><strong>说明：</strong> </p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<a id="more"></a>

</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h2><p>方法一：</p>
<p>1) 翻转整个句子<br>2) 翻转句中单词<br>3) 删除多余的空格</p>
<p>方法二：字符流，用stringstream来做</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>  O(n)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>  O(1)</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="built_in">string</span> &amp;s,<span class="keyword">int</span> start,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;<span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(s[start++],s[<span class="built_in">end</span>--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanSpaces</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n &amp;&amp; s[j] == <span class="string">' '</span>) j++; <span class="comment">// 跳过空格</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;n &amp;&amp; s[j] != <span class="string">' '</span>)s[i++] = s[j++]; </span><br><span class="line">            <span class="comment">// 保留单词（非空格部分）</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;n &amp;&amp; s[j] == <span class="string">' '</span>) j++; </span><br><span class="line">            <span class="comment">// 跳过空格（主要是防止结尾有空格，然后再添加空格越界）</span></span><br><span class="line">            <span class="keyword">if</span> (j&lt;n) s[i++] = <span class="string">' '</span>; <span class="comment">// 补充空格</span></span><br><span class="line">        &#125;</span><br><span class="line">        s = s.substr(<span class="number">0</span>,i); <span class="comment">// 改成引用减少一次拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//翻转整个语句</span></span><br><span class="line">        Reverse(s,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 翻转句中单词</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n &amp;&amp; s[i]==<span class="string">' '</span>) i++;</span><br><span class="line">            start = <span class="built_in">end</span> = i;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n &amp;&amp; s[i]!=<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="built_in">end</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">            Reverse(s,start,<span class="built_in">end</span><span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清除多余空格</span></span><br><span class="line">        s = cleanSpaces(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：字符流"><a href="#方法二：字符流" class="headerlink" title="方法二：字符流"></a>方法二：字符流</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">""</span>,temp;</span><br><span class="line">        ss&lt;&lt;s;</span><br><span class="line">        <span class="keyword">while</span>(ss&gt;&gt;temp)&#123;</span><br><span class="line">            ans=<span class="string">" "</span>+temp+ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans!=<span class="string">""</span>)</span><br><span class="line">            ans.erase(ans.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://segmentfault.com/a/1190000017271382" target="_blank" rel="noopener external nofollow noreferrer">C++ 学习笔记之——字符串和字符串流</a></li>
<li><a href="https://blog.csdn.net/yyhaohaoxuexi/article/details/51416874" target="_blank" rel="noopener external nofollow noreferrer">C++ string 类中substr的使用方法</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP头部具体划分</title>
    <url>/2020/04/08/TCP%E5%9B%BA%E5%AE%9A%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>尽管TCP和UDP都使用相同的网络层（IP），TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。</p>
<p>使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上之后的数据的传输。TCP连接是全双工的，即双方的数据读写可以通过一个连接进行。完成数据交换后，通信双方都必须断开连接以释放系统资源。</p>
<p>TCP连接是一对一的，所以基于广播和多播应该使用UDP协议。</p>
<a id="more"></a>
<h3 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h3><p>TCP头部详解如下(两个图结合着理解)：</p>
<p><img src="/2020/04/08/TCP%E5%9B%BA%E5%AE%9A%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/1.webp" alt></p>
<p><img src="/2020/04/08/TCP%E5%9B%BA%E5%AE%9A%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/1.png" alt></p>
<p>对上图的部分说明:</p>
<h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>在进行TCP通信时，客户端使用系统自动选择的临时端口号，服务器采用知名服务端口号，如DNS协议端口号53，HTTP协议端口号80。知名服务使用的端口号定义在/etc/services。</p>
<p><img src="/2020/04/08/TCP%E5%9B%BA%E5%AE%9A%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/2.png" alt></p>
<h4 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h4><p>六位标志位包含以下几项：</p>
<ul>
<li><p>URG：表示紧急指针是否有效；</p>
</li>
<li><p>ACK：表示确认号是否有效，携带ACK标志的数据报文段为确认报文段；</p>
</li>
<li><p>PSH：提示接收端的应用程序应该立即从TCP接受缓冲区中读走数据，为接受后续数据腾出空间；</p>
</li>
<li><p>RST：表示要求对方重新建立连接，携带RST标志位的TCP报文段成为复位报文段；</p>
</li>
<li><p>SYN：表示请求建立一个连接，携带SYN标志的TCP报文段为同步报文段；</p>
</li>
<li><p>FIN：通知对方本端要关闭了，带FIN标志的TCP报文段为结束报文段。</p>
</li>
</ul>
<h4 id="确认序号"><a href="#确认序号" class="headerlink" title="确认序号"></a>确认序号</h4><p>Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p>
<h4 id="TCP头部选项"><a href="#TCP头部选项" class="headerlink" title="TCP头部选项"></a>TCP头部选项</h4><p>TCP头部选项是一个可变长的信息，这部分最多包含40字节，因为TCP头部最长60字节，（其中还包含前面20字节的固定部分）。</p>
<p><strong>为什么在TCP首部的开始便是首部长度字段而UDP首部却没有？</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因为UDP提供无连接服务，它的数据包包头，是固定长度的8字节，不存在可选字</span><br><span class="line">段，可以减少很多传输开销，所以它无需使用首部字段长，因为它的首部就是固定的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而TCP提供连接服务，它的数据包包头，除了固定的20字节之外，还存在一个可</span><br><span class="line">选项，这个可选项字段，是根据TCP连接的要求而变动。这一字段最常见到的就</span><br><span class="line">是最大报文大小MSS，它指明发送端所能接收的最大长度的报文段。因为这个字</span><br><span class="line">段的存在，所以TCP包头使用了首部长字段。它占4位，以四字节为单位表示TCP</span><br><span class="line">包头长度，也就是说，TCP的首部最大长度可以是15x4&#x3D;60字节，而可选项长可以为60-20&#x3D;40字节</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/m0_37925202/article/details/80899012" target="_blank" rel="noopener external nofollow noreferrer">TCP固定头部结构详解</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>C++函数返回局部变量的问题</title>
    <url>/2020/04/08/C-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="常见栈内变量"><a href="#常见栈内变量" class="headerlink" title="常见栈内变量"></a>常见栈内变量</h3><p>一般来说，在函数内对于存在栈上的局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放。因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错；但是如果返回的是局部变量的地址（指针）的话，就造成了野指针，程序运行会出错，因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// OK.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>* ip = &amp;i;</span><br><span class="line">    <span class="keyword">return</span> ip; <span class="comment">// Wrong!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r1 = fun1();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">int</span>* r2 = fun2();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *r2 &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 这里有可能可以打印出结果：2，看似正确的，但其实是有问题的。</span></span><br><span class="line">    <span class="comment">//这是因为相应的内存还未被覆盖，但这块内存已经是自由的、不被保护的了。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// OK.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fun4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// Wrong!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* r3 = fun3();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r3 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Hello</span></span><br><span class="line">    <span class="keyword">char</span>* r4 = fun4();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r4 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 内存已经无效的了。打印出乱码。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>如果函数的返回值非要是一个局部变量地址，可以把局部变量声明为static静态变量。这样变量存储在静态存储区，程序运行过程中一直存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fun5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;i; <span class="comment">// OK.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fun6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> s[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// OK.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* r5 = fun5();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *r5 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">char</span>* r6 = fun6();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r6 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是不能作为函数的返回值的。因为编译器会把数组名认为是局部变量（数组）的地址。返回一个数组，实际上是返回指向这个数组首地址的指针。函数结束后，数组作为局部变量被释放，这个指针则变成了野指针。同1的fun2()及2的fun4()（字符数组）。但是声明数组是静态的，然后返回是可以的.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fun7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> a; <span class="comment">// Wrong!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fun8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> a; <span class="comment">// OK.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* r7 = fun7();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *r7 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 内存已经是无效的了。</span></span><br><span class="line">    <span class="keyword">int</span>* r8 = fun8();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *r8 &lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆内变量"><a href="#堆内变量" class="headerlink" title="堆内变量"></a>堆内变量</h3><p>函数返回指向存储在堆上的变量的指针是可以的。但是，程序员要自己负责在函数外释放（free/delete）分配（malloc/new）在堆上的内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fun9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// OK. 但需要程序员自己释放内存。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* r9 = <span class="literal">NULL</span>;</span><br><span class="line">    r9 = fun9();</span><br><span class="line">    <span class="built_in">strcpy</span>(r9, <span class="string">"Hello"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r9 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Hello</span></span><br><span class="line">    <span class="built_in">free</span>(r9); <span class="comment">// 要记得自己释放内存。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>字节序：大端法和小端法</title>
    <url>/2020/04/08/%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%9A%E5%A4%A7%E7%AB%AF%E6%B3%95%E5%92%8C%E5%B0%8F%E7%AB%AF%E6%B3%95/</url>
    <content><![CDATA[<p>字节序，顾名思义字节的顺序，再多说两句就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。</p>
<p>大端法：高位保存在低地址中。<br>小端法：高位存放在高地址中。</p>
<p><img src="/2020/04/08/%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%9A%E5%A4%A7%E7%AB%AF%E6%B3%95%E5%92%8C%E5%B0%8F%E7%AB%AF%E6%B3%95/1.webp" alt></p>
<a id="more"></a>
<p><strong>程序判断大端法还是小端法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        short s;</span><br><span class="line">        <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(short)];</span><br><span class="line">    &#125; u;</span><br><span class="line"></span><br><span class="line">    u.s = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(short) == <span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (u.c[<span class="number">0</span>] == <span class="number">0x12</span> &amp;&amp; u.c[<span class="number">1</span>] == <span class="number">0x34</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Big-Endian"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (u.c[<span class="number">0</span>] == <span class="number">0x34</span> &amp;&amp; u.c[<span class="number">1</span>] == <span class="number">0x12</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Little-Endian"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"not known"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(short) ="</span>&lt;&lt; <span class="keyword">sizeof</span>(short) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>大端和小端法对程序的影响</strong></p>
<ul>
<li><p>字节序不是由操作系统决定，而是由cpu架构决定的，比如 x86 的是小端序，而 PPC (PowerPC) 是big endian。 所以跑在 x86 上的 linux/windows 都是小端，而跑在 PPC 上的linux则是大端。</p>
</li>
<li><p>网络字节序为大端。</p>
</li>
<li><p>网络编程中常用的字节序转换函数有如下几个：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;&lt;netinet/in.h&gt;&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uing16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> host16bitvalue)</span></span>;    </span><br><span class="line"><span class="comment">// 参数为16位主机字节序的值，返回值是16位网络字节序的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> host32bitvalue)</span></span>;    </span><br><span class="line"><span class="comment">// 参数为32位主机字节序的值，返回值是32位网络字节序的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> net16bitvalue)</span></span>;     </span><br><span class="line"><span class="comment">// 参数为16位网络字节序的值，返回值是16位主机字节序的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> net32bitvalue)</span></span>;     </span><br><span class="line"><span class="comment">// 参数为16位网络字节序的值，返回值是16位主机字节序的值</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟地址、逻辑地址、物理地址区别与联系</title>
    <url>/2020/04/07/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E3%80%81%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的流量控制和拥塞控制</title>
    <url>/2020/04/07/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="TCP的流量控制和拥塞控制"><a href="#TCP的流量控制和拥塞控制" class="headerlink" title="TCP的流量控制和拥塞控制"></a>TCP的流量控制和拥塞控制</h2><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><ol>
<li><p>利用滑动窗口实现流量控制</p>
<p> 如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓<strong>流量控制</strong>就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p> 利用<strong>滑动窗口机制</strong>可以很方便地在TCP连接上实现对发送方的流量控制。</p>
 <a id="more"></a>
<p> 设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p>
<p> <img src="/2020/04/07/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/1.jfif" alt></p>
<p> 从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p>
<p> TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p>
</li>
<li><p>必须考虑传输速率</p>
<p> 可以用不同的机制来控制TCP报文段的发送时机。如：</p>
<p> &lt;1&gt;. TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。</p>
<p> &lt;2&gt;. 由发送方的应用进程指明要求发送报文段，即TCP支持的推送( push )操作。</p>
<p> &lt;3&gt;. 发送方的一个计时器期限到了，这时就把已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。</p>
<p> Nagle算法：若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方接收对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段再发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。Nagle算法还规定：当到达的数据已达到 发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。</p>
<p> 另，糊涂窗口综合征：TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1字节（这样就使接收缓存空间仅腾出1字节），然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报为40字节的的话）。接收，发送方又发来1个字节的数据（发送方的IP数据报是41字节）。接收方发回确认，仍然将窗口设置为1个字节。这样，网络的效率很低。要解决这个问题，可让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收方缓存已有一半空闲的空间。只要出现这两种情况，接收方就发回确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据报积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p>
</li>
</ol>
<h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><h4 id="1-拥塞："><a href="#1-拥塞：" class="headerlink" title="1.  拥塞："></a>1.  拥塞：</h4><p>即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。</p>
<pre><code>拥塞控制：**防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载**。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。

流量控制：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。</code></pre><h4 id="2-几种拥塞控制方法"><a href="#2-几种拥塞控制方法" class="headerlink" title="2. 几种拥塞控制方法"></a>2. 几种拥塞控制方法</h4><pre><code>慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</code></pre><h5 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h5><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。</p>
<p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<p><strong>慢开始算法：</strong> 当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p>
<p><img src="/2020/04/07/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2.jfif" alt></p>
<p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p>
<p>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p>
<p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：</p>
<p>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</p>
<p>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>
<p>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>
<p><strong>拥塞避免算法：</strong>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p>
<p><img src="/2020/04/07/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/3.jfif" alt></p>
<p>&lt;1&gt;. 当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。</p>
<p>&lt;2&gt;. 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值+1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线性规律增长。</p>
<p>&lt;3&gt;. 假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个MSS的大小。</p>
<p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，<strong>使网络比较不容易出现拥塞</strong>。</p>
<h4 id="2-2-快重传和快恢复"><a href="#2-2-快重传和快恢复" class="headerlink" title="2.2 快重传和快恢复"></a>2.2 快重传和快恢复</h4><p>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。</p>
<p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p>
<p><img src="/2020/04/07/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/4.jfif" alt></p>
<p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>
<p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p>
<p>&lt;1&gt;. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p>
<p>&lt;2&gt;. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p>
<p>下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。</p>
<p>区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p>
<p><img src="/2020/04/07/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/5.jfif" alt></p>
<p>也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。</p>
<p>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。</p>
<p>采用这样的拥塞控制方法使得TCP的性能有明显的改进。</p>
<p>接收方根据自己的接收能力设定了接收窗口rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，接收窗口又称为通知窗口。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口rwnd</p>
<p>发送方窗口的上限值 = Min [ rwnd, cwnd ]</p>
<p>当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。</p>
<p>当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解协议</title>
    <url>/2020/04/06/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>协议：</p>
<p>“协”字，代表必须有两个以上的参与者。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。</p>
<p>“议”字，代表的意思是对参与者的一种行为约定和规范。例如三方协议里规定的试用期限、毁约金等；租房协议里的租用期限、每月租金金额等。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP和TCP/IP的区别</title>
    <url>/2020/04/06/TCP%E5%92%8CTCP-IP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>TCP/IP是Transmission Control Protocol/Internet Protocol的简写，译名为传输控制协议/因特网协议，是Internet最基本的协议。TCP/IP是这个协议族的统称，它采用了4层的层级结构，而不是指TCP + IP两个协议的总和。</p>
<p>主要包括TCP、IP、UDP、ICMP、RIP、TELNET、FTP、SMTP、ARP、TFTP等许多协议</p>
<a id="more"></a>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP协议包含源主机地址、目标主机地址，还有TCP数据信息。但IP协议没有做任何事情来确认数据包是否按顺序发送或者包是否被破坏，所以IP数据包是不可靠的。</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>面向连接的通信协议，通过三次握手建立连接（socket通过TCP/IP连接时就是经过3次握手），通信完成后要关闭连接，它只用于端对端的通讯</p>
<p>TCP协议通过3次握手建立起一个可靠的连接，通过将数据包进行排序以及检验的方式，可以提供一种可靠的数据流服务</p>
<p>TCP可以限制数据的发送速度，间接地控制流量</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>面向无连接的通讯协议，UDP数据包括原端口号信息以及目标端口号信息，它可以实现广播发送</p>
<p>由于UDP通讯不需要接收方确认，所以属于不可靠的传输，可能会出现丢包现象。</p>
<p>七层网络模型示意图</p>
<p><img src="/2020/04/06/TCP%E5%92%8CTCP-IP%E7%9A%84%E5%8C%BA%E5%88%AB/1.jpg" alt></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP请求与响应全过程</title>
    <url>/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>在浏览器的地址栏输入一个URL，然后回车，回车这一瞬间到看到页面到底发生了什么呢？</p>
<p>主要是进行了一下几个步骤：</p>
<p>1.DNS域名解析；</p>
<p>2.建立TCP连接；</p>
<p>3.发送http请求；</p>
<p>4.服务器处理请求；</p>
<p>5.返回响应结果；</p>
<p>6.关闭TCP连接；</p>
<p>7.浏览器解析HTML；</p>
<p>8.浏览器布局渲染；</p>
<a id="more"></a>

<h3 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h3><p>我们在浏览器输入网址，其实就是要向服务器请求我们想要的页面内容，所有浏览器首先要确认的是域名所对应的服务器在哪里。将域名解析成对应的服务器IP地址这项工作，是由DNS服务器来完成的。</p>
<p>客户端收到你输入的域名地址后，一般会经历以下几个步骤：</p>
<ol>
<li><p>Chrome浏览器会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有<a href="http://www.baidu.com对应的条目，而且没有过期，如果有且没有过期则解析到此结束。" target="_blank" rel="noopener external nofollow noreferrer">www.baidu.com对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</a></p>
<pre><code>注：我们怎么查看Chrome自身的缓存？可以使用 
chrome://net-internals/#dns 来进行查看</code></pre></li>
<li><p>如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</p>
<pre><code>注：怎么查看操作系统自身的DNS缓存，以Windows系统为
例，可以在命令行下使用 ipconfig /displaydns 来进行查看</code></pre></li>
<li><p>如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p>
</li>
<li><p>如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问<a href="http://www.baidu.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.baidu.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.baidu.com" rel="external nofollow noreferrer">www.baidu.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.baidu.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.baidu.com</a>  对应的IP地址，该进行一步的动作了。</p>
</li>
</ol>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/1.png" alt></p>
<h3 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h3><p>费了一顿周折终于拿到服务器IP了，下一步自然就是链接到该服务器。对于客户端与服务器的TCP链接，必然要说的就是『三次握手』。</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/2.png" alt></p>
<p><strong>为什么HTTP协议要基于TCP来实现？</strong></p>
<p>目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</p>
<h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><p>与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）：</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/3.png" alt></p>
<p>请求报文<br>在浏览器中查看报文首部（以google浏览器为例）：</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/4.png" alt></p>
<p>请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。具体每个首部字段的作用，这里不做过多阐述。</p>
<h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><p>服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/5.png" alt></p>
<h3 id="返回响应结果"><a href="#返回响应结果" class="headerlink" title="返回响应结果"></a>返回响应结果</h3><p>在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构：</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/6.png" alt></p>
<p>响应报文</p>
<p>在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。</p>
<p>状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类：</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/7.png" alt></p>
<h3 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h3><p>为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/8.png" alt></p>
<h3 id="浏览器解析HTML"><a href="#浏览器解析HTML" class="headerlink" title="浏览器解析HTML"></a>浏览器解析HTML</h3><p>准确地说，浏览器需要加载解析的不仅仅是HTML，还包括CSS、JS。以及还要加载图片、视频等其他媒体资源。</p>
<p>浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。</p>
<p>要注意的是，浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题</p>
<h3 id="浏览器布局渲染"><a href="#浏览器布局渲染" class="headerlink" title="浏览器布局渲染"></a>浏览器布局渲染</h3><p>根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。</p>
<p>replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。</p>
<p>reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。<br>所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。</p>
<p>最后浏览器绘制各个节点，将页面展示给用户。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ thread用法总结</title>
    <url>/2020/04/04/C-thread%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>C++11中加入了<thread>头文件，此头文件主要声明了std::thread线程类。C++11的标准类std::thread对线程进行了封装，定义了C++11标准中的一些表示线程的类、用于互斥访问的类与方法等。应用C++11中的std::thread便于多线程程序的移值。</thread></p>
<a id="more"></a>
<p>std::thread类成员函数：</p>
<p>(1)、get_id：获取线程ID，返回一个类型为std::thread::id的对象。</p>
<p>(2)、joinable：检查线程是否可被join。检查thread对象是否标识一个活动(active)的可行性线程。缺省构造的thread对象、已经完成join的thread对象、已经detach的thread对象都不是joinable。</p>
<p>(3)、join：调用该函数会阻塞当前线程。阻塞调用者(caller)所在的线程直至被join的std::thread对象标识的线程执行结束。</p>
<p>(4)、detach：将当前线程对象所代表的执行实例与该线程对象分离，使得线程的执行可以单独进行。一旦线程执行完毕，它所分配的资源将会被释放。</p>
<p>(5)、native_handle：该函数返回与std::thread具体实现相关的线程句柄。native_handle_type是连接thread类和操作系统SDK API之间的桥梁，如在Linux g++(libstdc++)里，native_handle_type其实就是pthread里面的pthread_t类型，当thread类的功能不能满足我们的要求的时候(比如改变某个线程的优先级)，可以通过thread类实例的native_handle()返回值作为参数来调用相关的pthread函数达到目录。This member function is only present in class thread if the library implementation supports it. If present, it returns a value used to access implementation-specific information associated to the thread.</p>
<p>(6)、swap：交换两个线程对象所代表的底层句柄。</p>
<p>(7)、operator=：moves the thread object</p>
<p>(8)、hardware_concurrency：静态成员函数，返回当前计算机最大的硬件并发线程数目。基本上可以视为处理器的核心数目。</p>
<p>另外，std::thread::id表示线程ID，定义了在运行时操作系统内唯一能够标识该线程的标识符，同时其值还能指示所标识的线程的状态。Values of this type are returned by thread::get_id and this_thread::get_id to identify threads.</p>
<p>有时候我们需要在线程执行代码里面对当前调用者线程进行操作，针对这种情况，C++11里面专门定义了一个命名空间this_thread，此命名空间也声明在<thread>头文件中，其中包括get_id()函数用来获取当前调用者线程的ID；yield()函数可以用来将调用者线程跳出运行状态，重新交给操作系统进行调度，即当前线程放弃执行，操作系统调度另一线程继续执行；sleep_until()函数是将线程休眠至某个指定的时刻(time point),该线程才被重新唤醒；sleep_for()函数是将线程休眠某个指定的时间片(time span)，该线程才被重新唤醒，不过由于线程调度等原因，实际休眠实际可能比sleep_duration所表示的时间片更长。</thread></p>
<h3 id="1-创建一个线程"><a href="#1-创建一个线程" class="headerlink" title="1.创建一个线程"></a>1.创建一个线程</h3><p>创建线程比较简单，使用std的thread实例化一个线程对象就创建完成了，示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //sleep</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span>  <span class="comment">//普通的函数，用来执行线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"t1111\n"</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"t22222\n"</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(t1)</span></span>;  <span class="comment">//实例化一个线程对象th1，使用函数t1构造，然后该线程就开始执行了（t1()）</span></span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(t2)</span></span>;</span><br><span class="line"> </span><br><span class="line">    th1.join(); <span class="comment">// 必须将线程join或者detach 等待子线程结束主进程才可以退出</span></span><br><span class="line">    th2.join(); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//or use detach</span></span><br><span class="line">    <span class="comment">//th1.detach();</span></span><br><span class="line">    <span class="comment">//th2.detach();</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"here is main\n\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述提到的问题，还可以使用detach来解决，detach是用来和线程对象分离的，这样线程可以独立地执行，不过这样由于没有thread对象指向该线程而失去了对它的控制，当对象析构时线程会继续在后台执行，但是当主程序退出时并不能保证线程能执行完。如果没有良好的控制机制或者这种后台线程比较重要，最好不用detach而应该使用join。</p>
<h3 id="2-mutex和std-lock-guard的使用"><a href="#2-mutex和std-lock-guard的使用" class="headerlink" title="2. mutex和std::lock_guard的使用"></a>2. mutex和std::lock_guard的使用</h3><p>头文件是#include <mutex>，mutex是用来保证线程同步的，防止不同的线程同时操作同一个共享数据。</mutex></p>
<p>但使用lock_guard则相对安全，它是基于作用域的，能够自解锁，当该对象创建时，它会像m.lock()一样获得互斥锁，当生命周期结束时，它会自动析构(unlock)，不会因为某个线程异常退出而影响其他线程。示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lockGuard</span><span class="params">(m)</span></span>;</span><br><span class="line">       <span class="comment">// std::m.lock();</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//sleep(1);</span></span><br><span class="line">            --cnt;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// std::m.unlock();</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lockGuard</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="comment">// std::m.lock();</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// std::m.unlock();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">th1</span><span class="params">(t1)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">th2</span><span class="params">(t2)</span></span>;</span><br><span class="line"> </span><br><span class="line">	th1.join();    <span class="comment">//等待t1退出</span></span><br><span class="line">	th2.join();    <span class="comment">//等待t2退出</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"here is the main()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果，cnt是依次递减的，没有因为多线程而打乱次序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="function">here is the <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++虚函数与纯虚函数区别和重载的概念</title>
    <url>/2020/04/04/C-%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>虚函数是在类中添加函数的修饰关键字“Virtual”，且对它进行定义，这时函数变被指定为虚函数。格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CInterFace</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func_Virtual</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。</p>
<h3 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h3><p>为了方便使用多态特性，常常需要在基类中定义虚函数。下面顺便列出C++实现多态的三个条件：</p>
<p>（1）在基类中将这些成员函数声明为虚函数，并实现（必须要实现）。</p>
<p>（2）在派生类中也声明这些成员函数并实现（必须实现），基类和派生类的这些函数必须同名，而且其形参个数和类型，返回值类型必须与基类中的这些函数完全相同。</p>
<p>（3）将派生类对象赋给基类的指针变量或者引用。至此，多态实现，可用基类指针或引用调用派生类的方法（符合多态条件的方法，而不是普通方法）。</p>
<p>相应的不是多态的情况：</p>
<p>（1）基类中声明为虚函数，派生类中也声明为虚函数，并且也同名。但是派生类中该函数的形参类型或者形参个数和基类中的不相同。此时，多态不满足，派生类和基类的这两个虚函数仅仅是隐藏关系，没有虚特性。</p>
<p>（2）基类中声明为虚函数，派生类中也声明了一个同名函数，但没有使用virtual，并且形参类型或者形参个数和基类不相同。这时候基类中的虚函数也丢失虚特性，派生类的该函数不会被虚化，当然也就够不成多态，这两个函数也仅仅是隐藏关系。</p>
<p>（3）基类中的函数不是虚函数，派生类中声明为虚函数，它们同名，这时也够不成多态，派生类的虚函数没有虚特性，它们也是隐藏关系。</p>
<p>（4）基类和派生类的两个函数同名，都是虚函数，形参的个数和类型也都相同，但是返回值类型不同，这时编译会报错，因为两个虚函数在隐藏时，返回值类型发生了冲突，因此隐藏发生错误。注意，如果这两个函数不是虚函数，这不会报错，隐藏会成功；同时，如果派生类中是虚函数，基类中不是虚函数，也不过报错，隐藏也是成功的。这也说明，虚化并隐藏时，返回值类型一定要保持相同。</p>
<h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>是通过虚函数表机制来实现的，当类中存在虚函数时，编译器会在类中自动生成一个虚函数表，并由编译器自动生成和维护，virtual 修饰的成员函数会被编译器放入虚函数表中。</p>
<p>虚表指针：指向自己所使用的虚表</p>
<p>虚函数表:虚函数表是顺序存放虚函数地址的，虚表是顺序表，表里存放了虚函数的地址。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>纯虚函数是在基类中声明的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。</p>
<p>在基类中实现纯虚函数的方法是在函数原型后加“=0”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CInterFace</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func_PureVirtual</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。包含纯虚函数的类叫做抽象类（ 也叫接口类） ， 抽象类不能实例化出对象。 纯虚函数在派生类中重新定义以后， 派生类才能实例化出对象。</p>
<h2 id="虚函数和纯虚函数总结"><a href="#虚函数和纯虚函数总结" class="headerlink" title="虚函数和纯虚函数总结"></a>虚函数和纯虚函数总结</h2><ol>
<li><p>虚函数的定义形式：virtual {method body}   纯虚函数的定义形式：virtual { } = 0;</p>
</li>
<li><p>虚函数和纯虚函数可定义在同一个类(class)中，含有纯虚函数的类是抽象类(abstract class)，而含有虚函数的类则不是。</p>
</li>
<li><p>虚函数可以被直接使用，也可以被子类(sub class)重载以后以多态的形式调用，而纯虚函数必须在子类(sub class)中实现该函数才可以使用，因为纯虚函数在基类(base class)只有声明而没有定义。</p>
</li>
<li><p>在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时候要求前期bind,然而虚函数却是动态绑定(run-time bind)，而且被两者修饰的函数生命周期(life recycle)也不一样。</p>
</li>
</ol>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>就是函数或者方法有相同的名称，但是参数列表不同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。</p>
<p>重载的规则：<br>   1、在使用重载时只能通过相同的方法名、不同的参数形式实现。不同的参数可以是参数类型，参数个数，参数顺序（参数类型必须不一样）；</p>
<p>   2、不能通过访问权限、返回类型、抛出的异常进行重载；</p>
<p>   3、方法的异常类型和数目不会对重载造成影响；</p>
<p>成员函数被重载的特征：</p>
<p>（1）相同的范围（在同一个类中）； </p>
<p>（2）函数名字相同； </p>
<p>（3）参数不同； </p>
<p>（4）virtual 关键字可有可无 。</p>
<p><strong>函数重载在同一个作用域内。</strong>，重载绝对不会发生在基类和派生类之间，在同一个类中，重载函数之间必须依靠形参个数或者形参类型来进行区分，不能依靠返回类型。</p>
<h3 id="函数重载与虚函数的区别"><a href="#函数重载与虚函数的区别" class="headerlink" title="函数重载与虚函数的区别"></a>函数重载与虚函数的区别</h3><p>1.函数重载可以用于非成员函数和类的成员函数，而虚函数只能用于类的成员函数</p>
<p>2.函数重载可用于构造函数，而虚函数不能用于构造函数</p>
<p>3.如果对成员函数进行重载，重载的函数与被重载的函数应该是用一个类中的成员函数，不能分属于两个不同继承层次的类，函数重载处理的是横向的重载。虚函数是对同一类族中的基类和派生类的同名函数的处理，即允许在派生类中对基类的成员函数重新定义。虚函数处理的是纵向的同名函数。</p>
<p>4.重载的函数必须具有相同的函数名，函数类型可以相同也可以不同，但函数的参数个数和参数类型二者中至少有一个不同，否则在编译时无法区分。而虚函数则要求同一类族中的所有虚函数的函数名，函数类型，函数的参数个数和参数类型都全部相同，否则就不是重定义了，也就不是虚函数了</p>
<p>5.函数重载是在程序编译阶段确定操作的对象的，属于静态关联。虚函数是在程序运行阶段确定操作对象的，属于动态关联。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈总结</title>
    <url>/2020/04/04/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>单调栈主要回答这样的几种问题</p>
<ul>
<li><p>比当前元素更大的下一个元素</p>
</li>
<li><p>比当前元素更大的前一个元素</p>
</li>
<li><p>比当前元素更小的下一个元素</p>
</li>
<li><p>比当前元素更小的前一个元素</p>
<a id="more"></a>
<p>单调栈的一大优势就是<strong>线性的时间复杂度</strong>，所有的元素只会进栈一次，而且一旦出栈后就不会再进来了。</p>
<p><strong>单调递增栈可以找到左起第一个比当前数字小的元素</strong>。比如数组 [2 1 4 6 5]，刚开始2入栈，数字1入栈的时候，发现栈顶元素2比较大，将2移出栈，此时1入栈。那么2和1都没左起比自身小的数字。然后数字4入栈的时候，栈顶元素1小于4，于是1就是4左起第一个小的数字。此时栈里有1和4，然后数字6入栈的时候，栈顶元素4小于6，于是4就是6左起第一个小的数字。此时栈里有1，4，6，然后数字5入栈的时候，栈顶元素6大于5，将6移除，此时新的栈顶元素4小于5，那么4就是5左起的第一个小的数字，最终栈内数字为1，4，5。</p>
<p>同样的道理，<strong>单调递减栈可以找到左起第一个比当前数字大的元素</strong>。</p>
<h3 id="LeetCode-42：接雨水-（单调递减栈）"><a href="#LeetCode-42：接雨水-（单调递减栈）" class="headerlink" title="LeetCode 42：接雨水 （单调递减栈）"></a>LeetCode 42：接雨水 （单调递减栈）</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
</li>
</ul>
<p><img src="/2020/04/04/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/1.png" alt></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>
<p>分析：</p>
<p>必须两边高，中间低可以装下水，就可以使用一个单调递减栈，将递减的边界存进去，一旦发现当前的数字大于栈顶元素了，那么就有可能会有能装水的地方产生。此时我们当前的数字是右边界，我们从栈中至少需要有两个数字，才能形成一个坑槽，先取出的那个最小的数字，就是坑槽的最低点，再次取出的数字就是左边界，我们比较左右边界，取其中较小的值为装水的边界，然后此高度减去水槽最低点的高度，乘以左右边界间的距离就是装水量了。由于需要知道左右边界的位置，所以我们虽然维护的是递减栈，但是栈中数字并不是存递减的高度，而是递减的高度的坐标。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =<span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty() || <span class="built_in">height</span>[i] &lt; <span class="built_in">height</span>[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span> (s.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> h = <span class="built_in">min</span>(<span class="built_in">height</span>[s.top()],<span class="built_in">height</span>[i]) -  <span class="built_in">height</span>[t];</span><br><span class="line">                <span class="keyword">int</span> w = i-s.top()<span class="number">-1</span>;</span><br><span class="line">                res += h*w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-84：柱状图中最大的矩形（单调递增栈）"><a href="#LeetCode-84：柱状图中最大的矩形（单调递增栈）" class="headerlink" title="LeetCode 84：柱状图中最大的矩形（单调递增栈）"></a>LeetCode 84：柱状图中最大的矩形（单调递增栈）</h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="/2020/04/04/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/2.png" alt></p>
<p>分析：就是找两边第一个小于它的值，比如height[i]，以第i根柱子为最矮柱子所能延伸的最大面积，是以i 为中心，向左找第一个小于 heights[i] 的位置 left_i；向右找第一个小于于 heights[i] 的位置 right_i，即最大面积为 heights[i] * (right_i - left_i -1)，如下图所示:</p>
<p><img src="/2020/04/04/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/3.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 单调递增栈，为保证所有元素都出栈，最后加一个0</span></span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty() || heights[i] &gt; heights[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 出栈是计算以栈顶元素高度为矩形长的最大矩形面积</span></span><br><span class="line">                <span class="keyword">int</span> t = s.top();  </span><br><span class="line">                <span class="comment">// height[t]高度为最高，寻找左右两端小于高度heights[t]的坐标,右边小于高度t的坐标为i，</span></span><br><span class="line">                <span class="comment">// 如果出栈后不为空，则左边小于高度t的坐标为s.top(), 因为维持递增序列，</span></span><br><span class="line">                <span class="comment">// 出栈后下一个栈顶是小于高度t的，为空则说明左边没有小于高度t的</span></span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    w = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 注意-1</span></span><br><span class="line">                    w = i - s.top() - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, heights[t] * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-496：下一个更大元素-I（单调递减栈-哈希表）"><a href="#LeetCode-496：下一个更大元素-I（单调递减栈-哈希表）" class="headerlink" title="LeetCode 496：下一个更大元素 I（单调递减栈+哈希表）"></a>LeetCode 496：下一个更大元素 I（单调递减栈+哈希表）</h3><p>给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字2，第二个数组中的下一个较大数字是3。</span><br><span class="line">    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 单调递减栈 寻找nums2数组对应元素右起的比它大的数</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;n2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty()|| nums2[i]&lt;s.top())</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(nums2[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                m[t] = nums2[i]; </span><br><span class="line">                <span class="comment">// 哈希表存储对应的数字的下一个更大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 没有更大的数</span></span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            m[s.top()] = <span class="number">-1</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(m[num]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-503：下一个更大元素-II（单调不增栈）"><a href="#LeetCode-503：下一个更大元素-II（单调不增栈）" class="headerlink" title="LeetCode 503：下一个更大元素 II（单调不增栈）"></a>LeetCode 503：下一个更大元素 II（单调不增栈）</h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<p>如果不是循环数组，就可以写成如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty()||nums[i]&lt;nums[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                res[t] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>循环数组形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="comment">// 循环数组，相当于复制两次数组，遍历两次，一般环形利用取模运算来实现</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="number">2</span>*n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty() || nums[i%n] &lt;= nums[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(i%n);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="comment">// 只用考虑出栈的元素，在栈里边的不用考虑</span></span><br><span class="line">                res[t] = nums[i%n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-739：-每日温度（单调不增栈）"><a href="#LeetCode-739：-每日温度（单调不增栈）" class="headerlink" title="LeetCode 739： 每日温度（单调不增栈）"></a>LeetCode 739： 每日温度（单调不增栈）</h3><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>分析：</p>
<p>利用单调不增栈，当当前元素严格大于栈顶元素才出栈。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = T.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty() || T[i] &lt;= T[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                res[t] = i-t;  <span class="comment">//  注意返回的是两坐标之差</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>至于最后一点要说的就是，如何确定是使用严格单调栈还是非严格单调栈？<strong>只要根据题意确定我们栈中是否可以存放相同元素即可</strong></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找算法总结</title>
    <url>/2020/04/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="二分查找算法总结"><a href="#二分查找算法总结" class="headerlink" title="二分查找算法总结"></a>二分查找算法总结</h1><p>二分查找法作为一种常见的查找方法，将原本是线性时间提升到了对数时间范围，大大缩短了搜索时间，具有很大的应用场景，而在 LeetCode 中，要运用二分搜索法来解的题目也有很多，但是实际上二分查找法的查找目标有很多种，而且在细节写法也有一些变化。我就对二分查找法的具体写法做个总结。</p>
<a id="more"></a>
<h2 id="基础-二分查找的框架"><a href="#基础-二分查找的框架" class="headerlink" title="基础: 二分查找的框架"></a>基础: 二分查找的框架</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>,<span class="built_in">end</span> = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid =  start + (<span class="built_in">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) </span><br><span class="line">        &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) </span><br><span class="line">        &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析二分查找的一个技巧是：不要出现 <code>else</code>，而是把所有情况用 <code>else if</code> 写清楚，这样可以清楚地展现所有细节。本文都会使用 <code>else if</code>，旨在讲清楚，读者理解后可自行简化。</p>
<p>其中 … 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p>
<p>另外声明一下，计算 <code>mid</code> 时需要技巧防止溢出，在 <code>start</code> 和 <code>end</code> 都比较大的时候，<code>start + end</code> 很有可能超过 <code>int</code> 类型能表示的最大值，即整型溢出，为了避免这个问题，应该写成： <code>mid=start+(end-start)/2</code>。事实上，<code>int mid = start + (end - start) / 2</code> 在 <code>end</code> 很大、 <code>start</code> 是负数且很小的时候， <code>end - start</code> 也有可能超过 <code>int</code> 类型能表示的最大值，只不过一般情况下 <code>end</code> 和 <code>start</code> 表示的是数组索引值，<code>start</code> 是非负数，因此 <code>end - start</code> 溢出的可能性很小。更好的写法是：<code>int mid = (start + end) &gt;&gt;&gt; 1</code> .</p>
<h2 id="第一类：寻找一个数（基本的二分查找）"><a href="#第一类：寻找一个数（基本的二分查找）" class="headerlink" title="第一类：寻找一个数（基本的二分查找）"></a>第一类：寻找一个数（基本的二分查找）</h2><p>这是最简单的一类，也是我们最开始学二分查找法需要解决的问题,即搜索一个数，如果存在，返回其索引，否则返回 -1，比如我们有数组 <code>[2, 4, 5, 6, 9]</code>，<code>target = 6</code>，那么我们可以写出二分查找法的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">end</span>&gt;=start)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = start + (<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid]==target)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        start = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Q&amp;A:</strong></p>
<p>1.为什么<code>while</code>循环的条件中是 &lt;=，而不是 &lt; ？</p>
<p>答：因为初始化 <code>end</code> 的赋值是 <code>n-1</code>，即最后一个元素的索引，而不是 <code>n</code>。<br>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[start, end]</code>，后者相当于左闭右开区间 <code>[start, end)</code>，因为索引大小为 <code>n</code> 是越界的。</p>
<p>我们这个算法中使用的是前者 <code>[start, end]</code> 两端都闭的区间。这个区间其实就是每次进行搜索的区间，我们称之为「搜索区间」。</p>
<p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br></pre></td></tr></table></figure>
<p>但如果没找到，就需要 <code>while</code> 循环终止，然后返回 <code>-1</code>。那 <code>while</code> 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到。</p>
<p><code>while(start &lt;= end)</code> 的终止条件是 <code>start == end + 1</code>，写成区间的形式就是 <code>[end + 1, end]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见这时候搜索区间为空，这时候 <code>while</code> 循环终止是正确的，直接返回 <code>-1</code> 即可。</p>
<p><code>while(start &lt; end)</code> 的终止条件是 <code>start == end</code>，写成区间的形式就是 <code>[start, end]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，这时候搜索区间非空，还有一个数<code>2</code>，但此时 <code>while</code> 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 <code>2</code>没有被搜索，如果这时候直接返回 <code>-1</code> 就是错误的。</p>
<p>2.为什么 <code>start = mid + 1</code>，<code>end = mid - 1</code>？我看有的代码是 <code>start = mid</code> 或者 <code>end = mid</code>，没有这些加1减1，如何判断？</p>
<p>答：这也是二分查找的一个难点，刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[start, end]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，如何确定下一步的搜索区间呢？</p>
<p>当然是 <code>[start, mid - 1]</code> 或者 <code>[mid + 1, end]</code> 对不对？因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除。</p>
<p>3.此算法有什么缺陷？</p>
<p>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</p>
<p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target = 2</code>，此算法返回的索引是 <code>2</code>，没错。但是如果我们想得到 <code>target</code> 的左侧边界，即索引 <code>1</code>，或者我想得到 <code>target</code> 的右侧边界，即索引 <code>3</code>，这样的话此算法是无法处理的。</p>
<p>这样的需求很常见。你也许会说，找到一个 <code>target</code>，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。</p>
<p>我们后续的算法就来讨论这两种二分查找的算法。</p>
<h2 id="第二类：寻找左侧边界的二分搜索"><a href="#第二类：寻找左侧边界的二分搜索" class="headerlink" title="第二类：寻找左侧边界的二分搜索"></a>第二类：寻找左侧边界的二分搜索</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">end</span>&gt;start)  <span class="comment">// 搜索区间左闭右开</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = start + (<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid]==target)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">end</span> = mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        start = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">end</span> = mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// start == n时说明target比所有数都大，不存在返回-1</span></span><br><span class="line">    <span class="comment">// if (nums[start]!=target || start == n) return -1;</span></span><br><span class="line">    <span class="comment">// 返回start是返回的数组中的坐标，就是小于某个数的坐标</span></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Q&amp;A:</strong></p>
<p>1.为什么 <code>while(start &lt; end)</code> 而不是 <code>&lt;=</code>?</p>
<p>答：用相同的方法分析，因为 <code>end = n</code> 而不是 <code>n - 1</code> 。因此每次循环的「搜索区间」是 <code>[start, end)</code> 左闭右开。<br><code>while(start &lt; end)</code> 终止的条件是 <code>start == end</code>，此时搜索区间 <code>[start, start)</code>或者写成<code>[end, end)</code>为空，所以可以正确终止。</p>
<p>2.如何理解左侧边界？</p>
<p>答：</p>
<p><img src="/2020/04/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1.png" alt="1"></p>
<p>对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：<code>nums</code> 中小于 2的元素有 1 个。</p>
<p>比如对于有序数组 <code>nums = [2,3,5,7]</code>, <code>target = 1</code>，算法会返回 <code>0</code>，含义是：<code>nums</code> 中小于 1 的元素有 0 个。</p>
<p>再比如说 <code>nums</code> 不变，<code>target = 8</code>，算法会返回 4，含义是：<code>nums</code> 中小于 8 的元素有 4 个。</p>
<p>综上可以看出，函数的返回值（即 <code>start</code> 变量的值）取值区间是闭区间 <code>[0, n]</code>，如果start的值为<code>n</code>或者<code>nums[start]!=target</code>说明数组中没有目标值，返回-1</p>
<p>3.为什么 <code>start = mid + 1</code>，<code>end = mid</code> ？和之前的算法不一样？</p>
<p>答：这个很好解释，因为我们的「搜索区间」是 <code>[start, end)</code> <strong>左闭右开</strong>，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 <code>[start, mid)</code> 或 <code>[mid + 1, end)</code>。</p>
<p>4.为什么该算法能够搜索左侧边界？</p>
<p>答:关键在于对于 nums[mid] == target 这种情况的处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">    <span class="built_in">end</span> = mid;</span><br></pre></td></tr></table></figure>
<p>可见，找到 <code>target</code> 时不要立即返回，而是缩小「搜索区间」的上界 <code>end</code>，在区间 <code>[start, end)</code> 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p>
<p>5.为什么返回 <code>start</code> 而不是 <code>end</code>？</p>
<p>答：都是一样的，因为 <code>while</code> 终止的条件是 <code>start == end</code>。</p>
<h2 id="第三类：寻找右侧边界的二分查找"><a href="#第三类：寻找右侧边界的二分查找" class="headerlink" title="第三类：寻找右侧边界的二分查找"></a>第三类：寻找右侧边界的二分查找</h2><p>寻找右侧边界和寻找左侧边界的代码差不多，只有两处不同，已标注：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">end</span>&gt;start)  <span class="comment">// 搜索区间左开右闭</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = start + (<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid]==target)</span><br><span class="line">      &#123;</span><br><span class="line">        start = mid + <span class="number">1</span>;  <span class="comment">// 注意 增大左边界，向右收缩</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        start = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">end</span> = mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span><span class="number">-1</span>;  <span class="comment">//注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Q&amp;A:</strong></p>
<ol>
<li>为什么这个算法能够找到右侧边界？</li>
</ol>
<p>答：类似地，关键点还是这里：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid]==target)</span><br><span class="line">    start = mid + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>当 <code>nums[mid] == target</code> 时，不要立即返回，而是增大「搜索区间」的下界 <code>start</code>，使得区间不断向右收缩，达到锁定右侧边界的目的。</p>
<p>2.为什么最后返回 <code>end - 1</code> 而不像左侧边界的函数，返回 <code>start</code>？而且我觉得这里既然是搜索右侧边界，应该返回 <code>end</code> 才对。</p>
<p>答：首先，<code>while</code> 循环的终止条件是 <code>start == end</code>，所以 <code>start</code> 和 <code>end</code> 是一样的，要体现右侧的特点，返回 <code>end - 1</code> 好了。</p>
<p>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">    start = mid + <span class="number">1</span>;<span class="comment">//等价于：mid = start - 1</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/2.png" alt="2"></p>
<p>因为我们对 <code>start</code> 的更新必须是 <code>start = mid + 1</code>，就是说 <code>while</code> 循环结束时，<code>nums[start]</code> 一定不等于 <code>target</code> 了，而 <code>nums[start-1]</code> 可能是 <code>target</code>,也就是<code>return end-1</code>。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>来梳理一下这些细节差异的因果逻辑：</p>
<p>第一个，最基本的二分查找算法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因为我们初始化 end &#x3D; nums.size() - 1</span><br><span class="line">所以决定了我们的「搜索区间」是 [start, end]</span><br><span class="line">所以决定了 while (start &lt;&#x3D; end)</span><br><span class="line">同时也决定了 start &#x3D; mid+1 和 end &#x3D; mid-1</span><br><span class="line"></span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] &#x3D;&#x3D; target 时可以立即返回</span><br></pre></td></tr></table></figure>

<p>第二个，寻找左侧边界的二分查找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因为我们初始化 end &#x3D; nums.size()</span><br><span class="line">所以决定了我们的「搜索区间」是 [start, end)</span><br><span class="line">所以决定了 while (start &lt; end)</span><br><span class="line">同时也决定了 start &#x3D; mid + 1 和 end &#x3D; mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] &#x3D;&#x3D; target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br></pre></td></tr></table></figure>

<p>第三个，寻找右侧边界的二分查找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因为我们初始化 end &#x3D; nums.size()</span><br><span class="line">所以决定了我们的「搜索区间」是 (start, end]</span><br><span class="line">所以决定了 while (start &lt; end)</span><br><span class="line">同时也决定了 start &#x3D; mid + 1 和 end &#x3D; mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] &#x3D;&#x3D; target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line"></span><br><span class="line">又因为收紧左侧边界时必须 start &#x3D; mid + 1</span><br><span class="line">所以最后无论返回 start 还是 end，必须减一</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++二维数组按行遍历和按列遍历的区别</title>
    <url>/2020/04/03/C-%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E5%92%8C%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>按行遍历的效率更高。</p>
<p>数组在内存中是按行储存的，按行遍历时可以由指向数组第一个数的指针一直往下走，就可以遍历完整个数组，而按列遍历则要获得指向每一列的第一行的元素的指针，然后每次将指针指下一行，但是指针的寻址很快，所以不会有明显的区别。</p>
<a id="more"></a>

<p>按行遍历比按列遍历效率高具体体现在以下几点</p>
<p>1、<a href="https://zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98" target="_blank" rel="noopener external nofollow noreferrer">CPU高速缓存</a></p>
<p>计算机存在Cache机制，当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在，则不经访问内存直接返回该数据；如果不存在，则要先把内存中的相应数据载入缓存，再将其返回处理器。</p>
<p>缓存从内存中抓取一般都是整个数据块，所以它的物理内存是连续的，几乎都是同行不同列的，而如果内循环以列的方式进行遍历的话，将会使整个缓存块无法被利用，而不得不从内存中读取数据，而从内存读取速度是远远小于从缓存中读取数据的。</p>
<p>2、分页调度</p>
<p>物理内存是以页的方式进行划分的，当一个二维数组很大是如 int[128][1024],假设一页的内存为4096个字节，而每一行正好占据内存的一页（int 存储是4个字节），如果以列的形式进行遍历，就会发生128*1024次的页面调度，而如果以行遍历则只有128次页面调度，而页面调度是有时间消耗的，因而调度次数越多，遍历的时间就越长。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>vector扩容原理说明</title>
    <url>/2020/04/02/vector%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h3 id="扩容原理概述"><a href="#扩容原理概述" class="headerlink" title="扩容原理概述"></a>扩容原理概述</h3><ul>
<li>新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素</li>
<li>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了</li>
<li>初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1</li>
<li>不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。<a id="more"></a>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.push_back(i);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><ul>
<li>GCC输出</li>
</ul>
<p><img src="/2020/04/02/vector%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E/1.png" alt></p>
<ul>
<li>VS2015输出</li>
</ul>
<p><img src="/2020/04/02/vector%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E/2.png" alt></p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><ul>
<li><p>可以根据输出看到，vector是以2倍的方式扩容的。有两个疑问：</p>
<ul>
<li>为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？</li>
<li>为什么是以两倍的方式扩容而不是三倍四倍，或者其他方式呢？</li>
</ul>
</li>
<li><p>第一个问题：</p>
<ul>
<li><p>以成倍方式增长</p>
<ol>
<li>假定有 n 个元素,倍增因子为 m；</li>
<li>完成这 n 个元素往一个 vector 中的 push_back​操作，需要重新分配内存的次数大约为 logm(n)；</li>
<li>第 i 次重新分配将会导致复制 m^(i) (也就是当前的vector.size() 大小)个旧空间中元素;</li>
<li>n 次 push_back 操作所花费的时间复制度为O(n):<br>$$<br>\sum_{i=1}^{\log _{n}^{n}} m^{i} \approx \frac{n m}{m-1}<br>$$</li>
<li>m / (m - 1)，这是一个常量，均摊分析的方法可知，vector 中 push_back 操作的时间复杂度为常量时间.​</li>
</ol>
</li>
<li><p>一次增加固定值大小</p>
<ol>
<li>假定有 n 个元素,每次增加k个；</li>
<li>第i次增加复制的数量为为：100i</li>
<li>n 次 push_back 操作所花费的时间复杂度为O(n^2):<br>$$\sum_{i=1}^{n / k} k i$$</li>
<li>均摊下来每次push_back 操作的时间复杂度为O(n)；</li>
</ol>
</li>
</ul>
</li>
<li><p>总结：对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。</p>
</li>
<li><p>第二个问题：</p>
<ol>
<li><p>根据查阅的资料显示，考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2二倍的方式扩容，或者以1.5倍的方式扩容。</p>
</li>
<li><p>以2倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间:</p>
<p>$$k \sum_{i=0}^{n} 2^{i}=k\left(2^{n+1}-1\right)&lt;k 2^{n+1}$$</p>
<p><a href="https://www.zhihu.com/question/36538542/answer/67929747" target="_blank" rel="noopener external nofollow noreferrer">知乎上看到一个很好的解释</a></p>
</li>
</ol>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。</p>
</li>
<li><p>为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，更好一点。</p>
</li>
</ol>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://blog.csdn.net/yangshiziping/article/details/52550291" target="_blank" rel="noopener external nofollow noreferrer">vector扩容原理说明</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ vector拷贝使用总结</title>
    <url>/2020/04/02/C-vector%E6%8B%B7%E8%B4%9D%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>一些vector拷贝使用的细节，挖过填过的坑，记录一下。</p>
<p>主要有以下几种方法</p>
<h3 id="初始化构造时拷贝（深复制）"><a href="#初始化构造时拷贝（深复制）" class="headerlink" title="初始化构造时拷贝（深复制）"></a>初始化构造时拷贝（深复制）</h3><p>这种拷贝，相当于复制了一份数据，array中的数据不变。 如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">outArray</span><span class="params">(<span class="built_in">array</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="利用拷贝赋值操作符（深复制）"><a href="#利用拷贝赋值操作符（深复制）" class="headerlink" title="利用拷贝赋值操作符（深复制）"></a>利用拷贝赋值操作符（深复制）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; outArray;</span><br><span class="line">outArray = <span class="built_in">array</span>;</span><br></pre></td></tr></table></figure>

<h3 id="利用assign-函数（清空并深复制）"><a href="#利用assign-函数（清空并深复制）" class="headerlink" title="利用assign()函数（清空并深复制）"></a>利用assign()函数（清空并深复制）</h3><p>一样的复制了一份数据，array中的数据不变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; outArray&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">outArray.assign(<span class="built_in">array</span>.<span class="built_in">begin</span>(),<span class="built_in">array</span>.<span class="built_in">end</span>());<span class="comment">//清空原数据，赋予新数据=&#123;3,5,2,6,4&#125;</span></span><br><span class="line">outArray.assign(<span class="number">5</span>, <span class="number">0</span>);<span class="comment">//5个0，清空原数据=&#123;0,0,0,0,0,&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="利用swap-函数（交换两个vector）"><a href="#利用swap-函数（交换两个vector）" class="headerlink" title="利用swap()函数（交换两个vector）"></a>利用swap()函数（交换两个vector）</h3><p>会清空原vector数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; outArray;<span class="comment">//设为空</span></span><br><span class="line">outArray.swap(<span class="built_in">array</span>);<span class="comment">//清空array数组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; outArray&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">outArray.swap(<span class="built_in">array</span>);<span class="comment">//outArray=&#123;3,5,2,6,4&#125;；array=&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++单例模式Singleton的实现</title>
    <url>/2020/04/01/C-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FSingleton%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="问题情景"><a href="#问题情景" class="headerlink" title="问题情景"></a>问题情景</h3><p>在windows下面打开任务管理器，我们会发现，你只能打开一个任务管理器。如果在已打开一个任务管理器的情况下，再次打开任务管理器，系统会调出已经打开的窗口，而不是重新打开新的窗口。在系统中，之多只能存在一个任务管理器的实例。按照一般的思路，我们需要定义一个TaskManager的类（如下）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TaskManager()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>但这存在问题，只要我们调用一次初始化函数，系统就会生成一个TaskManager的实例，不能保证系统中之多只存在一个实例的要求。于是我们需要采用设计模式中的单例模式（Singleton）来实现。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>单例模式的两个功能：仅有一个实例和全局访问点。我们通过Singleton的类图来看一下这个模式：</p>
<p><img src="/2020/04/01/C-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FSingleton%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png" alt></p>
<p>在Singleton中，类的初始化函数被设为了private，这就意味着Client是不能通过调用类的初始化函数来生成一个实例，防止Client多次调用初始化函数生成多个实例出来。如果要访问Singleton，需要通过GetInstance方法，这是一个静态的方法，主要负责创建自己的实例，返回实例的指针给Client。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)<span class="comment">//第一次调用要判断指针是否为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                p_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Singleton()&#123;&#125;; <span class="comment">//构造函数设计成私有的</span></span><br><span class="line">        <span class="keyword">static</span> Singleton *p_instance; <span class="comment">//用类的指针指向唯一的实例</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//静态数据成员是静态存储的，必须对他进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *object = Singleton::GetInstance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Singleton类封装了它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单的说就是对唯一实例的受控访问。一般的，Singleton不会定义析构函数，由于实例分配的是全局地址，在程序运行结束，被系统收回所有分配空间时，Singleton才会被销毁，如果Singleton成员数据太多的话，可能占用了大量的内存空间而不能被释放，这需要我们注意。</p>
<h3 id="Singleton与全局变量的区别"><a href="#Singleton与全局变量的区别" class="headerlink" title="Singleton与全局变量的区别"></a>Singleton与全局变量的区别</h3><p>Singleton与全局变量都有全局访问的功能，但两者之间存在一些差别，全局变量在使用的过程中会存在一些问题：</p>
<ul>
<li>变量名冲突：必须小心维护变量名，每遇到一个全局变量，都必须仔细分辨该变量属于哪个模块、哪个程序。</li>
<li>耦合度难题：使用全局变量增加了函数与模块间的耦合程度，不易维护。</li>
<li>单个实体问题：全局变量不能防止一个类生成多个实例出来。</li>
<li>多线程访问：并发访问时需要使用同步机制，小心保护全局变量，避免冲突。</li>
</ul>
<p>看起来，使用Singleton可以避免上面的这些问题，但Singleton自身也有一些弊端。</p>
<h3 id="Singleton的优缺点"><a href="#Singleton的优缺点" class="headerlink" title="Singleton的优缺点"></a>Singleton的优缺点</h3><p>Singleton的优点：</p>
<ul>
<li>跨平台：使用合适的中间件可以把Singleton扩展为跨多个计算机工作。</li>
<li>适用于任何类：只要将初始化函数设为私有，并增加相应的静态函数和变量，就能把类变成Singleton。</li>
<li>延迟性：如果Singleton从未使用，就不会创建（仅指懒汉模式）</li>
</ul>
<p>Singleton的缺点：</p>
<ul>
<li>效率问题：由于if语句的存在，调用方法的效率收到影响。</li>
<li>不变重用：在C++下需要定义模板才能实现Singleton的重用。</li>
</ul>
<h3 id="Singleton的懒汉模式与饿汉模式"><a href="#Singleton的懒汉模式与饿汉模式" class="headerlink" title="Singleton的懒汉模式与饿汉模式"></a>Singleton的懒汉模式与饿汉模式</h3><p>针对Singleton初始化函数的调用策略，有两种选择，分别是懒汉模式和饿汉模式。</p>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><p>使用懒汉模式时，Singleton在程序第一次调用的时候才会初始化自己，代码如下。使用该模式时，由于if语句的存在，会影响调用的效率。而且，在多线程环境下使用时，为了保证只能初始化一个实例，需要用锁来保证线程安全性，防止同时多个线程进入if语句中。如果遇到处理大量数据时，锁会成为整个性能的瓶颈。一般懒汉模式适用于程序一部分中需要使用Singleton，且在实例化后没有大量频繁访问或线程访问的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mtx.lock();</span><br><span class="line">                <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    p_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">                mtx.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Singleton()&#123;&#125;; <span class="comment">//构造函数设计成私有的</span></span><br><span class="line">        <span class="keyword">static</span> Singleton *p_instance; <span class="comment">//用类的指针指向唯一的实例</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//静态数据成员是静态存储的，必须对他进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *object = Singleton::GetInstance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>PS:
GCC在Linux下的std::mutex工作良好。 然而，在Windows上很遗憾，
_GLIBCXX_HAS_GTHREADS没有在Windows上定义。mutex运行时支持是不存在的。</code></pre><h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>使用饿汉模式时，Singleton在程序一开始就将自己实例化，之后的GetInstance方法仅返回实例的指针即可，这样就解决了上述提到的if语句影响效率的问题。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Singleton* p_instance = <span class="keyword">new</span> Singleton();<span class="comment">//在此直接实例化</span></span><br><span class="line">        Singleton()&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>饿汉模式适用于Singleton在程序运行过程中一直被频繁调用，这样由于预先加载了实例，访问实例时没有if语句，效率更高。但要注意到，如果Singleton的成员比较庞大、复杂，实例化Singleton会花一些时间，且这个实例一直占用着大量内存，在使用时要注意这部分的开销。使用饿汉模式用于多线程编程的话，由于线程访问之前，实例已存在，就不需要像懒汉模式中加入锁，因此饿汉模式保证了多线程安全。饿汉模式比较适用于程序整个运行过程中都需要访问、会被频繁访问或者需要被多线程访问的情况。</p>
<pre><code>PS:
类名加*，有两种作用情况：
1. 用于定义时，或用于函数参数，返回值时，表示对应变量值为类指针类型；
2. 用于变量前，以(CLASS_NAME *)var_name，形式出现时，表示将变量或
常量var_name强制转换为类指针类型。</code></pre>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++源文件到可执行文件的过程</title>
    <url>/2020/04/01/C-%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>对于C/C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤：</p>
<p>1、预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。</p>
<p>2、编译：将预处理后的文件转换成汇编语言，生成.s文件</p>
<p>3、汇编：汇编变为目标代码(机器代码)生成.o的文件</p>
<p>4、链接：连接目标代码,生成可执行程序</p>
<a id="more"></a>
<p>程序的基本流程如图：</p>
<p><img src="/2020/04/01/C-%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/1.jfif" alt></p>
<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>预处理主要包含下面的内容：</p>
<ul>
<li>对所有的“#define”进行宏展开；</li>
<li>处理所有的条件编译指令，比如“#if”,“#ifdef”，“#elif”，“#else”,“#endif”</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归的，也就是说被包含的文件可能还包含其他文件</li>
<li>删除所有的注释“//”和“/**/”</li>
<li>添加行号和文件标识</li>
<li>保留所有的“#pragma”编译器指令</li>
</ul>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>将预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后，产生相应的汇编代码文件(.s文件)。</p>
<h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p>汇编器是将汇编代码转变成机器可以执行的代码，每一个汇编语句几乎都对应一条机器指令。最终产生目标文件(.o或.obj文件)。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>连接目标代码,生成可执行程序。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针详解</title>
    <url>/2020/04/01/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>智能指针分为三种：shared_ptr, unique_ptr, weak_ptr。本文就是详细介绍一下智能指针，作为笔记，方便理解。</p>
<p>智能指针的作用是动态分配内存，避免内存泄漏。</p>
<a id="more"></a>
<pre><code>PS:
内存泄漏：
    程序没有释放已经不再使用的内存，由于设计错误，导致在释放该段内存
    之前就失去了对该段内存的控制，因此这段内存一直被占用，无法释放，造
    成空间的浪费。

内存溢出：
    要求分配的内存超过了系统所能给我的，系统不能满足需求。内存泄漏的堆
    积如果不及时处理最终会导致内存溢出。</code></pre><h2 id="shared-ptr介绍"><a href="#shared-ptr介绍" class="headerlink" title="shared_ptr介绍"></a>shared_ptr介绍</h2><p>shared_ptr是一个引用计数智能指针，用于共享对象的所有权，也就是说它允许多个指针指向同一个对象</p>
<h3 id="shared-ptr的简单使用："><a href="#shared-ptr的简单使用：" class="headerlink" title="shared_ptr的简单使用："></a>shared_ptr的简单使用：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Example() : e(<span class="number">1</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Example Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">        ~Example() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Example Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Example&gt; <span class="title">pInt</span><span class="params">(<span class="keyword">new</span> Example())</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*pInt).e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pInt引用计数: "</span> &lt;&lt; pInt.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Example&gt; pInt2 = pInt;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pInt引用计数: "</span> &lt;&lt; pInt.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pInt2引用计数: "</span> &lt;&lt; pInt2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Example Constructor...</span><br><span class="line">pInt: <span class="number">1</span></span><br><span class="line">pInt引用计数: <span class="number">1</span></span><br><span class="line">pInt引用计数: <span class="number">2</span></span><br><span class="line">pInt2引用计数: <span class="number">2</span></span><br><span class="line">Example Destructor...</span><br></pre></td></tr></table></figure>
<p>从上面这段代码中，我们对shared_ptr指针有了一些直观的了解。一方面，跟STL中大多数容器类型一样，shared_ptr也是模板类，因此在创建shared_ptr时需要指定其指向的类型。另一方面，正如其名一样，shared_ptr指针允许让多个该类型的指针共享同一堆分配对象。同时shared_ptr使用经典的“引用计数”方法来管理对象资源，每个shared_ptr对象关联一个共享的引用计数。</p>
<p>对于shared_ptr在拷贝和赋值时的行为，《C++Primer第五版》中有详细的描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个shared_ptr都有一个关联的计数值，通常称为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。</span><br><span class="line"></span><br><span class="line">例如，当用一个shared_ptr初始化另一个shred_ptr，或将它当做参数传递给一</span><br><span class="line">个函数以及作为函数的返回值时，它所关联的计数器就会递增。</span><br><span class="line"></span><br><span class="line">当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的</span><br><span class="line">shared_ptr离开其作用域）时，计数器就会递减。一旦一个shared_ptr的计数</span><br><span class="line">器变为0，它就会自动释放自己所管理的对象。</span><br></pre></td></tr></table></figure>

<p>对比我们上面的代码可以看到：当我们将一个指向Example对象的指针交给pInt管理后，其关联的引用计数为1。接下来，我们用pInt初始化pInt2，两者关联的引用计数值增加为2。随后，函数结束，pInt和PInt2相继离开函数作用于，相应的引用计数值分别自减1最后变为0，于是Example对象被自动释放（调用其析构函数）。</p>
<h3 id="shared-ptr的常见用法"><a href="#shared-ptr的常见用法" class="headerlink" title="shared_ptr的常见用法"></a>shared_ptr的常见用法</h3><h4 id="1、创建shared-ptr实例"><a href="#1、创建shared-ptr实例" class="headerlink" title="1、创建shared_ptr实例"></a>1、创建shared_ptr实例</h4><p>最安全和高效的方法是调用make_shared库函数，该函数会在堆中分配一个对象并初始化，最后返回指向此对象的share_ptr实例。如果你不想使用make_ptr，也可以先明确new出一个对象，然后把其原始指针传递给share_ptr的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递给make_shared函数的参数必须和shared_ptr所指向类型的某个构造函数相匹配</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pStr = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pStr &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//  aaaaaaaaaa</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pInt</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pInt &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、访问所指对象"><a href="#2、访问所指对象" class="headerlink" title="2、访问所指对象"></a>2、访问所指对象</h4><p>shared_ptr的使用方式与普通指针的使用方式类似，既可以使用解引用操作符*获得原始对象进而访问其各个成员，也可以使用指针访问符-&gt;来访问原始对象的各个成员。</p>
<h4 id="3、拷贝和赋值操作"><a href="#3、拷贝和赋值操作" class="headerlink" title="3、拷贝和赋值操作"></a>3、拷贝和赋值操作</h4><p>我们可以用一个shared_ptr对象来初始化另一个share_ptr实例，该操作会增加其引用计数值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pStr = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//  1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pStr2</span><span class="params">(pStr)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//  2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr2.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//  2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果shared_ptr实例p和另一个shared_ptr实例q所指向的类型相同或者可以相互转换，我们还可以进行诸如p = q这样赋值操作。该操作会递减p的引用计数值，递增q的引用计数值。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Example(<span class="built_in">string</span> n) : name(n) &#123; <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~Example() &#123; <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Example&gt; pStr = make_shared&lt;Example&gt;(<span class="string">"a object"</span>);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Example&gt; pStr2 = make_shared&lt;Example&gt;(<span class="string">"b object"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    pStr = pStr2;   <span class="comment">// 此后pStr和pStr指向相同对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr2-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a object constructor...</span><br><span class="line">b object constructor...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">a object destructor...</span><br><span class="line">b object</span><br><span class="line">b object</span><br><span class="line">b object destructor...</span><br></pre></td></tr></table></figure>

<h4 id="4、检查引用计数"><a href="#4、检查引用计数" class="headerlink" title="4、检查引用计数"></a>4、检查引用计数</h4><p>shared_ptr提供了两个函数来检查其共享的引用计数值，分别是unique()和use_count()。</p>
<p>在前面，我们已经多次使用过use_count()函数，该函数返回当前指针的引用计数值。值得注意的是use_count()函数可能效率很低，应该只把它用于测试或调试。</p>
<p>unique()函数用来测试该shared_ptr是否是原始指针唯一拥有者，也就是use_count()的返回值为1时返回true，否则返回false。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pStr = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr.unique() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pStr2</span><span class="params">(pStr)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr2.unique() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// false;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="weak-ptr介绍"><a href="#weak-ptr介绍" class="headerlink" title="weak_ptr介绍"></a>weak_ptr介绍</h2><p>在正式介绍weak_ptr之前，我们先来回忆一下shared_ptr的一些知识。我们知道shared_ptr是采用引用计数的智能指针，多个shared_ptr实例可以指向同一个动态对象，并维护了一个共享的引用计数器。对于引用计数法实现的计数，总是避免不了循环引用（或环形引用）的问题，shared_ptr也不例外。</p>
<p>我们先来看看下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassB&gt; pb;  <span class="comment">// 在A中引用B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassA&gt; pa;  <span class="comment">// 在B中引用A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassA&gt; spa = make_shared&lt;ClassA&gt;();</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassB&gt; spb = make_shared&lt;ClassB&gt;();</span><br><span class="line">    spa-&gt;pb = spb;</span><br><span class="line">    spb-&gt;pa = spa;</span><br><span class="line">    <span class="comment">// 函数结束，思考一下：spa和spb会释放资源么？</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClassA Constructor...</span><br><span class="line">ClassB Constructor...</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>从上面代码中，ClassA和ClassB间存在着循环引用，从运行结果中我们可以看到：当main函数运行结束后，spa和spb管理的动态资源并没有得到释放，产生了内存泄漏。</p>
<p>为了解决类似这样的问题，C++11引入了weak_ptr，来打破这种循环引用。</p>
<p>weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。</p>
<h3 id="weak-ptr用法"><a href="#weak-ptr用法" class="headerlink" title="weak_ptr用法"></a>weak_ptr用法</h3><h4 id="1、创建weak-ptr实例"><a href="#1、创建weak-ptr实例" class="headerlink" title="1、创建weak_ptr实例"></a>1、创建weak_ptr实例</h4><p>当我们创建一个weak_ptr时，需要用一个shared_ptr实例来初始化weak_ptr，由于是弱共享，weak_ptr的创建并不会影响shared_ptr的引用计数值。</p>
<p>示例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建前sp的引用计数："</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// use_count = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建后sp的引用计数："</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// use_count = 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、判断weak-ptr指向对象是否存在"><a href="#2、判断weak-ptr指向对象是否存在" class="headerlink" title="2、判断weak_ptr指向对象是否存在"></a>2、判断weak_ptr指向对象是否存在</h4><p>既然weak_ptr并不改变其所共享的shared_ptr实例的引用计数，那就可能存在weak_ptr指向的对象被释放掉这种情况。这时，我们就不能使用weak_ptr直接访问对象。那么我们如何判断weak_ptr指向对象是否存在呢？C++中提供了lock函数来实现该功能。如果对象存在，lock()函数返回一个指向共享对象的shared_ptr，否则返回一个空shared_ptr。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : a(<span class="number">3</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;A&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="comment">//sp.reset();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">shared_ptr</span>&lt;A&gt; pa = wp.lock())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pa-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"wp指向对象为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把sp.reset()这行的注释去掉会导致wp指向对象为空。</p>
<p>weak_ptr还提供了expired()函数来判断所指对象是否已经被销毁。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : a(<span class="number">3</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;A&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    sp.reset(); <span class="comment">// 此时sp被销毁</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; wp.expired() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// true表示已被销毁，否则为false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A Constructor...</span><br><span class="line">A Destructor...</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="3、具体使用weak-ptr"><a href="#3、具体使用weak-ptr" class="headerlink" title="3、具体使用weak_ptr"></a>3、具体使用weak_ptr</h4><p>weak_ptr并没有重载operator-&gt;和operator *操作符，因此不可直接通过weak_ptr使用对象，典型的用法是调用其lock函数来获得shared_ptr示例，进而访问原始对象.</p>
<p>下面使用weak_ptr来改造最前面的代码，打破循环引用问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    weak_ptr&lt;ClassB&gt; pb;  <span class="comment">// 在A中引用B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    weak_ptr&lt;ClassA&gt; pa;  <span class="comment">// 在B中引用A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassA&gt; spa = make_shared&lt;ClassA&gt;();</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassB&gt; spb = make_shared&lt;ClassB&gt;();</span><br><span class="line">    spa-&gt;pb = spb;</span><br><span class="line">    spb-&gt;pa = spa;</span><br><span class="line">    <span class="comment">// 函数结束，思考一下：spa和spb会释放资源么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从运行结果可以看到spa和spb指向的对象都得到释放。</p>
<h2 id="unique-ptr介绍"><a href="#unique-ptr介绍" class="headerlink" title="unique_ptr介绍"></a>unique_ptr介绍</h2><p>unique是独特的、唯一的意思，故名思议，unique_ptr可以“独占”地拥有它所指向的对象，它提供一种严格意义上的所有权。这一点和我们前面介绍的shared_ptr类型指针有很大的不同：shared_ptr允许多个指针指向同一对象，而unique_ptr在某一时刻只能有一个指针指向该对象。unique_ptr保存指向某个对象的指针，当它本身被删除或者离开其作用域时会自动释放其指向对象所占用的资源。</p>
<p>下图演示了两个 unique_ptr 实例之间的所有权转换。</p>
<p><img src="/2020/04/01/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/unique_ptr.png" alt></p>
<h3 id="unique-ptr的基本特性"><a href="#unique-ptr的基本特性" class="headerlink" title="unique_ptr的基本特性"></a>unique_ptr的基本特性</h3><h4 id="1、创建unique-ptr"><a href="#1、创建unique-ptr" class="headerlink" title="1、创建unique_ptr"></a>1、创建unique_ptr</h4><p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个unique_ptr实例</span></span><br><span class="line">    <span class="comment">// unique_ptr&lt;int&gt; pInt(new int(5));</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、无法进行复制构造和赋值操作"><a href="#2、无法进行复制构造和赋值操作" class="headerlink" title="2、无法进行复制构造和赋值操作"></a>2、无法进行复制构造和赋值操作</h4><p>unique_ptr没有copy构造函数，不支持普通的拷贝和赋值操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个unique_ptr实例</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pInt2</span><span class="params">(pInt)</span></span>;    <span class="comment">// 报错</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt3 = pInt;   <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、可以进行移动构造和移动赋值操作"><a href="#3、可以进行移动构造和移动赋值操作" class="headerlink" title="3、可以进行移动构造和移动赋值操作"></a>3、可以进行移动构造和移动赋值操作</h4><p>unique_ptr虽然没有支持普通的拷贝和赋值操作，但却提供了一种移动机制来将指针的所有权从一个unique_ptr转移给另一个unique_ptr。如果需要转移所有权，可以使用std::move()函数。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt2 = <span class="built_in">std</span>::<span class="built_in">move</span>(pInt);    <span class="comment">// 转移所有权</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *pInt &lt;&lt; endl; // 出错，pInt为空</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pInt2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pInt3</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(pInt2))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、可以返回unique-ptr"><a href="#4、可以返回unique-ptr" class="headerlink" title="4、可以返回unique_ptr"></a>4、可以返回unique_ptr</h4><p>unique_ptr不支持拷贝操作，但却有一个例外：可以从函数中返回一个unique_ptr。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> pInt;    <span class="comment">// 返回unique_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ret = clone(p);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr使用场景"><a href="#unique-ptr使用场景" class="headerlink" title="unique_ptr使用场景"></a>unique_ptr使用场景</h3><h4 id="1、为动态申请的资源提供异常安全保证"><a href="#1、为动态申请的资源提供异常安全保证" class="headerlink" title="1、为动态申请的资源提供异常安全保证"></a>1、为动态申请的资源提供异常安全保证</h4><p>我们先来看看下面这一段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（可能会抛出异常）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是我们传统的写法：当我们动态申请内存后，有可能我们接下来的代码由于抛出异常或者提前退出（if语句）而没有执行delete操作。</p>
<p>解决的方法是使用unique_ptr来管理动态内存，只要unique_ptr指针创建成功，其析构函数都会被调用。确保动态资源被释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（可能会抛出异常）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、返回函数内动态申请资源的所有权"><a href="#2、返回函数内动态申请资源的所有权" class="headerlink" title="2、返回函数内动态申请资源的所有权"></a>2、返回函数内动态申请资源的所有权</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Func</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> pInt;    <span class="comment">// 返回unique_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ret = Func(p);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 函数结束后，自动释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、在容器中保存指针"><a href="#3、在容器中保存指针" class="headerlink" title="3、在容器中保存指针"></a>3、在容器中保存指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; p= make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    vec.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(p));    <span class="comment">// 使用移动语义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、管理动态数组"><a href="#4、管理动态数组" class="headerlink" title="4、管理动态数组"></a>4、管理动态数组</h4><p>标准库提供了一个可以管理动态数组的unique_ptr版本。</p>
<p>可以使用make_unique来创建一个到数组的 unique_ptr，但不能使用 make_unique 来初始化数组元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// unique_ptr&lt;int[]&gt; p(new int[5] &#123;1, 2, 3, 4, 5&#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a unique_ptr to an array of 5 integers.</span></span><br><span class="line">    <span class="keyword">auto</span> p = make_unique&lt;<span class="keyword">int</span>[]&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the array.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        wcout &lt;&lt; p[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">// 重载了operator[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、作为auto-ptr的替代品"><a href="#5、作为auto-ptr的替代品" class="headerlink" title="5、作为auto_ptr的替代品"></a>5、作为auto_ptr的替代品</h4>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>语音识别</title>
    <url>/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>整个语音识别系统主要构成有四个部分：语音信号处理和特征的提取模块；语音识别的声学模型；语音识别的语言模型；语音识别的解码和搜索部分。系统流程图如下图所示：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/1.png" alt></p>
<a id="more"></a>
<p>整个语音识别的过程可以用贝叶斯理论来描述，假设输入的音频序列为$O={o_{1}, o_{2}, \cdots, o_{n}}$，输出为文本序列为$W={w_{1}, w_{2}, \cdots, w_{n}}$。目的是构建一个模型，使得$\prod_{n} P\left(W_{n} | O_{n}\right)$最大，也就是训练集中n个样本的后验概率最大。单独拿出一个样本的后验概率使用贝叶斯公式可以得到：</p>
<p>$$P(W | O)=\frac{P(O | W) * P(W)}{P(O)}$$</p>
<p>进一步可得:</p>
<p>$$W^{*}=\operatorname{argmax}_{W} P(O | W) * P(W)$$</p>
<p>这里$P(W)$是输出词序列的概率，用语言模型来刻画，$P(O | W)$为似然概率，使用声学模型来表达。</p>
<h3 id="数据集构建"><a href="#数据集构建" class="headerlink" title="数据集构建"></a>数据集构建</h3><p>语音数据构建主要分为两种，一是公开数据集—&gt;日常对话，二是特定数据集—&gt;控制命令。</p>
<p>所搜集的公开语音数据集是<a href="http://www.openslr.org/18/" target="_blank" rel="noopener external nofollow noreferrer">THCHS30</a>、<a href="http://cn-mirror.openslr.org/resources/38/ST-CMDS-20170001_1-OS.tar.gz" target="_blank" rel="noopener external nofollow noreferrer">ST-CMDS</a>、<a href="http://cn-mirror.openslr.org/resources/33/data_aishell.tgz" target="_blank" rel="noopener external nofollow noreferrer">AIShell</a>等数据集，这几个数据集是中文语音数据集，基本数据格式如下图所示:</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/2.png" alt></p>
<p>基本信息如下：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/3.png" alt></p>
<p>针对实际的工业控制命令，我们进行专门的语音采集和录制。环境是和实际的泵站控制室一致，安静、近场。这里使用单粒麦克风进行录制，录制的格式与上边格式一致。</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/4.png" alt></p>
<h3 id="语音信号预处理"><a href="#语音信号预处理" class="headerlink" title="语音信号预处理"></a>语音信号预处理</h3><p>语音信号预处理是为了将原始语音信号转换成CNN网络输入的语谱图。CNN的输入层是200维的特征值序列。输出拼音的表示大小是1422，即1421个拼音+1个空白块。预测结果是返回语音识别后的拼音符号列表。</p>
<p>语音信号的预处理过程用到的技术是：预加重（pre-emphasis）、<br>分帧（enframing）、加窗（windowing)</p>
<h4 id="预加重"><a href="#预加重" class="headerlink" title="预加重"></a>预加重</h4><p>预加重可以使得语音信号的频谱信号分布更加均衡。预加重一般是用<br>60db/octave数字滤波器频率特性完成的。过滤器公式给出：</p>
<p>$$H(z)=1-u z^{-1}$$</p>
<p>其中$u$是预加重系数。</p>
<h4 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a>分帧</h4><p>使用预先设计好的窗函数处理被分帧分成的多个小片段。通过这种方法在一定程度上解决语音信号帧信号之间的不连续性问题。每一个小段作为语音信的单位，称为帧（frame）。以帧为单位可以分析语音信号的短时特性，从而进一步进行频谱等处理。分帧一般相邻帧之间有交叉重叠，交叉部分叫做帧移，帧移一般定为帧长度的一半。</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/5.png" alt></p>
<h4 id="加窗"><a href="#加窗" class="headerlink" title="加窗"></a>加窗</h4><p>对语音信号增加一个窗函数（Window Function），在语音信号的给定区间内限定为一个实数，其它部分为0。使用的是汉明窗（Hamming Window）汉明窗的时间域表达给出:</p>
<p>$$w(n)=0.54-0.46 \cos \left(\frac{2 \pi n}{N-1}\right)$$</p>
<p>其中$𝑛$是时间，$w(n)$是窗函数。</p>
<h4 id="语谱图特征提取"><a href="#语谱图特征提取" class="headerlink" title="语谱图特征提取"></a>语谱图特征提取</h4><p>语谱图（Spectrogram）是语音处理的一个重要特征，是一种描述语音信号的各个频率成分随着时间变换的热力图。</p>
<p>语谱图包含着语音信号的重要信息，用一个二维矩阵表示。其中一个轴表示时间，另外一个轴表示频率。不同的点或者颜色代表对应语音信号能量的大小。</p>
<p>语谱图的提取过程一般包括：采样、傅立叶变换、连续拼接。如下图所示：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/6.jpg" alt></p>
<p>原始语音信号是符合数据格式的后缀是.wav 的原始语音数据。这里定义一个函数，读取该原始语音数据，返回声音信号的时域谱矩阵和帧速率。具体函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">一些通用函数，如wav文件读取、信号出来和测试代码</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> python_speech_features <span class="keyword">import</span> mfcc</span><br><span class="line"><span class="keyword">from</span> python_speech_features <span class="keyword">import</span> delta</span><br><span class="line"><span class="keyword">from</span> python_speech_features <span class="keyword">import</span> logfbank</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_wav_data</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	读取一个wav文件，返回声音信号的时域谱矩阵和播放时间</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	wav = wave.open(filename,<span class="string">"rb"</span>) <span class="comment"># 打开一个wav格式的声音文件流</span></span><br><span class="line">	num_frame = wav.getnframes() <span class="comment"># 获取帧数</span></span><br><span class="line">	num_channel=wav.getnchannels() <span class="comment"># 获取声道数</span></span><br><span class="line">	framerate=wav.getframerate() <span class="comment"># 获取帧速率</span></span><br><span class="line">	num_sample_width=wav.getsampwidth() <span class="comment"># 获取实例的比特宽度，即每一帧的字节数</span></span><br><span class="line">	str_data = wav.readframes(num_frame) <span class="comment"># 读取全部的帧</span></span><br><span class="line">	wav.close() <span class="comment"># 关闭流</span></span><br><span class="line">	wave_data = np.fromstring(str_data, dtype = np.short) <span class="comment"># 将声音文件数据转换为数组矩阵形式</span></span><br><span class="line">	wave_data.shape = <span class="number">-1</span>, num_channel <span class="comment"># 按照声道数将数组整形，单声道时候是一列数组，双声道时候是两列的矩阵</span></span><br><span class="line">	wave_data = wave_data.T <span class="comment"># 将矩阵转置</span></span><br><span class="line">	<span class="keyword">return</span> wave_data, framerate  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetMfccFeature</span><span class="params">(wavsignal, fs)</span>:</span></span><br><span class="line">	<span class="comment"># 获取输入特征</span></span><br><span class="line">	feat_mfcc=mfcc(wavsignal[<span class="number">0</span>],fs)</span><br><span class="line">	feat_mfcc_d=delta(feat_mfcc,<span class="number">2</span>)</span><br><span class="line">	feat_mfcc_dd=delta(feat_mfcc_d,<span class="number">2</span>)</span><br><span class="line">	<span class="comment"># 返回值分别是mfcc特征向量的矩阵及其一阶差分和二阶差分矩阵</span></span><br><span class="line">	wav_feature = np.column_stack((feat_mfcc, feat_mfcc_d, feat_mfcc_dd))</span><br><span class="line">	<span class="keyword">return</span> wav_feature</span><br><span class="line"></span><br><span class="line">x=np.linspace(<span class="number">0</span>, <span class="number">400</span> - <span class="number">1</span>, <span class="number">400</span>, dtype = np.int64)</span><br><span class="line">w = <span class="number">0.54</span> - <span class="number">0.46</span> * np.cos(<span class="number">2</span> * np.pi * (x) / (<span class="number">400</span> - <span class="number">1</span>) ) <span class="comment"># 汉明窗</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFrequencyFeature3</span><span class="params">(wavsignal, fs)</span>:</span></span><br><span class="line">	<span class="comment"># wav波形 加时间窗以及时移10ms</span></span><br><span class="line">	time_window = <span class="number">25</span> <span class="comment"># 单位ms</span></span><br><span class="line">	window_length = fs / <span class="number">1000</span> * time_window <span class="comment"># 计算窗长度的公式，目前全部为400固定值</span></span><br><span class="line">	</span><br><span class="line">	wav_arr = np.array(wavsignal)</span><br><span class="line">	<span class="comment">#wav_length = len(wavsignal[0])</span></span><br><span class="line">	wav_length = wav_arr.shape[<span class="number">1</span>]</span><br><span class="line">	</span><br><span class="line">	range0_end = int(len(wavsignal[<span class="number">0</span>])/fs*<span class="number">1000</span> - time_window) // <span class="number">10</span> <span class="comment"># 计算循环终止的位置，也就是最终生成的窗数</span></span><br><span class="line">	data_input = np.zeros((range0_end, <span class="number">200</span>), dtype = np.float) <span class="comment"># 用于存放最终的频率特征数据</span></span><br><span class="line">	data_line = np.zeros((<span class="number">1</span>, <span class="number">400</span>), dtype = np.float)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, range0_end):</span><br><span class="line">		p_start = i * <span class="number">160</span></span><br><span class="line">		p_end = p_start + <span class="number">400</span></span><br><span class="line">		</span><br><span class="line">		data_line = wav_arr[<span class="number">0</span>, p_start:p_end]</span><br><span class="line">		</span><br><span class="line">		data_line = data_line * w <span class="comment"># 加窗</span></span><br><span class="line">		</span><br><span class="line">		data_line = np.abs(fft(data_line)) / wav_length</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		data_input[i]=data_line[<span class="number">0</span>:<span class="number">200</span>] <span class="comment"># 设置为400除以2的值（即200）是取一半数据，因为是对称的</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">#print(data_input.shape)</span></span><br><span class="line">	data_input = np.log(data_input + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> data_input</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wav_scale</span><span class="params">(energy)</span>:</span></span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	语音信号能量归一化</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	means = energy.mean() <span class="comment"># 均值</span></span><br><span class="line">	var=energy.var() <span class="comment"># 方差</span></span><br><span class="line">	e=(energy-means)/math.sqrt(var) <span class="comment"># 归一化能量</span></span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wav_show</span><span class="params">(wave_data, fs)</span>:</span> <span class="comment"># 显示出来声音波形</span></span><br><span class="line">	time = np.arange(<span class="number">0</span>, len(wave_data)) * (<span class="number">1.0</span>/fs)  <span class="comment"># 计算声音的播放时间，单位为秒</span></span><br><span class="line">	<span class="comment"># 画声音波形</span></span><br><span class="line">	<span class="comment">#plt.subplot(211)  </span></span><br><span class="line">	plt.plot(time, wave_data)  </span><br><span class="line">	<span class="comment">#plt.subplot(212)  </span></span><br><span class="line">	<span class="comment">#plt.plot(time, wave_data[1], c = "g")  </span></span><br><span class="line">	plt.show()  </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_wav_list</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	读取一个wav文件列表，返回一个存储该列表的字典类型值</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	txt_obj=open(filename,<span class="string">'r'</span>) <span class="comment"># 打开文件并读入</span></span><br><span class="line">	txt_text=txt_obj.read()</span><br><span class="line">	txt_lines=txt_text.split(<span class="string">'\n'</span>) <span class="comment"># 文本分割</span></span><br><span class="line">	dic_filelist=&#123;&#125; <span class="comment"># 初始化字典</span></span><br><span class="line">	list_wavmark=[] <span class="comment"># 初始化wav列表</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> txt_lines:</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="string">''</span>):</span><br><span class="line">			txt_l=i.split(<span class="string">' '</span>)</span><br><span class="line">			dic_filelist[txt_l[<span class="number">0</span>]] = txt_l[<span class="number">1</span>]</span><br><span class="line">			list_wavmark.append(txt_l[<span class="number">0</span>])</span><br><span class="line">	txt_obj.close()</span><br><span class="line">	<span class="keyword">return</span> dic_filelist,list_wavmark</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_wav_symbol</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	读取指定数据集中，所有wav文件对应的语音符号</span></span><br><span class="line"><span class="string">	返回一个存储符号集的字典类型值</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	txt_obj=open(filename,<span class="string">'r'</span>) <span class="comment"># 打开文件并读入</span></span><br><span class="line">	txt_text=txt_obj.read()</span><br><span class="line">	txt_lines=txt_text.split(<span class="string">'\n'</span>) <span class="comment"># 文本分割</span></span><br><span class="line">	dic_symbol_list=&#123;&#125; <span class="comment"># 初始化字典</span></span><br><span class="line">	list_symbolmark=[] <span class="comment"># 初始化symbol列表</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> txt_lines:</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="string">''</span>):</span><br><span class="line">			txt_l=i.split(<span class="string">' '</span>)</span><br><span class="line">			dic_symbol_list[txt_l[<span class="number">0</span>]]=txt_l[<span class="number">1</span>:]</span><br><span class="line">			list_symbolmark.append(txt_l[<span class="number">0</span>])</span><br><span class="line">	txt_obj.close()</span><br><span class="line">	<span class="keyword">return</span> dic_symbol_list,list_symbolmark</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span>(__name__==<span class="string">'__main__'</span>):</span><br><span class="line">	</span><br><span class="line">	wave_data, fs = read_wav_data(<span class="string">"A2_0.wav"</span>)  </span><br><span class="line">	</span><br><span class="line">	wav_show(wave_data[<span class="number">0</span>],fs)</span><br><span class="line">	t0=time.time()</span><br><span class="line">	freimg = GetFrequencyFeature(wave_data,fs)</span><br><span class="line">	t1=time.time()</span><br><span class="line">	print(<span class="string">'time cost:'</span>,t1-t0)</span><br><span class="line">	</span><br><span class="line">	freimg = freimg.T</span><br><span class="line">	plt.subplot(<span class="number">111</span>)</span><br><span class="line">	</span><br><span class="line">	plt.imshow(freimg)</span><br><span class="line">	plt.colorbar(cax=<span class="literal">None</span>,ax=<span class="literal">None</span>,shrink=<span class="number">0.5</span>)  </span><br><span class="line">	 </span><br><span class="line">	plt.show()</span><br></pre></td></tr></table></figure>

<p>原始语音信号经过处理后得到帧数、声道数、帧速率。然后读取全部帧数，再经过变换后转换成数组矩阵格式，该数组按照声道数进行数组整形，整形后数组转置得到时域谱矩阵，得到帧速率和时域谱矩阵。在得到帧速率和时域谱矩阵后，经过加窗、采样后、傅里叶变换，以及最后的连续拼接。流程图如下：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/7.png" alt></p>
<p>下图是采用上述代码对中文语音数据提取的波形图和语谱图的结果。波形图的横轴是时间，纵轴可以理解为位移或者压强。语谱图的横轴是拼接的时间，纵轴是频率。</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/8.png" alt></p>
<h3 id="声学模型设计训练"><a href="#声学模型设计训练" class="headerlink" title="声学模型设计训练"></a>声学模型设计训练</h3><p>声学模型输⼊入是语谱图，输出是拼音。如下图所示：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/9.png" alt></p>
<p>声学模型设计主要基于DFCNN网络进行训练，主要设计的结构和相应的参数设置如下：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/10.png" alt></p>
<p>参数设置：</p>
<p>Adam 的参数:<br>(lr = 0.01, beta_1 = 0.9,beta_2 = 0.999, decay = 0.0, epsilon = 10e-8)</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/11.png" alt></p>
<p>CTC是一种针对序列列深度模型的损失函数。相⽐比传统交叉熵损失函数能⾃自动对⻬齐序列列标签，端到端训练模型。具体参考<a href="https://blog.ailemon.me/2019/07/18/sequence-modeling-with-ctc/" target="_blank" rel="noopener external nofollow noreferrer">这里</a></p>
<p>使用Keras搭建序贯(Sequential)模型，部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">声学模型</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> platform <span class="keyword">as</span> plat</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> general_function.file_wav <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> general_function.file_dict <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> general_function.gen_func <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> general_function.muti_gpu <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> multi_gpu_model,plot_model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> keras <span class="keyword">as</span> kr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential, Model</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Input, Reshape, BatchNormalization <span class="comment"># , Flatten</span></span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Lambda, TimeDistributed, Activation,Conv2D, MaxPooling2D <span class="comment">#, Merge</span></span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD, Adadelta, Adam, RMSprop</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ReadData <span class="keyword">import</span> DataSpeech</span><br><span class="line"></span><br><span class="line">abspath = <span class="string">''</span></span><br><span class="line">ModelName=<span class="string">'_dfcnn'</span></span><br><span class="line"><span class="comment">#NUM_GPU = 2</span></span><br><span class="line">base_count=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelSpeech</span><span class="params">()</span>:</span> <span class="comment"># 语音模型类</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, datapath)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		初始化</span></span><br><span class="line"><span class="string">		默认输出的拼音的表示大小是1434，即1433个拼音+1个空白块</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		MS_OUTPUT_SIZE = <span class="number">1434</span></span><br><span class="line">		self.MS_OUTPUT_SIZE = MS_OUTPUT_SIZE <span class="comment"># 神经网络最终输出的每一个字符向量维度的大小</span></span><br><span class="line">		<span class="comment">#self.BATCH_SIZE = BATCH_SIZE # 一次训练的batch</span></span><br><span class="line">		self.label_max_string_length = <span class="number">64</span></span><br><span class="line">		self.AUDIO_LENGTH = <span class="number">1600</span>  <span class="comment">## 16s</span></span><br><span class="line">		self.AUDIO_FEATURE_LENGTH = <span class="number">200</span></span><br><span class="line">		self._model, self.base_model = self.CreateModel() </span><br><span class="line">		</span><br><span class="line">		self.datapath = datapath</span><br><span class="line">		self.slash = <span class="string">''</span></span><br><span class="line">		system_type = plat.system() <span class="comment"># 由于不同的系统的文件路径表示不一样，需要进行判断</span></span><br><span class="line">		<span class="keyword">if</span>(system_type == <span class="string">'Windows'</span>):</span><br><span class="line">			self.slash=<span class="string">'\\'</span> <span class="comment"># 反斜杠</span></span><br><span class="line">		<span class="keyword">elif</span>(system_type == <span class="string">'Linux'</span>):</span><br><span class="line">			self.slash=<span class="string">'/'</span> <span class="comment"># 正斜杠</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			print(<span class="string">'*[Message] Unknown System\n'</span>)</span><br><span class="line">			self.slash=<span class="string">'/'</span> <span class="comment"># 正斜杠</span></span><br><span class="line">		<span class="keyword">if</span>(self.slash != self.datapath[<span class="number">-1</span>]): <span class="comment"># 在目录路径末尾增加斜杠</span></span><br><span class="line">			self.datapath = self.datapath + self.slash</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">CreateModel</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		定义DFCNN模型，使用函数式模型  </span></span><br><span class="line"><span class="string">		输入层：200维的特征值序列，一条语音数据的最大长度设为1600（大约16s）</span></span><br><span class="line"><span class="string">		隐藏层：卷积池化层，卷积核大小为3x3，池化窗口大小为2</span></span><br><span class="line"><span class="string">		隐藏层：全连接层</span></span><br><span class="line"><span class="string">		输出层：全连接层，神经元数量为self.MS_OUTPUT_SIZE，使用softmax作为激活函数，</span></span><br><span class="line"><span class="string">		CTC层：使用CTC的loss作为损失函数，实现连接性时序多输出</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		</span><br><span class="line">		input_data = Input(name=<span class="string">'the_input'</span>, shape=(self.AUDIO_LENGTH, self.AUDIO_FEATURE_LENGTH, <span class="number">1</span>))</span><br><span class="line">		</span><br><span class="line">		layer_h1 = Conv2D(<span class="number">32</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">False</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(input_data) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h1 = BatchNormalization(mode=<span class="number">0</span>,axis=<span class="number">-1</span>)(layer_h1)</span><br><span class="line">		layer_h2 = Conv2D(<span class="number">32</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h1) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h2 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h2)</span><br><span class="line">		layer_h3 = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h2) <span class="comment"># 池化层 800*100</span></span><br><span class="line">		layer_h4 = Conv2D(<span class="number">64</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h3) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h4 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h4)</span><br><span class="line">		layer_h5 = Conv2D(<span class="number">64</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h4) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h5 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h5)</span><br><span class="line">		layer_h6 = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h5) <span class="comment"># 池化层 400*50</span></span><br><span class="line">		layer_h7 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h6) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h7 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h7)</span><br><span class="line">		layer_h8 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h7) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h8 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h8)</span><br><span class="line">		layer_h9 = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h8) <span class="comment"># 池化层 200*25</span></span><br><span class="line">		layer_h10 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h9) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h10 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h10)</span><br><span class="line">		layer_h11 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h10) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h11 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h11)</span><br><span class="line">		layer_h12 = MaxPooling2D(pool_size=<span class="number">1</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h11) <span class="comment"># 池化层 200*25</span></span><br><span class="line">		</span><br><span class="line">		layer_h13 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h12) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h13 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h13)</span><br><span class="line">		layer_h14 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h13) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h14 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h14)</span><br><span class="line">		layer_h15 = MaxPooling2D(pool_size=<span class="number">1</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h14) <span class="comment"># 池化层 None*200*25*128</span></span><br><span class="line">		</span><br><span class="line">		layer_h16 = Reshape((<span class="number">200</span>, <span class="number">3200</span>))(layer_h15)</span><br><span class="line">		layer_h17 = Dense(<span class="number">128</span>, activation=<span class="string">"relu"</span>, use_bias=<span class="literal">True</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h16) <span class="comment"># 全连接层</span></span><br><span class="line">		layer_h17 = BatchNormalization(axis=<span class="number">1</span>)(layer_h17)</span><br><span class="line">		layer_h18 = Dense(self.MS_OUTPUT_SIZE, use_bias=<span class="literal">True</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h17) <span class="comment"># 全连接层</span></span><br><span class="line">		layer_h18 = BatchNormalization(axis=<span class="number">1</span>)(layer_h18)</span><br><span class="line">		y_pred = Activation(<span class="string">'softmax'</span>, name=<span class="string">'Activation0'</span>)(layer_h18)</span><br><span class="line">		model_data = Model(inputs = input_data, outputs = y_pred)</span><br><span class="line">		model_data.summary()</span><br><span class="line">		</span><br><span class="line">		labels = Input(name=<span class="string">'the_labels'</span>, shape=[self.label_max_string_length], dtype=<span class="string">'float32'</span>)</span><br><span class="line">		input_length = Input(name=<span class="string">'input_length'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)</span><br><span class="line">		label_length = Input(name=<span class="string">'label_length'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)</span><br><span class="line">		<span class="comment"># Keras doesn't currently support loss funcs with extra parameters</span></span><br><span class="line">		<span class="comment"># so CTC loss is implemented in a lambda layer</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment"># CTC</span></span><br><span class="line">		loss_out = Lambda(self.ctc_lambda_func, output_shape=(<span class="number">1</span>,), name=<span class="string">'ctc'</span>)([y_pred, labels, input_length, label_length])</span><br><span class="line">		</span><br><span class="line">		model = Model(inputs=[input_data, labels, input_length, label_length], outputs=loss_out)</span><br><span class="line">		</span><br><span class="line">		opt = Adam(lr = <span class="number">0.001</span>, beta_1 = <span class="number">0.9</span>, beta_2 = <span class="number">0.999</span>, decay = <span class="number">0.0</span>, epsilon = <span class="number">10e-8</span>)</span><br><span class="line">		<span class="comment">#model.compile(loss=&#123;'ctc': lambda y_true, y_pred: y_pred&#125;, optimizer=sgd)</span></span><br><span class="line">		model.compile(loss=&#123;<span class="string">'ctc'</span>: <span class="keyword">lambda</span> y_true, y_pred: y_pred&#125;, optimizer = opt)</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># captures output of softmax so we can decode the output during visualization</span></span><br><span class="line">		test_func = K.function([input_data], [y_pred])</span><br><span class="line">		</span><br><span class="line">		print(<span class="string">'[*提示] 创建模型成功，模型编译成功'</span>)</span><br><span class="line">		<span class="keyword">return</span> model, model_data</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">ctc_lambda_func</span><span class="params">(self, args)</span>:</span></span><br><span class="line">		y_pred, labels, input_length, label_length = args</span><br><span class="line">		</span><br><span class="line">		y_pred = y_pred[:, :, :]</span><br><span class="line">		<span class="comment">#y_pred = y_pred[:, 2:, :]</span></span><br><span class="line">		<span class="keyword">return</span> K.ctc_batch_cost(labels, y_pred, input_length, label_length)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">TrainModel</span><span class="params">(self, datapath, epoch = <span class="number">2</span>, save_step = <span class="number">1000</span>, batch_size = <span class="number">32</span>, filename = abspath + <span class="string">'model_speech/m'</span> + ModelName + <span class="string">'/speech_model'</span>+ModelName)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		训练模型</span></span><br><span class="line"><span class="string">		参数：</span></span><br><span class="line"><span class="string">			datapath: 数据保存的路径</span></span><br><span class="line"><span class="string">			epoch: 迭代轮数</span></span><br><span class="line"><span class="string">			save_step: 每多少步保存一次模型</span></span><br><span class="line"><span class="string">			filename: 默认保存文件名，不含文件后缀名</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		data=DataSpeech(datapath, <span class="string">'train'</span>)</span><br><span class="line">		</span><br><span class="line">		num_data = data.GetDataNum() <span class="comment"># 获取数据的数量</span></span><br><span class="line">		</span><br><span class="line">		yielddatas = data.data_genetator(batch_size, self.AUDIO_LENGTH)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> epoch <span class="keyword">in</span> range(epoch): <span class="comment"># 迭代轮数</span></span><br><span class="line">			print(<span class="string">'[running] train epoch %d .'</span> % epoch)</span><br><span class="line">			n_step = <span class="number">0</span> <span class="comment"># 迭代数据数</span></span><br><span class="line">			<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">				<span class="keyword">try</span>:</span><br><span class="line">					print(<span class="string">'[message] epoch %d . Have train datas %d+'</span>%(epoch, n_step*save_step))</span><br><span class="line">					<span class="comment"># data_genetator是一个生成器函数</span></span><br><span class="line">					</span><br><span class="line">					<span class="comment">#self._model.fit_generator(yielddatas, save_step, nb_worker=2)</span></span><br><span class="line">					self._model.fit_generator(yielddatas, save_step)</span><br><span class="line">					n_step += <span class="number">1</span></span><br><span class="line">				<span class="keyword">except</span> StopIteration:</span><br><span class="line">					print(<span class="string">'[error] generator error. please check data format.'</span>)</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				</span><br><span class="line">				self.SaveModel(comment=<span class="string">'_e_'</span>+str(epoch)+<span class="string">'_step_'</span>+str(n_step * save_step))</span><br><span class="line">				self.TestModel(self.datapath, str_dataset=<span class="string">'train'</span>, data_count = <span class="number">4</span>)</span><br><span class="line">				self.TestModel(self.datapath, str_dataset=<span class="string">'dev'</span>, data_count = <span class="number">4</span>)</span><br><span class="line">				</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">LoadModel</span><span class="params">(self,filename = abspath + <span class="string">'model_speech/m'</span>+ModelName+<span class="string">'/speech_model'</span>+ModelName+<span class="string">'.model'</span>)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		加载模型参数</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		self._model.load_weights(filename)</span><br><span class="line">		self.base_model.load_weights(filename + <span class="string">'.base'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">SaveModel</span><span class="params">(self,filename = abspath + <span class="string">'model_speech/m'</span>+ModelName+<span class="string">'/speech_model'</span>+ModelName,comment=<span class="string">''</span>)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		保存模型参数</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		self._model.save_weights(filename + comment + <span class="string">'.model'</span>)</span><br><span class="line">		self.base_model.save_weights(filename + comment + <span class="string">'.model.base'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">TestModel</span><span class="params">(self, datapath=<span class="string">''</span>, str_dataset=<span class="string">'dev'</span>, data_count = <span class="number">32</span>,comment = <span class="string">''</span>, out_report = False, show_ratio = True, io_step_print = <span class="number">10</span>, io_step_file = <span class="number">10</span>)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		测试检验模型效果</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		io_step_print</span></span><br><span class="line"><span class="string">			为了减少测试时标准输出的io开销，可以通过调整这个参数来实现</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		io_step_file</span></span><br><span class="line"><span class="string">			为了减少测试时文件读写的io开销，可以通过调整这个参数来实现</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		data=DataSpeech(self.datapath, str_dataset)</span><br><span class="line">		<span class="comment">#data.LoadDataList(str_dataset) </span></span><br><span class="line">		num_data = data.GetDataNum() <span class="comment"># 获取数据的数量</span></span><br><span class="line">		<span class="keyword">if</span>(data_count &lt;= <span class="number">0</span> <span class="keyword">or</span> data_count &gt; num_data): <span class="comment"># 当data_count为小于等于0或者大于测试数据量的值时，则使用全部数据来测试</span></span><br><span class="line">			data_count = num_data</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			ran_num = random.randint(<span class="number">0</span>,num_data - <span class="number">1</span>) <span class="comment"># 获取一个随机数</span></span><br><span class="line">			</span><br><span class="line">			words_num = <span class="number">0</span></span><br><span class="line">			word_error_num = <span class="number">0</span></span><br><span class="line">			</span><br><span class="line">			nowtime = time.strftime(<span class="string">'%Y%m%d_%H%M%S'</span>,time.localtime(time.time()))</span><br><span class="line">			<span class="keyword">if</span>(out_report == <span class="literal">True</span>):</span><br><span class="line">				txt_obj = open(abspath+<span class="string">'Test_Report_'</span> + str_dataset + <span class="string">'_'</span> + nowtime + <span class="string">'.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="comment"># 打开文件并读入</span></span><br><span class="line">			</span><br><span class="line">			txt = <span class="string">'测试报告\n模型编号 '</span> + ModelName + <span class="string">'\n\n'</span></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> range(data_count):</span><br><span class="line">				data_input, data_labels = data.GetData((ran_num + i) % num_data)  <span class="comment"># 从随机数开始连续向后取一定数量数据</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment"># 数据格式出错处理 开始</span></span><br><span class="line">				<span class="comment"># 当输入的wav文件长度过长时自动跳过该文件，转而使用下一个wav文件来运行</span></span><br><span class="line">				num_bias = <span class="number">0</span></span><br><span class="line">				<span class="keyword">while</span>(data_input.shape[<span class="number">0</span>] &gt; self.AUDIO_LENGTH):</span><br><span class="line">					print(<span class="string">'*[Error]'</span>,<span class="string">'wave data lenghth of num'</span>,(ran_num + i) % num_data, <span class="string">'is too long.'</span>,<span class="string">'\n A Exception raise when test Speech Model.'</span>)</span><br><span class="line">					num_bias += <span class="number">1</span></span><br><span class="line">					data_input, data_labels = data.GetData((ran_num + i + num_bias) % num_data)  <span class="comment"># 从随机数开始连续向后取一定数量数据</span></span><br><span class="line">				<span class="comment"># 数据格式出错处理 结束</span></span><br><span class="line">				</span><br><span class="line">				pre = self.Predict(data_input, data_input.shape[<span class="number">0</span>] // <span class="number">8</span>)</span><br><span class="line">				</span><br><span class="line">				words_n = data_labels.shape[<span class="number">0</span>] <span class="comment"># 获取每个句子的字数</span></span><br><span class="line">				words_num += words_n <span class="comment"># 把句子的总字数加上</span></span><br><span class="line">				edit_distance = GetEditDistance(data_labels, pre) <span class="comment"># 获取编辑距离</span></span><br><span class="line">				<span class="keyword">if</span>(edit_distance &lt;= words_n): <span class="comment"># 当编辑距离小于等于句子字数时</span></span><br><span class="line">					word_error_num += edit_distance <span class="comment"># 使用编辑距离作为错误字数</span></span><br><span class="line">				<span class="keyword">else</span>: <span class="comment"># 否则肯定是增加了一堆乱七八糟的奇奇怪怪的字</span></span><br><span class="line">					word_error_num += words_n <span class="comment"># 就直接加句子本来的总字数就好了</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>((i % io_step_print == <span class="number">0</span> <span class="keyword">or</span> i == data_count - <span class="number">1</span>) <span class="keyword">and</span> show_ratio == <span class="literal">True</span>):</span><br><span class="line">					<span class="comment">#print('测试进度：',i,'/',data_count)</span></span><br><span class="line">					print(<span class="string">'Test Count: '</span>,i,<span class="string">'/'</span>,data_count)</span><br><span class="line">				</span><br><span class="line">				txt = <span class="string">''</span></span><br><span class="line">				<span class="keyword">if</span>(out_report == <span class="literal">True</span>):</span><br><span class="line">					<span class="comment"># if(i % io_step_file == 0 or i == data_count - 1):</span></span><br><span class="line">					<span class="comment"># 	txt_obj.write(txt)</span></span><br><span class="line">					<span class="comment"># 	txt = ''</span></span><br><span class="line">					txt += str(i) + <span class="string">'\n'</span></span><br><span class="line">					txt += <span class="string">'True:\t'</span> + str(data_labels) + <span class="string">'\n'</span></span><br><span class="line">					txt += <span class="string">'Pred:\t'</span> + str(pre) + <span class="string">'\n'</span></span><br><span class="line">					txt += <span class="string">'\n'</span></span><br><span class="line">					txt_obj.write(txt)</span><br><span class="line">				</span><br><span class="line">			print(<span class="string">'*[Test Result] Speech Recognition '</span> + str_dataset + <span class="string">' set word error ratio: '</span>, word_error_num / words_num * <span class="number">100</span>, <span class="string">'%'</span>)</span><br><span class="line">			<span class="keyword">if</span>(out_report == <span class="literal">True</span>):</span><br><span class="line">				txt += <span class="string">'*[测试结果] 语音识别 '</span> + str_dataset + <span class="string">' 集语音单字错误率： '</span> + str(word_error_num / words_num * <span class="number">100</span>) + <span class="string">' %'</span></span><br><span class="line">				txt_obj.write(txt)</span><br><span class="line">				txt = <span class="string">''</span></span><br><span class="line">				txt_obj.close()</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">except</span> StopIteration:</span><br><span class="line">			print(<span class="string">'[Error] Model Test Error. please check data format.'</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">Predict</span><span class="params">(self, data_input, input_len)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		预测结果</span></span><br><span class="line"><span class="string">		返回语音识别后的拼音符号列表</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		</span><br><span class="line">		batch_size = <span class="number">1</span> </span><br><span class="line">		in_len = np.zeros((batch_size),dtype = np.int32)</span><br><span class="line">		</span><br><span class="line">		in_len[<span class="number">0</span>] = input_len</span><br><span class="line">		</span><br><span class="line">		x_in = np.zeros((batch_size, <span class="number">1600</span>, self.AUDIO_FEATURE_LENGTH, <span class="number">1</span>), dtype=np.float)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(batch_size):</span><br><span class="line">			x_in[i,<span class="number">0</span>:len(data_input)] = data_input</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		base_pred = self.base_model.predict(x = x_in)</span><br><span class="line">		</span><br><span class="line">		base_pred =base_pred[:, :, :]</span><br><span class="line">		</span><br><span class="line">		r = K.ctc_decode(base_pred, in_len, greedy = <span class="literal">True</span>, beam_width=<span class="number">100</span>, top_paths=<span class="number">1</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">#print('r', r)</span></span><br><span class="line">		</span><br><span class="line">		r1 = K.get_value(r[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">		<span class="comment">#print('r1', r1)</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">#r2 = K.get_value(r[1])</span></span><br><span class="line">		<span class="comment">#print(r2)</span></span><br><span class="line">		</span><br><span class="line">		r1=r1[<span class="number">0</span>]</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> r1</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">RecognizeSpeech</span><span class="params">(self, wavsignal, fs)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		最终做语音识别用的函数，识别一个wav序列的语音</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">#data = self.data</span></span><br><span class="line">		<span class="comment">#data = DataSpeech('E:\\语音数据集')</span></span><br><span class="line">		<span class="comment">#data.LoadDataList('dev')</span></span><br><span class="line">		<span class="comment"># 获取输入特征</span></span><br><span class="line">		<span class="comment">#data_input = GetMfccFeature(wavsignal, fs)</span></span><br><span class="line">		<span class="comment">#t0=time.time()</span></span><br><span class="line">		data_input = GetFrequencyFeature(wavsignal, fs)</span><br><span class="line">		<span class="comment">#t1=time.time()</span></span><br><span class="line">		<span class="comment">#print('time cost:',t1-t0)</span></span><br><span class="line">		</span><br><span class="line">		input_length = len(data_input)</span><br><span class="line">		input_length = input_length // <span class="number">8</span></span><br><span class="line">		</span><br><span class="line">		data_input = np.array(data_input, dtype = np.float)</span><br><span class="line">		<span class="comment">#print(data_input,data_input.shape)</span></span><br><span class="line">		data_input = data_input.reshape(data_input.shape[<span class="number">0</span>],data_input.shape[<span class="number">1</span>],<span class="number">1</span>)</span><br><span class="line">		<span class="comment">#t2=time.time()</span></span><br><span class="line">		r1 = self.Predict(data_input, input_length)</span><br><span class="line">		<span class="comment">#t3=time.time()</span></span><br><span class="line">		<span class="comment">#print('time cost:',t3-t2)</span></span><br><span class="line">		list_symbol_dic = GetSymbolList(self.datapath) <span class="comment"># 获取拼音列表</span></span><br><span class="line">		</span><br><span class="line">		r_str=[]</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> r1:</span><br><span class="line">			r_str.append(list_symbol_dic[i])</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> r_str</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">RecognizeSpeech_FromFile</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		最终做语音识别用的函数，识别指定文件名的语音</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		</span><br><span class="line">		wavsignal,fs = read_wav_data(filename)</span><br><span class="line">		</span><br><span class="line">		r = self.RecognizeSpeech(wavsignal, fs)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> r</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		返回keras model</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		<span class="keyword">return</span> self._model</span><br></pre></td></tr></table></figure>

<h3 id="语言模型设计训练"><a href="#语言模型设计训练" class="headerlink" title="语言模型设计训练"></a>语言模型设计训练</h3><h3 id="实验分析和软件设计"><a href="#实验分析和软件设计" class="headerlink" title="实验分析和软件设计"></a>实验分析和软件设计</h3>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>TPOT——一个自动化的Python机器学习工具</title>
    <url>/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="TPOT—一个自动化的Python机器学习工具"><a href="#TPOT—一个自动化的Python机器学习工具" class="headerlink" title="TPOT—一个自动化的Python机器学习工具"></a>TPOT—一个自动化的Python机器学习工具</h2><p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/1.png" alt></p>
<p>TPOT全称是基于树的pipeline优化工具(Tree-based Pipeline Optimization Tool)，这是一个非常棒Python自动机器学习工具，使用遗传编程优化机器学习pipeline。</p>
<a id="more"></a>

<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/2.png" alt></p>
<p>TPOT可以自动化许多东西，包括生命特性选择、模型选择、特性构建等等。如果你是Python机器学习者，很幸运，TPOT是构建在Scikit-learn之上的，所以它生成的所有代码看起来应该很熟悉。</p>
<p>它的作用是通过智能地探索数千种可能的pipeline来自动化机器学习中最繁琐的部分，找到最适合你的数据的pipeline，然后为你提供最佳的 Python 代码。</p>
<p>它的工作原理如下：</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/3.png" alt></p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><p>安装TPOT，可参考以下文档：<br><a href="http://epistasislab.github.io/tpot/installing/" target="_blank" rel="noopener external nofollow noreferrer">http://epistasislab.github.io/tpot/installing/</a></p>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h2><h3 id="2-1-TPOT代码"><a href="#2-1-TPOT代码" class="headerlink" title="2.1 TPOT代码"></a>2.1 TPOT代码</h3><p>TPOT的接口，与scikit-learn很类似。</p>
<p>TPOT可以像任何常规的Python模块一样导入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br></pre></td></tr></table></figure>
<p>然后创建一个TPOT实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer = TPOTClassifier()</span><br></pre></td></tr></table></figure>
<p>当然，TPOTRegressor（）也可以。</p>
<p>一些带有定制TPOT参数的示例代码可能如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, cv=<span class="number">5</span>, random_state=<span class="number">42</span>, verbosity=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>现在，可以利用fit函数来寻找最优的管道：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>fit函数初始化了遗传算法，以找到基于平均k倍交叉验证的最高评分管道，然后对整个提供的样本进行训练，TPOT实例可以作为一个合适的模型使用。</p>
<p>然后，可以使用score函数来评估测试集中的最终管道：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(pipeline_optimizer.score(X_test, y_test))</span><br></pre></td></tr></table></figure>
<p>最后，可以把TPOT将相应的Python代码导出到文本文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer.export(<span class="string">'tpot_exported_pipeline.py'</span>)</span><br></pre></td></tr></table></figure>
<p>下面是一个完整的示例脚本，使用TPOT优化管道，对其进行评分，并将最好的管道导出到文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"> </span><br><span class="line">digits = load_digits()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"> </span><br><span class="line">pipeline_optimizer = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, cv=<span class="number">5</span>,random_state=<span class="number">42</span>, verbosity=<span class="number">2</span>)</span><br><span class="line">pipeline_optimizer.fit(X_train, y_train)</span><br><span class="line">print(pipeline_optimizer.score(X_test, y_test))</span><br><span class="line">pipeline_optimizer.export(<span class="string">'tpot_exported_pipeline.py'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-2-TPOT命令行"><a href="#2-2-TPOT命令行" class="headerlink" title="2.2 TPOT命令行"></a>2.2 TPOT命令行</h3><p>TPOT可以通过命令行导入使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tpot &#x2F;path_to&#x2F;data_file.csv</span><br></pre></td></tr></table></figure>
<p>命令行导入使用TPOT的示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tpot data&#x2F;mnist.csv -is , -target class -o tpot_exported_pipeline.py -g 5 -p 20 -cv 5 -s 42 -v 2</span><br></pre></td></tr></table></figure>
<h3 id="2-3-评估函数"><a href="#2-3-评估函数" class="headerlink" title="2.3 评估函数"></a>2.3 评估函数</h3><p>TPOT允许自定义评分函数，具体例子可以参考<a href="https://epistasislab.github.io/tpot/using/#scoring-functions" target="_blank" rel="noopener external nofollow noreferrer">Scoring Functions</a><br>##2.4 内置TPOT配置<br>TPOT提供了一些默认的操作符和参数配置，它可以很好地优化机器学习管道。下面是TPOT当前内置配置的<a href="https://epistasislab.github.io/tpot/using/#built-in-tpot-configurations" target="_blank" rel="noopener external nofollow noreferrer">列表</a>。它有4种：</p>
<ul>
<li>Default TPOT：默认的参数，在一些大数据集上可能需要较长时间。</li>
<li>TPOT light：与Default TPOT相比，使用了更简单、快速运行的操作符，因此TPOT light对于查找用于分类或回归问题的快速简单的管道非常有用。</li>
<li>TPOT MDR：专门用于全基因组关联研究（GWAS）</li>
<li>TPOT sparse：带有one-hot编码，且支持稀疏矩阵。<br>如果要使用这些配置只需将配置的字符串名称传递给config_dict 参数。示例代码如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">digits = load_digits()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">tpot = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, verbosity=<span class="number">2</span>,config_dict=<span class="string">'TPOT light'</span>)</span><br><span class="line">tpot.fit(X_train, y_train)</span><br><span class="line">print(tpot.score(X_test, y_test))</span><br><span class="line">tpot.export(<span class="string">'tpot_mnist_pipeline.py'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-5-定制TPOT的操作符和参数"><a href="#2-5-定制TPOT的操作符和参数" class="headerlink" title="2.5 定制TPOT的操作符和参数"></a>2.5 定制TPOT的操作符和参数</h3>除了TPOT所带来的默认配置之外，在某些情况下，限制TPOT所考虑的算法和参数是很有用的（用于减少寻优的时间等）。出于这个原因，TPOT允许用户为TPOT提供其操作符和参数的自定义配置。<br>自定义TPOT配置必须采用嵌套字典格式，举一个例子：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"> </span><br><span class="line">digits = load_digits()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"> </span><br><span class="line">tpot_config = &#123;</span><br><span class="line">    <span class="string">'sklearn.naive_bayes.GaussianNB'</span>: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    <span class="string">'sklearn.naive_bayes.BernoulliNB'</span>: &#123;</span><br><span class="line">        <span class="string">'alpha'</span>: [<span class="number">1e-3</span>, <span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1.</span>, <span class="number">10.</span>, <span class="number">100.</span>],</span><br><span class="line">        <span class="string">'fit_prior'</span>: [<span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    <span class="string">'sklearn.naive_bayes.MultinomialNB'</span>: &#123;</span><br><span class="line">        <span class="string">'alpha'</span>: [<span class="number">1e-3</span>, <span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1.</span>, <span class="number">10.</span>, <span class="number">100.</span>],</span><br><span class="line">        <span class="string">'fit_prior'</span>: [<span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">tpot = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, verbosity=<span class="number">2</span>,</span><br><span class="line">                      config_dict=tpot_config)</span><br><span class="line">tpot.fit(X_train, y_train)</span><br><span class="line">print(tpot.score(X_test, y_test))</span><br><span class="line">tpot.export(<span class="string">'tpot_mnist_pipeline.py'</span>)</span><br></pre></td></tr></table></figure>
这样，TPOT寻找最优的pipeline，就只会在tpot_config中寻找了，无疑大大减少了时间复杂度，不过准确性可能会下降。<h3 id="2-6-Note"><a href="#2-6-Note" class="headerlink" title="2.6 Note"></a>2.6 Note</h3>搜索整个管道空间是特别耗时的。认识到原因是必要的，在默认的TPOT参数下（100 generations with 100 population size），TPOT将在完成前评估1万个管道配置。考虑一个网格搜索1万个超参数组合用于机器学习算法以及网格搜索需要多长时间。用10倍的交叉验证来评估这1万个模型，这意味着大约有10万个模型在一个网格搜索的训练数据中被匹配和评估。这是一个耗时的过程，即使对于像决策树这样的简单模型也是如此。</li>
</ul>
<p>典型的TPOT运行将需要数小时到数天才能完成（除非是一个小数据集），但是可以中断运行，并看到目前为止最好的结果。TPOT还提供warm_start参数，可以从中断的地方重新启动之前运行的TPOT。</p>
<h2 id="3-TPOT-API"><a href="#3-TPOT-API" class="headerlink" title="3. TPOT API"></a>3. TPOT API</h2><p>以TPOTRegressor为例，分类问题一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tpot</span>.<span class="title">TPOTRegressor</span><span class="params">(generations=<span class="number">100</span>, population_size=<span class="number">100</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">offspring_size=None, mutation_rate=<span class="number">0.9</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">crossover_rate=<span class="number">0.1</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">scoring=<span class="string">'neg_mean_squared_error'</span>, cv=<span class="number">5</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">subsample=<span class="number">1.0</span>, n_jobs=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">max_time_mins=None, max_eval_time_mins=<span class="number">5</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">random_state=None, config_dict=None,</span></span></span><br><span class="line"><span class="class"><span class="params">warm_start=False,</span></span></span><br><span class="line"><span class="class"><span class="params">memory=None,</span></span></span><br><span class="line"><span class="class"><span class="params">periodic_checkpoint_folder=None,</span></span></span><br><span class="line"><span class="class"><span class="params">early_stop=None,</span></span></span><br><span class="line"><span class="class"><span class="params">verbosity=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">disable_update_check=False)</span></span></span><br></pre></td></tr></table></figure>
<p>在默认情况下，TPOTRegressor将搜索广泛的监督的回归模型，包括预处理，特征选择，学习器和它们的超参数。当然，TPOTRegressor可以完全自己定制。</p>
<p>参数，属性和方法的详情可以参考<a href="https://epistasislab.github.io/tpot/api/#regression" target="_blank" rel="noopener external nofollow noreferrer">如下</a></p>
<p>下面列出主要的参数和方法：</p>
<p>参数：</p>
<ul>
<li>generations: int, optional (default=100)，运行管道优化过程的迭代次数。一定是正数,默认是100。一般来说，值越大，性能越好。</li>
</ul>
<p>TPOT将评估population_size+generations×offspring_size的规模。</p>
<ul>
<li><p>population_size: int, optional (default=100)，在每一代遗传中保留的个体数。一定是正数。一般来说，值越大，性能越好。</p>
</li>
<li><p>offspring_size: int, optional (default=100)，在每一次遗传过程中产生的后代数量。一定是正数。</p>
</li>
<li><p>mutation_rate: float, optional (default=0.9)，变异率，采用默认值即可。</p>
</li>
<li><p>crossover_rate: float, optional (default=0.1)，交叉率，采用默认值即可。</p>
</li>
<li><p>scoring: string or callable, optional (default=’neg_mean_squared_error’)，回归问题中用于评估给定管道的质量的函数。可以使用以下内置评分函数： ‘neg_median_absolute_error’, ‘neg_mean_absolute_error’, ‘neg_mean_squared_error’, ‘r2’</p>
</li>
<li><p>cv: int, cross-validation generator, or an iterable, optional (default=5)</p>
</li>
<li><p>subsample: float, optional (default=1.0)，在TPOT优化过程中使用的训练样本的比例。必须在0到1之间。</p>
</li>
<li><p>n_jobs: integer, optional (default=1)</p>
</li>
<li><p>max_time_mins: integer or None, optional (default=None)，TPOT需要多少分钟来优化管道。</p>
</li>
<li><p>max_eval_time_mins: integer, optional (default=5)，TPOT需要多少分钟来评估一个管道。</p>
</li>
<li><p>random_state: integer or None, optional (default=None)，使用这个参数来确保TPOT每次运行时都会有相同的结果。</p>
</li>
<li><p>config_dict: Python dictionary, string, or None, optional (default=None)，用于定制TPOT在优化过程中搜索的操作符和参数的配置字典。</p>
</li>
<li><p>warm_start: boolean, optional (default=False)，表明TPOT实例是否会重用以前调用fit（）的入口。</p>
</li>
<li><p>early_stop: integer, optional (default: None)</p>
</li>
<li><p>verbosity: integer, optional (default=0)，<br>0，TPOT将不会打印任何东西，<br>1，将打印很少的信息，<br>2，TPOT将会打印更多的信息并提供一个进度条<br>3，TPOT将打印所有内容，并提供一个进度条</p>
</li>
</ul>
<p>方法：</p>
<ul>
<li>fit(features, target, sample_weight=None, groups=None)，在给定的训练数据上运行TPOT优化过程。</li>
<li>predict(features)，使用优化的管道来预测测试集的目标值。</li>
<li>score(testing_features, testing_target)，使用用户指定的评分函数在给定的测试数据上返回优化的管道的得分。</li>
<li>export(output_file_name)，将优化的管道导出为Python代码。</li>
</ul>
<h2 id="4-实例"><a href="#4-实例" class="headerlink" title="4.实例"></a>4.实例</h2><h3 id="例4-1"><a href="#例4-1" class="headerlink" title="例4.1"></a>例4.1</h3><p>数据集地址：<a href="https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/" target="_blank" rel="noopener external nofollow noreferrer">https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/</a></p>
<p>使用的数据集：breast-cancer-wisconsin.data<br>直接把数据全选复制到txt中，然后直接改文件后缀为csv，把文件转换为csv格式。并加上属性名</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/4.png" alt></p>
<p>程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">使用TPOT自动选择scikit-learn机器学习模型和参数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"> </span><br><span class="line">inputfile=<span class="string">'C:/Users/bryce/Desktop/breast-cancer-wisconsin.data.csv'</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    df=pd.read_csv(inputfile)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    df.replace(<span class="string">'?'</span>,np.nan,inplace=<span class="literal">True</span>)</span><br><span class="line">    df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">    df.drop([<span class="string">'id'</span>],<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    df[<span class="string">'Bare Nuclei'</span>] = df[<span class="string">'Bare Nuclei'</span>].astype(int)</span><br><span class="line">    X=np.array(df.drop([<span class="string">'Class'</span>],<span class="number">1</span>))</span><br><span class="line">    Y=np.array(df[<span class="string">'Class'</span>])</span><br><span class="line">    x_train,x_test,y_train,y_test=model_selection.train_test_split(X,Y,test_size=<span class="number">0.2</span>)</span><br><span class="line">    tpot=TPOTClassifier(generations=<span class="number">6</span>,verbosity=<span class="number">2</span>)</span><br><span class="line">    tpot.fit(x_train,y_train)</span><br><span class="line">    tpot.score(x_test,y_test)</span><br><span class="line">    tpot.export(<span class="string">'pipeline.py'</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/5.png" alt></p>
<p>可以看到运行的最优结果是随机森林算法,并给出具体的参数。<br>再运行一下随机森林算法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">使用TPOT自动选择scikit-learn机器学习模型和参数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"> </span><br><span class="line">inputfile=<span class="string">'C:/Users/bryce/Desktop/breast-cancer-wisconsin.data.csv'</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    df=pd.read_csv(inputfile)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    df.replace(<span class="string">'?'</span>,np.nan,inplace=<span class="literal">True</span>)</span><br><span class="line">    df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">    df.drop([<span class="string">'id'</span>],<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">'Bare Nuclei'</span>] = df[<span class="string">'Bare Nuclei'</span>].astype(int)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    X=np.array(df.drop([<span class="string">'Class'</span>],<span class="number">1</span>))</span><br><span class="line">    Y=np.array(df[<span class="string">'Class'</span>])</span><br><span class="line">    x_train,x_test,y_train,y_test=model_selection.train_test_split(X,Y,test_size=<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># tpot=TPOTClassifier(generations=6,verbosity=2)</span></span><br><span class="line">    <span class="comment"># tpot.fit(x_train,y_train)</span></span><br><span class="line">    <span class="comment"># tpot.score(x_test,y_test)</span></span><br><span class="line">    <span class="comment"># tpot.export('pipeline.py')</span></span><br><span class="line"> </span><br><span class="line">    rfc=RandomForestClassifier(bootstrap=<span class="literal">True</span>, criterion=<span class="string">'entropy'</span>, max_features=<span class="number">0.05</span>, min_samples_leaf=<span class="number">3</span>, min_samples_split=<span class="number">16</span>, n_estimators=<span class="number">100</span>)</span><br><span class="line">    rfc.fit(x_train,y_train)</span><br><span class="line">    accuracy=rfc.score(x_test,y_test)</span><br><span class="line">    print(<span class="string">"accuracy:%s"</span>%accuracy)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/6.png" alt></p>
<h3 id="例4-2"><a href="#例4-2" class="headerlink" title="例4.2"></a>例4.2</h3><p>数据集：sklearn自带的波士顿房价数据集</p>
<h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h2><ol>
<li><a href="https://epistasislab.github.io/tpot/examples/" target="_blank" rel="noopener external nofollow noreferrer">TPOT官方参考文档</a></li>
<li><a href="https://github.com/EpistasisLab/tpot" target="_blank" rel="noopener external nofollow noreferrer">TPOTgithub</a></li>
<li><a href="https://blog.csdn.net/anshuai_aw1/article/details/82498947" target="_blank" rel="noopener external nofollow noreferrer">利用TPOT完成自动化机器学习</a></li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法</title>
    <url>/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>整理一些常见的六大基础排序算法： 冒泡排序、选择排序、<strong>插入排序</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong></p>
<p><img src="/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort_summary.jpg" alt></p>
<a id="more"></a>

<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span></span><br><span class="line"><span class="comment">    2. 对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</span></span><br><span class="line"><span class="comment">    3. 针对所有的元素重复以上的步骤，除了最后已经选出的元素（有序）。</span></span><br><span class="line"><span class="comment">    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定排序，平均 O(n**2)，最好 O(n), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// swap(nums[j], nums[j+1]);</span></span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt></p>
<h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</span></span><br><span class="line"><span class="comment">    2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</span></span><br><span class="line"><span class="comment">    3. 以此类推，直到所有元素均排序完毕。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定排序，平均 O(n**2)，最好 O(n**2), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = i;</span><br><span class="line">        <span class="comment">//每一趟循环比较时，idx用于存放较小元素的数组下标，</span></span><br><span class="line">        <span class="comment">//这样当前批次比较完毕最终存放的就是此趟内最小的元素</span></span><br><span class="line">        <span class="comment">//的下标，避免每次遇到较小元素都要进行交换。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] &gt; nums[j]);</span><br><span class="line">            &#123;</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (idx !=i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[idx];</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插入排序（重要）"><a href="#3-插入排序（重要）" class="headerlink" title="3. 插入排序（重要）"></a>3. 插入排序（重要）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt></p>
<h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   直接插入排序基本思想是每一步将一个待排序的记录，</span></span><br><span class="line"><span class="comment">   插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   1. 从第一个元素开始，该元素可以认为已经被排序</span></span><br><span class="line"><span class="comment">   2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</span></span><br><span class="line"><span class="comment">   3. 如果被扫描的元素（已排序）大于新元素，将该元素后移一位</span></span><br><span class="line"><span class="comment">   4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span></span><br><span class="line"><span class="comment">   5. 将新元素插入到该位置后</span></span><br><span class="line"><span class="comment">   6. 重复步骤2~5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定排序，平均 O(n**2)，最好 O(n), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 从下标为1的元素开始选择合适的位置插入，</span></span><br><span class="line">    <span class="comment">// 因为下标为0的只有一个元素，默认是有序的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 记录要插入的数据</span></span><br><span class="line">        <span class="keyword">int</span> temp  = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i- <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//与已排序的数逐一比较，大于temp时，该数移后</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span>) &amp;&amp; (nums[j] &gt; nums[j])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-归并排序（重要）"><a href="#4-归并排序（重要）" class="headerlink" title="4. 归并排序（重要）"></a>4. 归并排序（重要）</h3><p><img src="/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/guibing1.png" alt><br><img src="/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/guibing1.png" alt></p>
<h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   将已有序的子序列合并，得到完全有序的序列；</span></span><br><span class="line"><span class="comment">   即先使每个子序列有序，再使子序列段间有序。</span></span><br><span class="line"><span class="comment">   若将两个有序表合并成一个有序表，称为二路归并。</span></span><br><span class="line"><span class="comment">   归并排序是一种稳定的排序方法。</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">1、确定数组的大小，以及输入数组中的元素值；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、将输入的数组进行分组归并；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、将整个数组分成左右两个数组，左右两个数组再向下分，直至子数组的元素少于2个时，子数组将停止分割；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4、当左右子数组不能再分割，也是都是一个元素时，比较他们的大小，进行排序合并；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5、再排序合并上一级子数组为两个元素的数组，接着再排序合并上一级子数组为四个元素的数组；</span></span><br><span class="line"><span class="comment">直至到排序合并刚开始的两个子数组，最后成为排好序的数组；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定排序，平均 O(nlogn)，最好 O(nlogn), 最差 O(nlogn),辅助空间 O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp[high+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">//临时数组指针</span></span><br><span class="line">        <span class="keyword">int</span> l=low;<span class="comment">//左序列指针</span></span><br><span class="line">        <span class="keyword">int</span> r=mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid&amp;&amp;r&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]&lt;nums[r])</span><br><span class="line">                temp[i++]=nums[l++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[i++]=nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid) <span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[i++]=nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=high) <span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[i++]=nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将temp中的元素全部拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[low++]=temp[i++];</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            mergesort(nums,low,mid);  <span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">            mergesort(nums,mid+<span class="number">1</span>,high); <span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">            merge(nums,low,high); <span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-快速排序（重要）"><a href="#5-快速排序（重要）" class="headerlink" title="5. 快速排序（重要）"></a>5. 快速排序（重要）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt></p>
<h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 从数列中挑出一个元素作为基准数。</span></span><br><span class="line"><span class="comment">    2. 重新排序数列，将比基准数大的放到右边，小于或等于它的数都放到左边。</span></span><br><span class="line"><span class="comment">    3. 再对左右区间递归执行第二步，直至各区间只有一个数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定排序，平均 O(nlogn)，最好 O(nlogn), 最差 O(n**2),辅助空间 O(logn)</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">Paritition</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> pivot = nums[low];</span><br><span class="line">   <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= pivot)</span><br><span class="line">     &#123;</span><br><span class="line">       --high;</span><br><span class="line">     &#125;</span><br><span class="line">     nums[low] = nums[high];</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt; pivot)</span><br><span class="line">     &#123;</span><br><span class="line">       ++low;</span><br><span class="line">     &#125;</span><br><span class="line">     nums[high] = nums[low];</span><br><span class="line">   &#125;</span><br><span class="line">   nums[low] = pivot;</span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> <span class="comment">//快排母函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">int</span> i = Paritition(nums, low, high);</span><br><span class="line">     QuickSort(nums, low, i - <span class="number">1</span>);</span><br><span class="line">     QuickSort(nums, i + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>精简版</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> l = low, r = high, pivot = nums[low];</span><br><span class="line">		<span class="keyword">while</span>(l&lt;r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r] &gt;=pivot) <span class="comment">// 从右向左找第一个小于基准的数</span></span><br><span class="line">			&#123;</span><br><span class="line">			    r--;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[l] = nums[r];</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l] &lt; pivot) <span class="comment">// 从左向右找第一个大于等于基准的数</span></span><br><span class="line">			&#123;</span><br><span class="line">			    l++;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[r] = nums[l];</span><br><span class="line">		&#125;</span><br><span class="line">		nums[l] = pivot;</span><br><span class="line">		quick_sort(nums, low, l<span class="number">-1</span>);</span><br><span class="line">		quick_sort(nums, l+<span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-堆排序（重要）"><a href="#6-堆排序（重要）" class="headerlink" title="6. 堆排序（重要）"></a>6. 堆排序（重要）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt></p>
<h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">堆排序的基本思想是：将待排序序列构造成一个大顶堆，</span></span><br><span class="line"><span class="comment">此时，整个序列的最大值就是堆顶的根节点。将其与末</span></span><br><span class="line"><span class="comment">尾元素进行交换，此时末尾就为最大值。然后将剩余n-1</span></span><br><span class="line"><span class="comment">个元素重新构造成一个堆，这样会得到n个元素的次小值。</span></span><br><span class="line"><span class="comment">如此反复执行，便能得到一个有序序列了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  1.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　2.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与</span></span><br><span class="line"><span class="comment">  当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定排序，平均 O(nlogn)，最好 O(nlogn), 最差 O(nlogn),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; nums[k]&lt;nums[k+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[k] &gt;temp)</span><br><span class="line">        <span class="comment">//如果子节点大于父节点，将子节点值赋给父节点</span></span><br><span class="line">        <span class="comment">//（不用进行交换）</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = nums[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[i] = temp;    <span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">        adjustHeap(nums,i,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(nums[<span class="number">0</span>],nums[j]);</span><br><span class="line">        <span class="comment">//将堆顶元素(最大值)与末尾元素进行交换，</span></span><br><span class="line">        <span class="comment">//将最大值交换到数组的最后位置保存</span></span><br><span class="line">        adjustHeap(nums,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener external nofollow noreferrer">图解排序算法(三)之堆排序</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>泵站机组故障诊断</title>
    <url>/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/</url>
    <content><![CDATA[<h3 id="故障诊断系统概述"><a href="#故障诊断系统概述" class="headerlink" title="故障诊断系统概述"></a>故障诊断系统概述</h3><p>研究的基于自动化机器学习的故障诊断系统既具有故障诊断算法训练功能，也具有算法部署功能。它会读取故障数据，进行特征提取，然后使用自动化机器学习方法找出最优机器学习流程，并将该流程训练好保存下来，最后使用Web服务器对故障诊断算法进行部署。所研究的故障诊断系统具有高度自动化、功能拓展方便、模型更新方便的特点。</p>
<a id="more"></a>
<p>本系统由以下几个子部分构成：</p>
<p>（1）系统运行日志。日志是对系统运行状态的记录，它可以帮助检验系统运行是否正常，在出现异常情况时可以帮助使用者快速查找错误。日志的记录是分级别的，一般分为DEBUG、INFO、WARNING、ERROR、CRITICAL 五个级别，这五个级别的严重程度越来越高。</p>
<p>（2）系统配置文件。系统配置文件本质上是文本文件，通过配套的文本解析方法可以提取出变量名及其对应的设定值。系统在主功能运行前读取配置文件，从而设定程序的运行模式或训练任务，达到不改变代码就可以改变程序运行的效果。</p>
<p>（3）故障样本数据库。所研究的故障诊断算法是基于机器学习的，而机器学习方法是由数据驱动的，因此一个故障样本数据库是必要的。由于本文研究对象泵站机组具有型号多、运行工况复杂的特点，故障样本数据库在设计的时候充分考虑了这些特点。</p>
<p>（4）样本平衡性检验。在用数据进行训练之前，应该对样本平衡性进行检验，样本数量比较少的做一些特殊处理，样本数量太少的应从训练集里予以剔除，更失衡严重的就终止本次训练，等待数据收集完毕后再开始。</p>
<p>（5）故障特征提取。从故障数据库获得的数据是传感器数据，而传感器数据是无法直接作为机器学习算法输入的。为了提高故障诊断算法的效果，应该先对数据库中传感器数据使用快速傅里叶变换进行预处理。</p>
<p>（6）使用TPOT进行模型训练。采用基于遗传算法的自动化机器学习方法TPOT是使用遗传算法对特征归一化、特征选择、模型和参数选择等环节组成的机器学习流程进行自动构建并寻优的方法。</p>
<p>（7）故障诊断模型工程部署。所研究的故障诊断模型工程部署方法是基于Python轻型Web服务器框架Flask通过HTTP协议实现Python环境与Java环境的交互。</p>
<p>故障诊断系统工作流程图如下所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/liucheng1.png" alt></p>
<h3 id="故障诊断系统研究"><a href="#故障诊断系统研究" class="headerlink" title="故障诊断系统研究"></a>故障诊断系统研究</h3><h4 id="故障数据库设计规范"><a href="#故障数据库设计规范" class="headerlink" title="故障数据库设计规范"></a>故障数据库设计规范</h4><p>在泵站机组型号或运行工况不一样的情况下，虽然机组发生了同一种故障类型，但同样位置的传感器数据会有所不同，这就导致提取的特征也有点不同。因此，在故障数据存储时必须要体现出故障样本的来源背景，这里用机组型号和运行工况来表示。</p>
<p>以机组某个部件有两个传感器为例设计的故障数据库规范如下表所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/shujuku1.png" alt></p>
<h4 id="故障样本不平衡处理"><a href="#故障样本不平衡处理" class="headerlink" title="故障样本不平衡处理"></a>故障样本不平衡处理</h4><h5 id="样本不平衡下的训练方法"><a href="#样本不平衡下的训练方法" class="headerlink" title="样本不平衡下的训练方法"></a>样本不平衡下的训练方法</h5><p>针对样本不平衡下的训练数据集采用简单易行的调整类的权重方法，该方法是在误差函数里添加类别权重，以达到误差平衡，带权重的误差函数为：</p>
<p>$$<br>\text { error }=\frac{\sum_{i=1}^{n} w_{i}\left(y_{i}^{\prime}-y_{i}\right)^{2}}{n}<br>$$</p>
<p>其中：</p>
<p>$𝑛$ 代表样本总数；</p>
<p>$𝑤_𝑖$ 代表第$i$个样本所在类别的权重；</p>
<p>$y_{i}^{\prime}$代表第$i$个样本的预测结果；</p>
<p>$𝑦_𝑖$代表第$i$个样本的实际结果。</p>
<h5 id="样本不平衡下的评估方法"><a href="#样本不平衡下的评估方法" class="headerlink" title="样本不平衡下的评估方法"></a>样本不平衡下的评估方法</h5><p>在统计和机器学习中，常常用AUC 来评估二分类模型的性能（多分类也可以使用，作为二分类的拓展）。AUC 的全称是Area under the curve，即曲线下的面积。通常这里的曲线指的是受试者操作曲线(Receiver Operating Characteristic,ROC)。相比于准确率、召回率、F1 值等依赖于判决阈值的评估指标，AUC则没有这个问题。</p>
<p>ROC 曲线：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/ROC.jpg" alt></p>
<p>AUC值为ROC 曲线下方所覆盖的区域面积，AUC越大, 说明曲线越靠近(0,1) 这个点，越接近理想曲线，分类效果自然更好。</p>
<p>AUC指标为什么可以作为样本不平衡情况下的模型评价指标？因为当用来验证算法效果的数据集中的样本比例发生变化时，ROC曲线的形状能够保持不变，而AUC是ROC曲线的下方面积，所以当模型一定时，AUC的值也不随正负样本分布的变化而变化，所以能够作为不平衡数据集的模型评价指标。</p>
<h4 id="故障特征提取"><a href="#故障特征提取" class="headerlink" title="故障特征提取"></a>故障特征提取</h4><p>泵轴的常见故障有油膜涡动、接触摩擦、油膜振荡、转子不平衡和转子不对中，这些故障都可以体现在泵轴的振动信号里，通常采用泵轴的摆度数值作为它的振动信号。通过利用FFT快速傅里叶变换将时域的振动信号转换为频域的能量分布。</p>
<p>下面对泵轴的转子不平衡故障数据进行特征提取实验，介绍如下：</p>
<p>（1）数据来源传感器：泵轴$Y$方向摆度信号</p>
<p>（2）数据滤波方法与窗函数：小波阈值去噪、汉宁窗</p>
<p>（3）基频$𝐹_0$、采样频率$𝐹_𝑠$和采样点数$𝑁$：$20Hz$、$2048Hz$、$2048$由上面几个数据，可得到下面几个频谱分析需要的参数：</p>
<p>（a）最高有效频率𝐹𝑚：𝐹𝑚 = 𝐹𝑠/2.56=800Hz</p>
<p>（b）频率分辨率𝛥𝐹 ：𝛥𝐹 = 𝐹𝑠/𝑁=2048/2048=1Hz</p>
<p>（c）谱线数𝑀：𝑀 = 𝑁/2.56=2048/2.56=800</p>
<p>下图为转子不平衡故障特征提取过程。</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/tezheng.jpg" alt></p>
<p>图中共有三个子图，其中最上面的图是泵轴摆度信号的时域图，表现出<br>了周期性，中间图是对摆度信号的时域数据作快速傅立叶变换得到的频谱，最下面图是从频谱提取的特征向量。</p>
<h4 id="自动化机器学习工具TPOT"><a href="#自动化机器学习工具TPOT" class="headerlink" title="自动化机器学习工具TPOT"></a>自动化机器学习工具TPOT</h4><p><a href="/TPOT——一个自动化的Python机器学习工具.md">此节具体参考这里</a></p>
<h4 id="诊断算法的部署"><a href="#诊断算法的部署" class="headerlink" title="诊断算法的部署"></a>诊断算法的部署</h4><p>设置Web服务器，通过HTTP协议进行调用。生产环境软件通过网络IP、端口将需要诊断的数据传递给Web服务器。Web服务器接受到数据后会进行诊断服务，在诊断结束后，诊断结果会原路返回给服务调用者。<br>诊断数据与Web 服务器之间使用HTTP协议进行通信，HTTP协议下有GET、POST、PUT 和DELETE 等方法，因为通信过程中需要传输传感器数据，所以这里使用可携带数据体的POST方法。</p>
<p>在故障诊断的各个环节中，诊断算法具有“一次加载、多次使用”的特点，而特征提取、算法调用等步骤随着传输数据的不同而采用不同的方法，所以故障诊断Web服务器在实现时应该按照这样的方式：加载诊断算法在创建故障诊断Web服务器时进行，数据获取、特征提取、调用诊断算法和诊断结果返回这些步骤在POST方法中实现。</p>
<h3 id="故障诊断系统具体实现"><a href="#故障诊断系统具体实现" class="headerlink" title="故障诊断系统具体实现"></a>故障诊断系统具体实现</h3><h4 id="系统开发环境"><a href="#系统开发环境" class="headerlink" title="系统开发环境"></a>系统开发环境</h4><p>故障诊断系统是在Windows 10上使用Python编程语言开发的，<br>其中数据库使用SQL Server，日志管理使用Logging，配置文件解析加载使用Configparser，频域分析工具包使用Scipy，矩阵数据处理使用Pandas 和Numpy，自动化机器学习工具使用TPOT，模型序列化保存工具使用Pickle，Web 应用框架使用Flask。</p>
<p>下表是详细的故障诊断系统开发环境。</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/environment.png" alt></p>
<h4 id="系统功能模块的实现"><a href="#系统功能模块的实现" class="headerlink" title="系统功能模块的实现"></a>系统功能模块的实现</h4><h5 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h5><p>系统日志管理工具使用Logging 模块实现，具体的是使用了Logging 下的logger 对象，使用logger 对象可以避免多个程序使用同一个日志文件时产生重复记录的问题。系统日志管理工具被打包成一个独立的文件，方便不同任务的复用。<a href="https://cuiqingcai.com/6080.html" target="_blank" rel="noopener external nofollow noreferrer">logging模块的基本用法</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_logger</span><span class="params">()</span>:</span></span><br><span class="line">    logger = logging.getLogger(__name__)</span><br><span class="line">    logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    stream_handler = logging.StreamHandler()</span><br><span class="line">    stream_handler.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    file_handler = logging.FileHandler(filename=<span class="string">'日志.log'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    file_handler.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">    formatter = logging.Formatter(fmt=<span class="string">'%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">    stream_handler.setFormatter(formatter)</span><br><span class="line">    file_handler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">    logger.addHandler(stream_handler)</span><br><span class="line">    logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logger</span><br></pre></td></tr></table></figure>

<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>配置文件的格式有ini、toml、yaml、json 和xml 等，其中ini格式的最为简单直观，这里使用的配置文件就是ini格式.部分配置如下图所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/ini.jpg" alt></p>
<h4 id="建立机组故障数据库"><a href="#建立机组故障数据库" class="headerlink" title="建立机组故障数据库"></a>建立机组故障数据库</h4><p>利用数据库SQL Server 2017 与数据库可视化管理工具Navicat Premium进行搭建，首先参考<a href="https://www.cnblogs.com/ios9/p/9527939.html" target="_blank" rel="noopener external nofollow noreferrer">Win10 SQL Server 2017安装</a>，利用Navicat进行创建一个Faults数据库，并在Faults数据库中创建Rotor表如图所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan2.png" alt></p>
<p>然后根据数据库设计规范，在表中创建相对应的字段。如图所示:</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan.png" alt></p>
<p><strong>注意：</strong> SQL Server 2017不支持数组形式，这里采用将数组转化为字符串,将他们拼接起来当做文本写入。</p>
<p>字段类型在设置的时候注意采用nvarchar(max)的类型，具体如下图：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan3.png" alt></p>
<p><a href="https://data.mendeley.com/datasets/p9bsmj4xwg/1/files/9ecd3bf8-6ed0-452b-8c84-05a4833ac803" target="_blank" rel="noopener external nofollow noreferrer">Rotor数据</a>, 数据是.mat文件，利用Python处理数据后，写入数据库CGQ1这一列中，最终如图所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan4.png" alt></p>
<h5 id="平衡性检验"><a href="#平衡性检验" class="headerlink" title="平衡性检验"></a>平衡性检验</h5><p>平衡性检验工具的实现是先使用Pandas 筛选数据，然后使用Collections模块的Counter 工具进行统计。</p>
<h5 id="故障特征提取-1"><a href="#故障特征提取-1" class="headerlink" title="故障特征提取"></a>故障特征提取</h5><p>故障特征提取工具以独立的代码文件形式进行存放，该工具是多个特征提取函数的集合，如果想使用哪个特征提取函数，只需要在配置文件里指定函数名，如果想使用的函数不存在，模仿已有的函数编辑添加即可。通过这样的设计，无需更改主函数就可改变系统功能。特征提取函数代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span><span class="params">(string)</span>:</span></span><br><span class="line">    string_arr = string.split(<span class="string">','</span>)</span><br><span class="line">    <span class="comment">#print(string_arr)</span></span><br><span class="line">    float_arr = list(map(float, string_arr))</span><br><span class="line">    <span class="keyword">return</span> float_arr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotor_simple</span><span class="params">(arr, logger, conf=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(arr,dict):<span class="comment">#如果数据来源于web,  isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。</span></span><br><span class="line">        arr = trans(arr)</span><br><span class="line">    <span class="comment">#print(arr[1])</span></span><br><span class="line">    rotation_frequency = round(float(arr[<span class="number">0</span>])/<span class="number">60</span>) <span class="comment"># 旋转频率</span></span><br><span class="line">    sample_frequency = int(arr[<span class="number">1</span>]) <span class="comment"># 采样频率</span></span><br><span class="line">    useful_bandwidth = int(sample_frequency/<span class="number">2.56</span>) <span class="comment"># 有效带宽</span></span><br><span class="line">    <span class="keyword">if</span> useful_bandwidth&lt;rotation_frequency*<span class="number">6</span>:</span><br><span class="line">        logger.warning(<span class="string">'数据采样频率过低！数据作废'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    sensor_data = transfer(arr[<span class="number">3</span>]) <span class="comment"># 将逗号拼接的传感器数据变成数组</span></span><br><span class="line">    data_length = len(sensor_data) <span class="comment"># 采样长度</span></span><br><span class="line">    sample_time = data_length/sample_frequency <span class="comment"># 采样时间</span></span><br><span class="line">    frequency_resolution = <span class="number">1</span>/sample_time <span class="comment"># 频率分辨率</span></span><br><span class="line">    <span class="keyword">if</span> (rotation_frequency&lt;<span class="number">10</span> <span class="keyword">and</span> frequency_resolution&gt;<span class="number">0.1</span>) <span class="keyword">or</span> sample_time&lt;<span class="number">1</span>:</span><br><span class="line">        logger.warning(<span class="string">'采样时间过短！数据作废'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    f0_candidates = [rotation_frequency<span class="number">-2</span>,rotation_frequency<span class="number">-1</span>,rotation_frequency,rotation_frequency+<span class="number">1</span>,rotation_frequency+<span class="number">2</span>] <span class="comment"># 基频</span></span><br><span class="line">    spectrum = abs(fft(sensor_data))[:useful_bandwidth]/len(sensor_data)  <span class="comment"># 频谱</span></span><br><span class="line">    f0 = f0_candidates[spectrum[f0_candidates].argmax()]<span class="comment"># 确定基频</span></span><br><span class="line">    segments = [[<span class="number">1</span>,int(<span class="number">0.40</span>*f0)],[int(<span class="number">0.40</span>*f0),int(<span class="number">0.50</span>*f0)],</span><br><span class="line">                [int(<span class="number">0.5</span>*f0)],[int(<span class="number">0.50</span>*f0)+<span class="number">1</span>,int(f0)],[f0],[int(<span class="number">2</span>*f0)],</span><br><span class="line">                [int(<span class="number">3</span>*f0),int(<span class="number">5</span>*f0)+<span class="number">1</span>],[int(<span class="number">6</span>*f0),useful_bandwidth]]</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> seg <span class="keyword">in</span> segments:</span><br><span class="line">        <span class="keyword">if</span> len(seg)==<span class="number">2</span>:</span><br><span class="line">            max_value = max(spectrum[seg[<span class="number">0</span>]:seg[<span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_value = spectrum[seg[<span class="number">0</span>]]</span><br><span class="line">        temp.append(max_value)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotor</span><span class="params">(data, useful_labels, conf, model_dir, logger)</span>:</span></span><br><span class="line">    djzs_field_name = conf[<span class="string">'Table'</span>][<span class="string">'djzs_field_name'</span>]</span><br><span class="line">    gzlx_field_name = conf[<span class="string">'Table'</span>][<span class="string">'gzlx_field_name'</span>]</span><br><span class="line">    cypl_field_name = conf[<span class="string">'Table'</span>][<span class="string">'cypl_field_name'</span>]</span><br><span class="line">    filtered_data = data.loc[:,[djzs_field_name,cypl_field_name,gzlx_field_name,<span class="string">'CGQ1'</span>]][data[gzlx_field_name].isin(useful_labels)]</span><br><span class="line">    </span><br><span class="line">    config_for_web = &#123;<span class="string">'mission'</span>:conf[<span class="string">'Mission'</span>][<span class="string">'table'</span>],</span><br><span class="line">                      <span class="string">'label'</span>:useful_labels,</span><br><span class="line">                     <span class="string">'function_for_web'</span>:conf[<span class="string">'Mission'</span>][<span class="string">'extract_feature_function_for_web'</span>]&#125;</span><br><span class="line">    <span class="keyword">with</span> open(model_dir+<span class="string">'\config_for_web.json'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        json.dump(config_for_web, file, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    feature_and_label = []</span><br><span class="line">    <span class="keyword">for</span> arr <span class="keyword">in</span> filtered_data.values:</span><br><span class="line">        temp = rotor_simple(arr, logger)</span><br><span class="line">        <span class="keyword">if</span> temp != <span class="literal">None</span>:<span class="comment"># 数据有效</span></span><br><span class="line">            temp.append(useful_labels.index(arr[<span class="number">2</span>]))</span><br><span class="line">            feature_and_label.append(temp)</span><br><span class="line">    feature_and_label = np.array(feature_and_label, dtype=np.float32)</span><br><span class="line">    </span><br><span class="line">    column = [<span class="string">'feature&#123;&#125;'</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(feature_and_label.shape[<span class="number">1</span>]<span class="number">-1</span>)]+[<span class="string">'label'</span>]</span><br><span class="line">    df = pd.DataFrame(data=feature_and_label, columns=column)</span><br><span class="line">    df.to_csv(model_dir+<span class="string">'\\feature_and_label.csv'</span>, index=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> feature_and_label</span><br></pre></td></tr></table></figure>

<h5 id="自动化机器学习"><a href="#自动化机器学习" class="headerlink" title="自动化机器学习"></a>自动化机器学习</h5><p>Python 的第三方包TPOT已经实现了基于遗传算法的自动化机器学习，通过在Python 环境中安装TPOT，并且调用相关方法即可实现自动化机器学习。部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger.info(<span class="string">'自动化机器学习初始化...'</span>)</span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"></span><br><span class="line">generations = int(conf[<span class="string">'Tpot'</span>][<span class="string">'generations'</span>])</span><br><span class="line">population_size = int(conf[<span class="string">'Tpot'</span>][<span class="string">'population_size'</span>])</span><br><span class="line">verbosity = int(conf[<span class="string">'Tpot'</span>][<span class="string">'verbosity'</span>])</span><br><span class="line"></span><br><span class="line">model = TPOTClassifier(generations=generations, population_size=population_size,  scoring=<span class="string">'f1_macro'</span>, cv=<span class="number">5</span>, n_jobs=<span class="number">1</span>, verbosity=verbosity)</span><br><span class="line">feature = feature_and_label[:,:<span class="number">-1</span>]</span><br><span class="line">label = feature_and_label[:,<span class="number">-1</span>]</span><br><span class="line">logger.info(<span class="string">'初始化完毕，开始寻找最优机器学习流程...'</span>)</span><br><span class="line">model.fit(feature, label)</span><br><span class="line">logger.info(<span class="string">'寻优结束，开始保存最优机器学习流程...'</span>)</span><br><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line">joblib.dump(model.fitted_pipeline_, model_dir+<span class="string">'\pipeline.pkl'</span>)</span><br><span class="line">logger.info(<span class="string">'保存成功，训练结束！'</span>)</span><br></pre></td></tr></table></figure>


<h5 id="故障诊断系统部署"><a href="#故障诊断系统部署" class="headerlink" title="故障诊断系统部署"></a>故障诊断系统部署</h5><p>利用Python轻型Web框架来进行部署构建故障诊断Web服务器。加载诊断算法和实现HTTP的POST方法。、</p>
<p>加载诊断算法并创建Web服务器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">function_for_web = &#123;&#125;</span><br><span class="line">pipeline = &#123;&#125;</span><br><span class="line">label = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> model_dirs:</span><br><span class="line">    logger.info(<span class="string">'正在读取web配置文件...'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(each+<span class="string">'\config_for_web.json'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            config_for_web = json.load(file)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        logger.error(<span class="string">'读取配置文件&#123;&#125;失败！'</span>.format(each+<span class="string">'\config.ini'</span>), exc_info=<span class="literal">True</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    logger.info(<span class="string">'web配置文件读取完成'</span>)</span><br><span class="line">    </span><br><span class="line">    mission = config_for_web[<span class="string">'mission'</span>]</span><br><span class="line">    function_for_web[mission] = config_for_web[<span class="string">'function_for_web'</span>]</span><br><span class="line">    pipeline[mission] = joblib.load(each+<span class="string">'\pipeline.pkl'</span>)</span><br><span class="line">    label[mission] = config_for_web[<span class="string">'label'</span>]</span><br><span class="line">    </span><br><span class="line">app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">5050</span>)</span><br></pre></td></tr></table></figure>

<p>POST方法实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/',methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diagnose</span><span class="params">()</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    all_data = request.json</span><br><span class="line">    missions = all_data.keys()</span><br><span class="line"><span class="comment">#     logger.info(str(missions))</span></span><br><span class="line">    <span class="keyword">for</span> mission <span class="keyword">in</span> missions:</span><br><span class="line">        exec(<span class="string">'from extract_features import &#123;0&#125; as extract_function'</span>.format(function_for_web[mission]), globals())</span><br><span class="line">        data = all_data[mission]</span><br><span class="line">        feature = extract_function(data, logger, conf)<span class="comment"># feature is a list</span></span><br><span class="line">        proba = pipeline[mission].predict_proba(np.array(feature, np.float32).reshape(<span class="number">1</span>, <span class="number">-1</span>))[<span class="number">0</span>]</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(proba):</span><br><span class="line">            result[label[mission][i]] = <span class="string">'%.1f'</span>%round(float(v)*<span class="number">100</span>,<span class="number">1</span>)</span><br><span class="line">        results[mission] = result</span><br><span class="line"><span class="comment">#     print(results)</span></span><br><span class="line">    <span class="keyword">return</span> json.dumps(results, ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h5 id="故障诊断系统测试"><a href="#故障诊断系统测试" class="headerlink" title="故障诊断系统测试"></a>故障诊断系统测试</h5><p>使用泵轴故障数据（数据类别为正常、转子不对中、转子不平衡、接触摩擦样本各45 个，来源工况单一）来简单测试一下所实现故障诊断系统，测试结果下图所示，横坐标代表机器学习流程组成的种群代数，纵坐标代表每代种群中最优机器学习流程的AUC评分。</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/res.jpg" alt></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>圆圈中最后剩下的数字</title>
    <url>/2020/03/30/62_%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>0,1，···n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<a id="more"></a>

<h2 id="本题考点："><a href="#本题考点：" class="headerlink" title="本题考点："></a>本题考点：</h2><p>  约瑟夫环问题</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h2><p>  1.) 模拟法</p>
<p>  用数组列表模拟一下。创建一个数组存储0-n-1的数组，但数组长度大于1时，就计算end位置即为(start+m-1)%len(nums) ，删除该元素后然后start再等于之前end，最后数组中剩最后一个元素，返回nums[0]</p>
<p>  时间复杂度O(n),空间复杂度O(n)</p>
<p>  2.) 数学方法：</p>
<p>  将上述问题建模为函数 f(n, m)，该函数的返回值为最终留下的元素的序号。</p>
<p>  每删除一个元素，下一个元素成为最开始的头，相当于把数组向前移动m位。若已知n-1个人时，删除下标位置位f(n−1,m)，则n个人的时候，就是往后移动m位，(因为有可能数组越界，超过的部分会被接到头上，所以还要模n)，既f(n,m) = (f(n-1,m) + m) % n</p>
<p>  递归公式为：$f(n, m)=(f(n-1, m)+m) \% n$</p>
<p>  时间复杂度O(n),空间复杂度O(n)</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="方法一：模拟法"><a href="#方法一：模拟法" class="headerlink" title="方法一：模拟法"></a>方法一：模拟法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res =<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span> || m&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">end</span> = (start+m<span class="number">-1</span>)%(nums.<span class="built_in">size</span>());</span><br><span class="line">            nums.erase(nums.<span class="built_in">begin</span>()+<span class="built_in">end</span>);  </span><br><span class="line">            <span class="comment">// vector插入删除操作时间复杂度是O(n)，可能会超时</span></span><br><span class="line">            start = <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二：数学法"><a href="#方法二：数学法" class="headerlink" title="方法二：数学法"></a>方法二：数学法</h4><p>迭代：空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归：空间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(n,m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (f(n<span class="number">-1</span>,m) + m) %n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/u011500062/article/details/72855826" target="_blank" rel="noopener external nofollow noreferrer">约瑟夫环——公式法（递推公式）</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>TPOT优化原理部分源码解读</title>
    <url>/2020/03/28/TPOT%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>TPOT的涉及到的建模过程，以TPOT light为例主要有3块：Classifiers、Preprocesssors、Selectors，TPOT的遗传算法优化是以pipeline为基础的，也就是说pipeline就相当于基因序列。通过构建初始pipeline，再经过遗传算法中的交叉、变异最终生成符合条件的模型效果较好的pipeline。我们从最优的那一代中选取其中建模效果最好的pipeline即可，TPOT是基于scikit-learn框架的，它本身不去实现我们常用的分类回归等算法。而是通过遗传算法优化pipeline。也就是从中选出最优的数据处理、特征选择、分类算法的组合。</p>
<a id="more"></a>
<p>一个简单的TPOT的使用实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"> </span><br><span class="line">iris = load_digits()</span><br><span class="line">iris.data[<span class="number">0</span>:<span class="number">5</span>], iris.target</span><br><span class="line"><span class="keyword">print</span> iris</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line">X_train.shape, X_test.shape, y_train.shape, y_test.shape</span><br><span class="line"> </span><br><span class="line">tpot = TPOTClassifier(verbosity=<span class="number">2</span>, max_time_mins=<span class="number">2</span>,config_dict=<span class="string">"TPOT light"</span>,population_size=<span class="number">10</span>,mutation_rate=<span class="number">0.9</span>,crossover_rate=<span class="number">0.1</span>)</span><br><span class="line">tpot.fit(X_train, y_train)</span><br><span class="line">print(tpot.score(X_test, y_test))</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/2020/03/28/TPOT%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/1.png" alt></p>
<h3 id="部分核心源码解读"><a href="#部分核心源码解读" class="headerlink" title="部分核心源码解读"></a>部分核心源码解读</h3><h4 id="1、初始群体的生成"><a href="#1、初始群体的生成" class="headerlink" title="1、初始群体的生成"></a>1、初始群体的生成</h4><p>这段代码可以看出，pipeline的构建是通过生成不同深度的树类构建初始pipeline的，大致过程是先确定树的深度，从Classifiers中选择一个分类器放入树的顶端，接下来构建分类器的参数，以上均为随机选取。如果树的深度大于1，则还需要从Preprocesssors、Selectors中选择算子加入到pipeline中，还要进行参数初始化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@_pre_test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate</span><span class="params">(self, pset, min_, max_, condition, type_=None)</span>:</span></span><br><span class="line">    <span class="string">"""Generate a Tree as a list of lists.</span></span><br><span class="line"><span class="string">    The tree is build from the root to the leaves, and it stop growing when</span></span><br><span class="line"><span class="string">    the condition is fulfilled.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    pset: PrimitiveSetTyped</span></span><br><span class="line"><span class="string">        Primitive set from which primitives are selected.</span></span><br><span class="line"><span class="string">    min_: int</span></span><br><span class="line"><span class="string">        Minimum height of the produced trees.</span></span><br><span class="line"><span class="string">    max_: int</span></span><br><span class="line"><span class="string">        Maximum Height of the produced trees.</span></span><br><span class="line"><span class="string">    condition: function</span></span><br><span class="line"><span class="string">        The condition is a function that takes two arguments,</span></span><br><span class="line"><span class="string">        the height of the tree to build and the current</span></span><br><span class="line"><span class="string">        depth in the tree.</span></span><br><span class="line"><span class="string">    type_: class</span></span><br><span class="line"><span class="string">        The type that should return the tree when called, when</span></span><br><span class="line"><span class="string">        :obj:None (default) no return type is enforced.</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    individual: list</span></span><br><span class="line"><span class="string">        A grown tree with leaves at possibly different depths</span></span><br><span class="line"><span class="string">        dependending on the condition function.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> type_ <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        type_ = pset.ret</span><br><span class="line">    expr = []</span><br><span class="line">    height = np.random.randint(min_, max_)</span><br><span class="line">    stack = [(<span class="number">0</span>, type_)]</span><br><span class="line">    <span class="keyword">while</span> len(stack) != <span class="number">0</span>:</span><br><span class="line">        depth, type_ = stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># We've added a type_ parameter to the condition function</span></span><br><span class="line">        <span class="keyword">if</span> condition(height, depth, type_):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                term = np.random.choice(pset.terminals[type_])</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                _, _, traceback = sys.exc_info()</span><br><span class="line">                <span class="keyword">raise</span> IndexError(</span><br><span class="line">                    <span class="string">'The gp.generate function tried to add '</span></span><br><span class="line">                    <span class="string">'a terminal of type &#123;&#125;, but there is'</span></span><br><span class="line">                    <span class="string">'none available. &#123;&#125;'</span>.format(type_, traceback)</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">if</span> inspect.isclass(term):</span><br><span class="line">                term = term()</span><br><span class="line">            expr.append(term)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                prim = np.random.choice(pset.primitives[type_])</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                _, _, traceback = sys.exc_info()</span><br><span class="line">                <span class="keyword">raise</span> IndexError(</span><br><span class="line">                    <span class="string">'The gp.generate function tried to add '</span></span><br><span class="line">                    <span class="string">'a primitive of type &#123;&#125;, but there is'</span></span><br><span class="line">                    <span class="string">'none available. &#123;&#125;'</span>.format(type_, traceback)</span><br><span class="line">                )</span><br><span class="line">            expr.append(prim)</span><br><span class="line">            <span class="keyword">for</span> arg <span class="keyword">in</span> reversed(prim.args):</span><br><span class="line">                stack.append((depth + <span class="number">1</span>, arg))</span><br><span class="line">    <span class="keyword">return</span> expr</span><br></pre></td></tr></table></figure>

<h4 id="2、适应性值评估检测"><a href="#2、适应性值评估检测" class="headerlink" title="2、适应性值评估检测"></a>2、适应性值评估检测</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_evaluate_individuals</span><span class="params">(self, individuals, features, target, sample_weight=None, groups=None)</span>:</span></span><br><span class="line">    <span class="string">"""Determine the fit of the provided individuals.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    individuals: a list of DEAP individual</span></span><br><span class="line"><span class="string">        One individual is a list of pipeline operators and model parameters that can be</span></span><br><span class="line"><span class="string">        compiled by DEAP into a callable function</span></span><br><span class="line"><span class="string">    features: numpy.ndarray &#123;n_samples, n_features&#125;</span></span><br><span class="line"><span class="string">        A numpy matrix containing the training and testing features for the individual's evaluation</span></span><br><span class="line"><span class="string">    target: numpy.ndarray &#123;n_samples&#125;</span></span><br><span class="line"><span class="string">        A numpy matrix containing the training and testing target for the individual's evaluation</span></span><br><span class="line"><span class="string">    sample_weight: array-like &#123;n_samples&#125;, optional</span></span><br><span class="line"><span class="string">        List of sample weights to balance (or un-balanace) the dataset target as needed</span></span><br><span class="line"><span class="string">    groups: array-like &#123;n_samples, &#125;, optional</span></span><br><span class="line"><span class="string">        Group labels for the samples used while splitting the dataset into train/test set</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    fitnesses_ordered: float</span></span><br><span class="line"><span class="string">        Returns a list of tuple value indicating the individual's fitness</span></span><br><span class="line"><span class="string">        according to its performance on the provided data</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"> </span><br><span class="line">    operator_counts, eval_individuals_str, sklearn_pipeline_list, stats_dicts = self._preprocess_individuals(individuals)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Make the partial function that will be called below</span></span><br><span class="line">    partial_wrapped_cross_val_score = partial(</span><br><span class="line">        _wrapped_cross_val_score,</span><br><span class="line">        features=features,</span><br><span class="line">        target=target,</span><br><span class="line">        cv=self.cv,</span><br><span class="line">        scoring_function=self.scoring_function,</span><br><span class="line">        sample_weight=sample_weight,</span><br><span class="line">        groups=groups,</span><br><span class="line">        timeout=self.max_eval_time_seconds</span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line">    result_score_list = []</span><br><span class="line">    <span class="comment"># Don't use parallelization if n_jobs==1</span></span><br><span class="line">    <span class="keyword">if</span> self.n_jobs == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> sklearn_pipeline <span class="keyword">in</span> sklearn_pipeline_list:</span><br><span class="line">            self._stop_by_max_time_mins()</span><br><span class="line">            val = partial_wrapped_cross_val_score(sklearn_pipeline=sklearn_pipeline)</span><br><span class="line">            result_score_list = self._update_val(val, result_score_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># chunk size for pbar update</span></span><br><span class="line">        <span class="comment"># chunk size is min of cpu_count * 2 and n_jobs * 4</span></span><br><span class="line">        chunk_size = min(cpu_count()*<span class="number">2</span>, self.n_jobs*<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> chunk_idx <span class="keyword">in</span> range(<span class="number">0</span>, len(sklearn_pipeline_list), chunk_size):</span><br><span class="line">            self._stop_by_max_time_mins()</span><br><span class="line">            parallel = Parallel(n_jobs=self.n_jobs, verbose=<span class="number">0</span>, pre_dispatch=<span class="string">'2*n_jobs'</span>)</span><br><span class="line">            tmp_result_scores = parallel(delayed(partial_wrapped_cross_val_score)(sklearn_pipeline=sklearn_pipeline)</span><br><span class="line">                                         <span class="keyword">for</span> sklearn_pipeline <span class="keyword">in</span> sklearn_pipeline_list[chunk_idx:chunk_idx + chunk_size])</span><br><span class="line">            <span class="comment"># update pbar</span></span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> tmp_result_scores:</span><br><span class="line">                result_score_list = self._update_val(val, result_score_list)</span><br><span class="line"> </span><br><span class="line">    self._update_evaluated_individuals_(result_score_list, eval_individuals_str, operator_counts, stats_dicts)</span><br><span class="line"> </span><br><span class="line">    <span class="string">"""Look up the operator count and cross validation score to use in the optimization"""</span></span><br><span class="line">    <span class="keyword">return</span> [(self.evaluated_individuals_[str(individual)][<span class="string">'operator_count'</span>],</span><br><span class="line">             self.evaluated_individuals_[str(individual)][<span class="string">'internal_cv_score'</span>])</span><br><span class="line">            <span class="keyword">for</span> individual <span class="keyword">in</span> individuals]</span><br></pre></td></tr></table></figure>

<h3 id="3、变异"><a href="#3、变异" class="headerlink" title="3、变异"></a>3、变异</h3><p>变异主要是增加pipeline的内容或更换其中的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_random_mutation_operator</span><span class="params">(self, individual, allow_shrink=True)</span>:</span></span><br><span class="line">    <span class="string">"""Perform a replacement, insertion, or shrink mutation on an individual.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    individual: DEAP individual</span></span><br><span class="line"><span class="string">        A list of pipeline operators and model parameters that can be</span></span><br><span class="line"><span class="string">        compiled by DEAP into a callable function</span></span><br><span class="line"><span class="string">    allow_shrink: bool (True)</span></span><br><span class="line"><span class="string">        If True the `mutShrink` operator, which randomly shrinks the pipeline,</span></span><br><span class="line"><span class="string">        is allowed to be chosen as one of the random mutation operators.</span></span><br><span class="line"><span class="string">        If False, `mutShrink`  will never be chosen as a mutation operator.</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    mut_ind: DEAP individual</span></span><br><span class="line"><span class="string">        Returns the individual with one of the mutations applied to it</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    mutation_techniques = [</span><br><span class="line">        partial(gp.mutInsert, pset=self._pset),</span><br><span class="line">        partial(mutNodeReplacement, pset=self._pset)</span><br><span class="line">    ]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># We can't shrink pipelines with only one primitive, so we only add it if we find more primitives.</span></span><br><span class="line">    number_of_primitives = sum([isinstance(node, deap.gp.Primitive) <span class="keyword">for</span> node <span class="keyword">in</span> individual])</span><br><span class="line">    <span class="keyword">if</span> number_of_primitives &gt; <span class="number">1</span> <span class="keyword">and</span> allow_shrink:</span><br><span class="line">        mutation_techniques.append(partial(gp.mutShrink))</span><br><span class="line"> </span><br><span class="line">    mutator = np.random.choice(mutation_techniques)</span><br><span class="line"> </span><br><span class="line">    unsuccesful_mutations = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(self._max_mut_loops):</span><br><span class="line">        <span class="comment"># We have to clone the individual because mutator operators work in-place.</span></span><br><span class="line">        ind = self._toolbox.clone(individual)</span><br><span class="line">        offspring, = mutator(ind)</span><br><span class="line">        <span class="keyword">if</span> str(offspring) <span class="keyword">not</span> <span class="keyword">in</span> self.evaluated_individuals_:</span><br><span class="line">            <span class="comment"># Update statistics</span></span><br><span class="line">            <span class="comment"># crossover_count is kept the same as for the predecessor</span></span><br><span class="line">            <span class="comment"># mutation count is increased by 1</span></span><br><span class="line">            <span class="comment"># predecessor is set to the string representation of the individual before mutation</span></span><br><span class="line">            <span class="comment"># generation is set to 'INVALID' such that we can recognize that it should be updated accordingly</span></span><br><span class="line">            offspring.statistics[<span class="string">'crossover_count'</span>] = individual.statistics[<span class="string">'crossover_count'</span>]</span><br><span class="line">            offspring.statistics[<span class="string">'mutation_count'</span>] = individual.statistics[<span class="string">'mutation_count'</span>] + <span class="number">1</span></span><br><span class="line">            offspring.statistics[<span class="string">'predecessor'</span>] = (str(individual),)</span><br><span class="line">            offspring.statistics[<span class="string">'generation'</span>] = <span class="string">'INVALID'</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            unsuccesful_mutations += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Sometimes you have pipelines for which every shrunk version has already been explored too.</span></span><br><span class="line">    <span class="comment"># To still mutate the individual, one of the two other mutators should be applied instead.</span></span><br><span class="line">    <span class="keyword">if</span> ((unsuccesful_mutations == <span class="number">50</span>) <span class="keyword">and</span></span><br><span class="line">            (type(mutator) <span class="keyword">is</span> partial <span class="keyword">and</span> mutator.func <span class="keyword">is</span> gp.mutShrink)):</span><br><span class="line">        offspring, = self._random_mutation_operator(individual, allow_shrink=<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> offspring,</span><br></pre></td></tr></table></figure>

<h3 id="4、交叉"><a href="#4、交叉" class="headerlink" title="4、交叉"></a>4、交叉</h3><p>选取两个pipeline，对里面的内容进行互换，但是两个pipeline的primitive要相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pick_two_individuals_eligible_for_crossover</span><span class="params">(population)</span>:</span></span><br><span class="line">    <span class="string">"""Pick two individuals from the population which can do crossover, that is, they share a primitive.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    population: array of individuals</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    tuple: (individual, individual)</span></span><br><span class="line"><span class="string">        Two individuals which are not the same, but share at least one primitive.</span></span><br><span class="line"><span class="string">        Alternatively, if no such pair exists in the population, (None, None) is returned instead.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    primitives_by_ind = [set([node.name <span class="keyword">for</span> node <span class="keyword">in</span> ind <span class="keyword">if</span> isinstance(node, gp.Primitive)])</span><br><span class="line">                         <span class="keyword">for</span> ind <span class="keyword">in</span> population]</span><br><span class="line">    pop_as_str = [str(ind) <span class="keyword">for</span> ind <span class="keyword">in</span> population]</span><br><span class="line"> </span><br><span class="line">    eligible_pairs = [(i, i+<span class="number">1</span>+j) <span class="keyword">for</span> i, ind1_prims <span class="keyword">in</span> enumerate(primitives_by_ind)</span><br><span class="line">                                 <span class="keyword">for</span> j, ind2_prims <span class="keyword">in</span> enumerate(primitives_by_ind[i+<span class="number">1</span>:])</span><br><span class="line">                                 <span class="keyword">if</span> <span class="keyword">not</span> ind1_prims.isdisjoint(ind2_prims) <span class="keyword">and</span></span><br><span class="line">                                    pop_as_str[i] != pop_as_str[i+<span class="number">1</span>+j]]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Pairs are eligible in both orders, this ensures that both orders are considered</span></span><br><span class="line">    eligible_pairs += [(j, i) <span class="keyword">for</span> (i, j) <span class="keyword">in</span> eligible_pairs]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> eligible_pairs:</span><br><span class="line">        <span class="comment"># If there are no eligible pairs, the caller should decide what to do</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    pair = np.random.randint(<span class="number">0</span>, len(eligible_pairs))</span><br><span class="line">    idx1, idx2 = eligible_pairs[pair]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> population[idx1], population[idx2]</span><br></pre></td></tr></table></figure>

<p>TPOT设置了一个阈值来决定是交叉还是变异，默认情况下变异的概率为0.9，交叉的概率为0.1.我们可以修改这个阈值。</p>
<p>具体的pipeline变换如下：</p>
<p>默认的种群数量为100，为了看源码方便，改为了5个种群数。交叉变异的概率各为0.5.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tpot = TPOTClassifier(verbosity=<span class="number">2</span>, max_time_mins=<span class="number">2</span>,config_dict=<span class="string">"TPOT light"</span>,population_size=<span class="number">5</span>,mutation_rate=<span class="number">0.5</span>,crossover_rate=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p>初始种群为5个pipeline，分别为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> = &#123;Individual&#125; KNeighborsClassifier(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), KNeighborsClassifier__n_neighbors=<span class="number">79</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br><span class="line"><span class="number">1</span> = &#123;Individual&#125; KNeighborsClassifier(Binarizer(input_matrix, Binarizer__threshold=<span class="number">0.55</span>), KNeighborsClassifier__n_neighbors=<span class="number">84</span>, KNeighborsClassifier__p=<span class="number">2</span>, KNeighborsClassifier__weights=uniform)</span><br><span class="line"><span class="number">2</span> = &#123;Individual&#125; DecisionTreeClassifier(input_matrix, DecisionTreeClassifier__criterion=gini, DecisionTreeClassifier__max_depth=<span class="number">9</span>, DecisionTreeClassifier__min_samples_leaf=<span class="number">18</span>, DecisionTreeClassifier__min_samples_split=<span class="number">20</span>)</span><br><span class="line"><span class="number">3</span> = &#123;Individual&#125; LogisticRegression(StandardScaler(input_matrix), LogisticRegression__C=<span class="number">0.0001</span>, LogisticRegression__dual=<span class="literal">True</span>, LogisticRegression__penalty=l2)</span><br><span class="line"><span class="number">4</span> = &#123;Individual&#125; GaussianNB(input_matrix)</span><br></pre></td></tr></table></figure>
<p>经过第一轮交叉、变异，结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> = &#123;Individual&#125; LogisticRegression(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), LogisticRegression__C=<span class="number">0.1</span>, LogisticRegression__dual=<span class="literal">True</span>, LogisticRegression__penalty=l2)</span><br><span class="line"><span class="number">1</span> = &#123;Individual&#125; KNeighborsClassifier(input_matrix, KNeighborsClassifier__n_neighbors=<span class="number">79</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br><span class="line"><span class="number">2</span> = &#123;Individual&#125; KNeighborsClassifier(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), KNeighborsClassifier__n_neighbors=<span class="number">79</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br><span class="line"><span class="number">3</span> = &#123;Individual&#125; GaussianNB(input_matrix)</span><br><span class="line"><span class="number">4</span> = &#123;Individual&#125; KNeighborsClassifier(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), KNeighborsClassifier__n_neighbors=<span class="number">84</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br></pre></td></tr></table></figure>

<p>然后对这几个pipeline进行打分评估，和上一轮pipeline一起选出score最高的前5个。</p>
<p>进入下一轮迭代。最后产生5个pipeline，打分，从中选出最优的那个：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Best pipeline: KNeighborsClassifier(input_matrix, n_neighbors=<span class="number">10</span>, p=<span class="number">2</span>, weights=distance)</span><br><span class="line"><span class="number">0.977777777778</span></span><br></pre></td></tr></table></figure>

<p>流程举例如下（具体流程和TPOT代码本身略有区别，但是不影响对遗传算法自动化建模的理解）</p>
<p><img src="/2020/03/28/TPOT%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/2.png" alt></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://blog.csdn.net/hgy0403/article/details/81291307" target="_blank" rel="noopener external nofollow noreferrer">TPOT遗传算法</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Github分支备份Hexo博客源文件</title>
    <url>/2020/03/21/%E5%88%A9%E7%94%A8Github%E5%88%86%E6%94%AF%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>Hexo 部署博客很方便，我的这个博客也是用 Hexo 部署在 GitHub Pages 上的，有得人可能在多台电脑上写博客，这个时候需要把博客的源文件备份在一个地方，这样只需把博客源文件复制下来就可以在另一个地方写博客并部署到 GitHub Pages上了</p>
<a id="more"></a>
<p>本篇介绍的就是利用博客的 repo 分支（ master 分支的必须用来存放你博客网站文件）托管 Hexo 源文件和配置达到备份的目的，下面开始正题</p>
<h4 id="把博客目录的源文件push到repo分支上"><a href="#把博客目录的源文件push到repo分支上" class="headerlink" title="把博客目录的源文件push到repo分支上"></a>把博客目录的源文件push到repo分支上</h4><p>cd 进入博客目录，Git 初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>完成之后，添加修改的文件，Hexo 就自带了 .gitignore 文件需要忽略的文件 都已经默认配置好了，add 全部文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>然后commit：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;commit first time&quot;</span><br></pre></td></tr></table></figure>
<p>提交成功之后，接下来就是 push 到github了，需要先把这 Hexo 源文件映射到远程 repo 上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;your-name&#x2F;your-name.github.io.git</span><br></pre></td></tr></table></figure>

<p>接下来就是把Hexo源文件 push 上去，但是关键的地方到了，master上是 Hexo 生成博客网页的代码，而我们 Hexo 源文件是要 push 到一个分支上面的，所以接下来先要在 repo 上新建一个分支</p>
<p>新建一个叫做blogSource的分支(注意：分支名要和本地hexo项目名一致，不然push会出错)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch blogSource</span><br></pre></td></tr></table></figure>

<p>查看本地分支，并且切换到 blogSource 分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git checkout blogSource</span><br></pre></td></tr></table></figure>

<p>然后拉取远程代码，再把刚才添加的 Hexo 源文件代码 push 到blogSource这个分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br><span class="line">git push -u origin blogSource</span><br></pre></td></tr></table></figure>
<p>然后就可以在 repo 上看到分支里面已经有博客的源文件了</p>
<h4 id="日常更新博客源文件"><a href="#日常更新博客源文件" class="headerlink" title="日常更新博客源文件"></a>日常更新博客源文件</h4><p>以后你本地的博客源文件的修改就可以直接用 git 命令 push 到 repo 的 blogSource 分支上了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .  &#x2F;&#x2F;添加修改内容到本地仓储</span><br><span class="line">git commit -m &#39;modify blog&#39;  &#x2F;&#x2F;提交修改内容到本地仓库</span><br><span class="line">git push --set-upstream origin blogSource  &#x2F;&#x2F;配置push，以方便后期直接git push推送</span><br><span class="line">git push  &#x2F;&#x2F;将本地分支和分支下的内容推送到远程</span><br></pre></td></tr></table></figure>

<p>注意：执行 git push –set-upstream origin blogSource 命令之后，以后修改博客源文件代码之后，直接使用 git push 不用再指定分支，就可以把代码 push 到 blogSource 分支上了</p>
<h4 id="更换地点使用-repo-分支上的博客源文件"><a href="#更换地点使用-repo-分支上的博客源文件" class="headerlink" title="更换地点使用 repo 分支上的博客源文件"></a>更换地点使用 repo 分支上的博客源文件</h4><p>换一台电脑，配置好 Hexo 的环境，<a href="https://xiaovv.me/2017/04/06/GitHub%E9%85%8D%E7%BD%AESSH-key/" target="_blank" rel="noopener external nofollow noreferrer">配置 Git SSH key</a>，把博客源文件代码克隆下来:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone xxxxxxxxx.xx (你的 github page 的 repo 地址)</span><br></pre></td></tr></table></figure>

<p>博客源文件下载下来之后，默认的分支是 master，需要切换到 blogSource 分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout origin&#x2F;blogSource</span><br></pre></td></tr></table></figure>

<p>然后cd到博客目录依次执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>接下来就可以开始愉快的写博客了，写完之后记得把源文件代码 push 到 Github 上，然后用 Hexo 部署到自己博客上面</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + NexT主题博客相关设置</title>
    <url>/2020/03/21/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="一、添加文章版权声明功能"><a href="#一、添加文章版权声明功能" class="headerlink" title="一、添加文章版权声明功能"></a>一、添加文章版权声明功能</h4><p>打开博客目录下的主题配置文件（/themes/next/_config.yml），找到Declare license on posts 标签，进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Declare license on posts</span><br><span class="line">post_copyright:</span><br><span class="line">  enable: true    #激活版权声明模块</span><br><span class="line">  license: CC BY-NC-SA 3.0     #版权许可协议</span><br><span class="line">  license_url: https:&#x2F;&#x2F;winney07.github.io&#x2F;      #声明的文章的可点击链接（域名）</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>配置完后，执行以下命令，在浏览器中访问，效果如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/next-set1.png" alt></p>
<h4 id="二、设置favicon图标"><a href="#二、设置favicon图标" class="headerlink" title="二、设置favicon图标"></a>二、设置favicon图标</h4><p>1、选择一个favicon制作网站完成制作，例如：比特虫 ，制作一个16*16，一个32*32的；</p>
<p>2、两个不同尺寸大小的文件，重名为favicon-16x16-next.png和favicon-32x32-next.png；</p>
<p>3、将重命名的两个图片文件放到博客目录下的themes/next/source/images中（覆盖原来的两个默认的）<br>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/favicon.png" alt></p>
<h3 id="三、添加友情链接"><a href="#三、添加友情链接" class="headerlink" title="三、添加友情链接"></a>三、添加友情链接</h3><p>打开主题配置文件（/themes/next/_config.yml），找到以下内容进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: 友情链接 </span><br><span class="line"># links_layout: block   &#x2F;&#x2F;块状显示（选择了行内显示，这个要注释掉，不然会报错）</span><br><span class="line">links_layout: inline    &#x2F;&#x2F;行内显示</span><br><span class="line">links:</span><br><span class="line">  小超: https:&#x2F;&#x2F;www.xiaochao.me&#x2F;</span><br><span class="line">  Github: https:&#x2F;&#x2F;www.github.com</span><br></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/friend-link.png" alt></p>
<h4 id="四、调整hexo页面宽度"><a href="#四、调整hexo页面宽度" class="headerlink" title="四、调整hexo页面宽度"></a>四、调整hexo页面宽度</h4><p>博客在浏览器上的留白太多，因此想增加文章的宽度。</p>
<p>打开/themes/next/source/css/_variables/custom.styl 添加两行代码即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$main-desktop &#x3D; 1200px </span><br><span class="line">$content-desktop &#x3D; 900px</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>在Hexo博客中发布文章</title>
    <url>/2020/03/21/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h4 id="1、新建一篇文章"><a href="#1、新建一篇文章" class="headerlink" title="1、新建一篇文章"></a>1、新建一篇文章</h4><p>（1）在hexo博客目录下，进入Git Bash命令窗口中，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;在这里&quot;</span><br></pre></td></tr></table></figure>

<p>（2）在博客目录下的/source/_posts/ 文件夹下，可以看到已经生成了标题为(在这里.md)的博客文件：<br>如图所示：<br><img src="https://winney07.github.io/2018/08/02/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/zai.png" alt></p>
<a id="more"></a>
<p>（3）在（在这里.md）文件中编辑自己的博客文章即可。<br>注意：Hexo 发布的文章是 Markdown 格式的文件， Markdown 基本语法的网址：<a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener external nofollow noreferrer">点这里前往</a></p>
<h4 id="2、给文章添加分类和标签"><a href="#2、给文章添加分类和标签" class="headerlink" title="2、给文章添加分类和标签"></a>2、给文章添加分类和标签</h4><p>(1) 在（在这里.md）文件中设置tags和categories属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 在这里</span><br><span class="line">date: 2018-08-02 11:41:10</span><br><span class="line">tags:</span><br><span class="line">- 博客           &#x2F;&#x2F;多个标签可以这样添加</span><br><span class="line">- hexo</span><br><span class="line">categories: test</span><br></pre></td></tr></table></figure>
<p>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/zai-edit.png" alt></p>
<h4 id="3、启动服务器，本地测试"><a href="#3、启动服务器，本地测试" class="headerlink" title="3、启动服务器，本地测试"></a>3、启动服务器，本地测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h4 id="4、添加“阅读全文”按钮"><a href="#4、添加“阅读全文”按钮" class="headerlink" title="4、添加“阅读全文”按钮"></a>4、添加“阅读全文”按钮</h4><p>方法一：在文章任意你想添加的位置添加即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p>方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto_excerpt进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>

<p>其中length代表显示摘要的截取字符长度。</p>
<p>注：这两种方法，在博客首页显示的效果不一样，根据自己的需要，选择自己喜欢的方法</p>
<h4 id="5、在博文中添加图片"><a href="#5、在博文中添加图片" class="headerlink" title="5、在博文中添加图片"></a>5、在博文中添加图片</h4><p>方法一：</p>
<p>(1)在blog目录下，安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>(2)在blog\source 目录下新建一个images文件夹，把图片放置在里面；</p>
<p>(3)在xxx.md文件中引用图片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![header]( images&#x2F;header.jpg)</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<p>(1)在全局配置文件（blog/_config.yml)中将post_asset_folder设置为true；</p>
<p>(2)创建文章（在创建的时候，会在blog/source/_post目录下，生成一个XXX.md文件和一个XXX的文件夹）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;XXX&quot;</span><br></pre></td></tr></table></figure>

<p>(3)把XXX这个博文需要展示的图片放在XXX文件夹目录下；</p>
<p>(4)在XXX.md文件中引入图片的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![你想输入的替代文字](XXX&#x2F;图片名.jpg)</span><br></pre></td></tr></table></figure>
<h4 id="6、发布到Github上"><a href="#6、发布到Github上" class="headerlink" title="6、发布到Github上"></a>6、发布到Github上</h4><p>（1）发表的文章在本地预览无误后，在 Git Bash 命令窗口执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>（2）在浏览器，访问自己的博客域名，即可看到刚 发布的文章</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>将Hexo博客主题更换为NexT主题</title>
    <url>/2020/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p>1、把默认主题更改成Next主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>这是将Next主题下载到blog目录的themes主题下的next文件夹中。打开站点的_config.yml配置文件，修改主题为next<br><img src="/2020/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/1.jpg" alt></p>
<a id="more"></a>
<p>打开<strong>主题theme</strong>的_config.yml配置文件，不是<strong>站点site</strong>主题文件，找到Scheme Settings<br><img src="/2020/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/2.jpg" alt><br>next主题有三个样式，我用的是Pisces，可以选择你自己喜欢的样式（只需要把行首的#去除，#是注释），选择好后，再次部署网站，hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。</p>
<p>2、在主题配置文件 _config.yml中配置博客网站底部的基本信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup.</span><br><span class="line">  # If not defined, current year will be used.</span><br><span class="line">  since: 2020      #网站起始运营年份</span><br><span class="line"></span><br><span class="line">  # Icon between year and copyright info.</span><br><span class="line">  icon: user     #声明图标</span><br><span class="line"></span><br><span class="line">  # If not defined, will be used &#96;author&#96; from Hexo main config.</span><br><span class="line">  copyright: bryceustc   #版权所有</span><br><span class="line">  # ------------------------------------------------------------</span><br><span class="line">  # Hexo link (Powered by Hexo).</span><br><span class="line">  powered: true</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">    enable: false    #是否显示主题</span><br><span class="line">    # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">    version: false     #是否显示驱动</span><br></pre></td></tr></table></figure>

<p>3、在主题配置文件 _config.yml中配置菜单按钮，找到menu属性，做以下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line"> home: &#x2F; || home     #首页，后面的表示图标</span><br><span class="line"> categories: &#x2F;categories&#x2F; || th   #分类</span><br><span class="line"> tags: &#x2F;tags&#x2F; || tags       #标签</span><br><span class="line"> archives: &#x2F;archives&#x2F; || archive     #归档</span><br><span class="line"> about: &#x2F;about&#x2F; || user       #关于</span><br><span class="line"> #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line"> #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line"> #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure>
<p>4、创建相应的页面</p>
<p>（1）执行命令hexo s，本地预览我们的博客页面，会发现，点击分类、标签、关于这几个页面的时候，会显示404。</p>
<p>（2）在Git Bash命令窗口，输入以下命令来创建相应页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &#39;categories&#39;</span><br><span class="line">hexo new page &#39;tags&#39;</span><br><span class="line">hexo new page &#39;about&#39;</span><br></pre></td></tr></table></figure>
<p>（3）可以在hexo/source目录下看到创建的3个文件夹<br><img src="https://winney07.github.io/2018/08/01/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/source.png" alt></p>
<p>5、每一个分类菜单都生成了一个 index.md 初始文件（在刚创建的文件夹目录下），默认包含了 title 和 date 字段，我们需要给每一 index.md 文件添加上 type 字段<br>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-3-20 16:28:33</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-3-20 16:28:33</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2020-3-20 16:28:33</span><br><span class="line">type: about</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>6、配置搜索菜单：<br>（1）安装 hexo-generator-searchdb ，在 Git Bash 命令窗口，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>（2）打开全局配置文件（hexo/_config.yml），新增以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>（3）打开主题配置文件（hexo/themes/next/_config.yml），找到 local_search 属性，开启本地搜索功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>
<p>7、执行命令hexo s，本地预览我们的博客页面，发现刚才的配置已经完成</p>
<p>8、在命令窗口，输入以下命令，将修改后的本地hexo项目托管到GitHub上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>9、上传成功后，可以通过自己的博客域名访问修改主题和修改相关配置后的博客页面</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + GitHub Pages 搭建个人博客</title>
    <url>/2020/03/19/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><h4 id="1、安装Node-js"><a href="#1、安装Node-js" class="headerlink" title="1、安装Node.js"></a>1、安装Node.js</h4><p>(1) 下载Node.js：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener external nofollow noreferrer">官网下载地址</a> （这里以Windows 为例）;</p>
<p><img src="/images/node.png" alt></p>
<a id="more"></a>
<p>(2) 双击下载好的.msi文件，按下一步下一步，安装好就可以；</p>
<p>(3) 在cmd命令窗口，输入下面的这个命令，如果能够显示Node.js的版本，说明安装成功了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<p><img src="/images/node_v.png" alt></p>
<h4 id="2、安装Git"><a href="#2、安装Git" class="headerlink" title="2、安装Git"></a>2、安装Git</h4><p>(1) 下载Git：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener external nofollow noreferrer">官网下载</a></p>
<p>(2) 双击下载好的Git安装包，按下一步下一步，进行安装即可；</p>
<p>(3) 在cmd命令窗口，输入下面的这个命令，如果能够显示Git的版本，说明安装成功了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p><img src="/images/git_v.png" alt></p>
<h3 id="二、Hexo搭建博客"><a href="#二、Hexo搭建博客" class="headerlink" title="二、Hexo搭建博客"></a>二、Hexo搭建博客</h3><h4 id="1、安装Hexo"><a href="#1、安装Hexo" class="headerlink" title="1、安装Hexo"></a>1、安装Hexo</h4><p>（1）在计算机中，新建一个Blog文件夹，用于存放自己的博客内容。</p>
<p>（2）在Blog文件夹内，鼠标右键，选择Git Bash,进入到命令窗口</p>
<p><img src="/images/blog.png" alt></p>
<p>（3）在命令窗口中，输入下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h4 id="2、初始化Hexo"><a href="#2、初始化Hexo" class="headerlink" title="2、初始化Hexo"></a>2、初始化Hexo</h4><p>在命令窗口中，输入下面代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<h4 id="3、配置Hexo"><a href="#3、配置Hexo" class="headerlink" title="3、配置Hexo"></a>3、配置Hexo</h4><p>(1) 安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>(2) 部署形成的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g &#x2F;&#x2F;或者 hexo generate</span><br></pre></td></tr></table></figure>

<h4 id="4、启动服务器"><a href="#4、启动服务器" class="headerlink" title="4、启动服务器"></a>4、启动服务器</h4><p>(1) 在命令窗口执行下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s  &#x2F;&#x2F;或者 hexo server</span><br></pre></td></tr></table></figure>

<p>(2) 在浏览器地址栏中输入<a href="http://localhost:4000/" target="_blank" rel="noopener external nofollow noreferrer">http://localhost:4000/</a> （默认端口是4000），如果能够看到如图所示的效果，说明初始化的Hexo博客搭建成功了。<br>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-blog.png" alt></p>
<h4 id="三、将本地的-Hexo-博客部署到-GitHub-Pages上"><a href="#三、将本地的-Hexo-博客部署到-GitHub-Pages上" class="headerlink" title="三、将本地的 Hexo 博客部署到 GitHub Pages上"></a>三、将本地的 Hexo 博客部署到 GitHub Pages上</h4><p>（1）新建一个仓库，仓库名为bryceustc.github.io（这个仓库的名称必须严格按照 username.github.io 的格式来命名）【前提是你要有一个Github账号】<br>如图所示：（因为我已经创建过这个库了，所以会显示红色警告，只是后来为了截图，重新写一个同名的）</p>
<p><img src="/images/github.png" alt></p>
<p>（2）进入已经创建好的仓库（点击自己的头像，选择Your profile，点击刚创建好的那个仓库进去仓库里面），点击settings，找到GitHub Pages 选项，点击 Choose a theme 选择一个主题（可以选择也可以不选择，根据自己的需求决定是否操作这一步）<br>如图所示：</p>
<p><img src="/images/gitpages.png" alt></p>
<p>（3）配置Git个人信息，在winneyBlog目录下，鼠标右键，选择Git Bash，进入命令窗口，输入下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Github用户名&quot;       &#x2F;&#x2F;自己Github的账号名</span><br><span class="line">git config --global user.email &quot;Github邮箱&quot;        &#x2F;&#x2F;自己注册Github的邮箱地址</span><br></pre></td></tr></table></figure>

<p>（4）生成SSH KEY,意思是生成一个公钥和密钥，因为Github需要一个密钥才能与本地相连接。在命令窗口输入下面的命令，然后需要连续按3次回车生成密钥（每按一次回车你可以看到对应的信息） 【你也可以先查看是否已经有了ssh密钥：cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C  &quot;Github邮箱&quot;        &#x2F;&#x2F;自己注册Github的邮箱地址</span><br></pre></td></tr></table></figure>

<p>如图所示：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh-key.png" alt></p>
<p>（5）生成的SSH KEY会保存到 C:/Users/电脑名用户名/.ssh 目录中（根据你自己电脑用户名，打开对应的目录）</p>
<ul>
<li>打开.ssh 这个目录，打开 id_rsa.pub 文件，复制里面的全部内容（这些内容就是密钥）<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/user-ssh.png" alt></li>
</ul>
<p>（6）在GitHub中添加SSH keys</p>
<ul>
<li><p>打开Github，点击头像，选择Settings；</p>
</li>
<li><p>选择SSH and GPG keys项,点击右上角New SSH key按钮，将刚刚复制到的密钥粘贴到key输入框中，title自己给它命一个名就好<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/add-key.png" alt></p>
</li>
<li><p>最后点击Add Key，如果显示这样的界面，说明SSH KEY 配置成功：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh-keys.png" alt></p>
</li>
</ul>
<p>（7）修改全局配置文件</p>
<ul>
<li><p>在blog文件夹下，找到_config.yml文件；如图所示：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy.png" alt></p>
</li>
<li><p>复制仓库地址：如图所示：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/git-href.png" alt></p>
</li>
<li><p>修改_config.yml文件里的deploy属性(目的是将本地hexo项目放到Github上)如图所示：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy.png" alt></p>
</li>
</ul>
<p><strong>注：</strong>【如果repository中填写的是https协议的，hexo d上传代码到Github时有下面类似错误，可以将repository改为ssh的链接】<br>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy-error.png" alt></p>
<p><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh-link.png" alt></p>
<p>（8）安装hexo-deployer-git 插件，目的是将代码快速托管到Github上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>（9）将hexo项目托管到GitHub上（命令可以分开写也可以一起写）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>备注:<br>hexo clean // 清除缓存文件 (db.json) 和已生成的静态文件 (public)</p>
<p>hexo generate // 部署之前预先生成静态文件，简写为hexo g</p>
<p>hexo deploy // 文件生成后立即部署网站，简写为hexo d</p>
<p>（10）在浏览器地址栏输入 <a href="https://username.github.io/" target="_blank" rel="noopener external nofollow noreferrer">https://username.github.io/</a> 即可访问，（username也就是你的Github账户名），如果能够正常访问，并且跟本地hexo项目显示的内容是一样的，那么说明你已经把本地hexo项目部署到Github上了。</p>
<h4 id="四、配置博客的个人信息"><a href="#四、配置博客的个人信息" class="headerlink" title="四、配置博客的个人信息"></a>四、配置博客的个人信息</h4><p>（1）在hexo目录中，找到全局配置文件_config.yml</p>
<p>（2）配置信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html</span><br><span class="line">## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: Bryce&#39;s Blog</span><br><span class="line">subtitle: Learn Everything.</span><br><span class="line">description: A Student From USTC.</span><br><span class="line">author: Bryce</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone: Asia&#x2F;Shanghai</span><br><span class="line"></span><br><span class="line"># URL 博客地址</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: https:&#x2F;&#x2F;bryceustc.github.io&#x2F;</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br><span class="line"></span><br><span class="line"># Directory 目录设置</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads&#x2F;code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link:</span><br><span class="line">  enable: true # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: &#39;&#39;</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: true</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace: &#39;&#39;</span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br><span class="line"></span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default &#x3D; &#39;&#39;)</span><br><span class="line"># per_page: Posts displayed per page. (0 &#x3D; disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#39;&#39;</span><br><span class="line">  per_page: 5 #每页文章数量</span><br><span class="line">  order_by: -date</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Metadata elements</span><br><span class="line">## https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTML&#x2F;Element&#x2F;meta</span><br><span class="line">meta_generator: true</span><br><span class="line"></span><br><span class="line"># Date &#x2F; Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F;</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">## Use post&#39;s date for updated date unless set in front-matter</span><br><span class="line">use_date_for_updated: false</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Include &#x2F; Exclude file(s)</span><br><span class="line">## include:&#x2F;exclude: options only apply to the &#39;source&#x2F;&#39; folder</span><br><span class="line">include:</span><br><span class="line">exclude:</span><br><span class="line">ignore:</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next</span><br><span class="line">plugins: hexo-generate-feed</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;bryceustc&#x2F;bryceustc.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>注意：.yml 文件有严格的格式要求，文件里所有的配置都是：冒号 空格 值，并且冒号是英文状态下的输入。想了解更多的可以前往官网。</p>
<p>（3）在博客目录下，右键点击Git Bash，进去命令窗口，输入下面的命令，即可在浏览器中看到刚刚设置的内容显示在页面中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server    &#x2F;&#x2F;简写为hexo s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/2020/03/18/3_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0~n-1范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2，3，1，0，2，5，3}，那么对应的输出是重复的数字2或者3</p>
<a id="more"></a>

<p>在一个长度为n+1的数组里的所有数字都在1~n范围内。所以数组中至少有一个数是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，输入长度为8的数组{2，3，5，4，3，2，6，7}，那么对应的输出是重复的数字2或者3。</p>
<h2 id="本题考点"><a href="#本题考点" class="headerlink" title="本题考点"></a>本题考点</h2><p>  1). 一维数组的理解，一维数组在内存中占据连续空间，可以根据下标定位对应的元素</p>
<p>  2). 二分查找算法的理解，快速正确实现二分查找</p>
<p>  3). 时间复杂度与空间复杂度的理解</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>  1). 把输入的数组进行排序，排序后再判断有无重复数字，时间复杂度为O(nlogn)</p>
<p>  2). 使用哈希表来解决，时间复杂度为O(n)，但空间复杂度也为O(n)</p>
<p>  3). 交换位置重排法，把每个数字放回对应位置的方法。如果出现一个数字无法放回（所在位置已经是对应数字了），那么说明该数字重复，时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>  4). 题目二可以依照题目一的思路来，不过由于不能修改输入数组，所以可以构建一个n+1大小的辅助数组，构建了辅助数组之后可以使用hash表也可以使用换位置的思路来做 </p>
<p>  5). 使用二分的思想来做，二分基数组，但这种方法不能找出所有重复的数字，时间复杂度为O(nlogn)，空间复杂度为O(1)，相当于用时间换取空间</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="方法一：排序后直接查找"><a href="#方法一：排序后直接查找" class="headerlink" title="方法一：排序后直接查找"></a>方法一：排序后直接查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Duplication</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums.empty()||n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> || nums[i] &gt; n - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(nums[i]);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：利用哈希表"><a href="#方法二：利用哈希表" class="headerlink" title="方法二：利用哈希表"></a>方法二：利用哈希表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Duplication</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums.empty() || n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> || nums[i] &gt; n<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                m[i]++;</span><br><span class="line">                <span class="keyword">if</span>(m[i]&gt;<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(i);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法三：交换位置重排"><a href="#方法三：交换位置重排" class="headerlink" title="方法三：交换位置重排"></a>方法三：交换位置重排</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Duplication</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums,<span class="keyword">int</span> n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//异常值检测</span></span><br><span class="line">            <span class="keyword">if</span> (nums.empty() || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//越界检测</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]&lt; <span class="number">0</span> || nums[i] &gt; n<span class="number">-1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//只要当前数值与索引不等，就要一直替换</span></span><br><span class="line">                <span class="keyword">while</span> (nums[i]!=i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//一旦遇到当前的数值与另外一个换位的值相等，就停止，说明找到了重复的数字</span></span><br><span class="line">                    <span class="keyword">if</span> (nums[i] == nums[nums[i]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(nums[i]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        flag = <span class="literal">true</span>;  <span class="comment">//return直接跳出所有循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                    nums[i] = nums[temp];</span><br><span class="line">                    nums[temp] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法四：二分法查找"><a href="#方法四：二分法查找" class="headerlink" title="方法四：二分法查找"></a>方法四：二分法查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ( nums.empty() || n &lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">end</span> = n;</span><br><span class="line">      <span class="keyword">while</span>(<span class="built_in">end</span> &gt; start)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;=start &amp;&amp; nums[i]&lt;=mid)</span><br><span class="line">            &#123;</span><br><span class="line">              m++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; mid - start+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">           start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://blog.csdn.net/hunanchenxingyu/article/details/8101795" target="_blank" rel="noopener external nofollow noreferrer">循环结构中break、continue、return和exit的区别</a></p>
</li>
<li><p><a href="https://blog.csdn.net/zolalad/article/details/11848739" target="_blank" rel="noopener external nofollow noreferrer">时间复杂度和空间复杂度</a></p>
</li>
<li><p><a href="https://github.com/bryceustc/LeetCode_Note/blob/master/cpp/Find-First-And-Last-Position-Of-Element-In-Sorted-Array/BinarySearch.md" target="_blank" rel="noopener external nofollow noreferrer">二分查找算法</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
