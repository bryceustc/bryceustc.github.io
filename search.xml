<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020.11.3 笔试题</title>
    <url>/2020/11/03/2020-11-3-%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>记录一下2020.11.03银行的三道笔试题。</p>
<ol>
<li>大意是每购买完一件产品，记录的是已经购买完的所有产品的最大价值，但是只能记录最后连续k件的最大价格。输出记录的价格。</li>
</ol>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">1</span><br><span class="line">3 2</span><br><span class="line">9 6 6</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">9 9 6</span><br></pre></td></tr></table></figure></p>
<p>思路：类似滑动窗口最大值<br><span id="more"></span><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n){</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[q.<span class="built_in">back</span>()]){</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; (i-q.<span class="built_in">front</span>()+<span class="number">1</span>)&gt;k) {</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        }</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        <span class="keyword">if</span> (i != (<span class="type">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>) {</span><br><span class="line">            cout &lt;&lt; nums[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            cout &lt;&lt; nums[i] &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) {</span><br><span class="line">        <span class="type">int</span> n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            cin &gt;&gt; nums[i];</span><br><span class="line">        }</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        res = <span class="built_in">helper</span>(nums, k);</span><br><span class="line">        <span class="built_in">printVec</span>(res);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<ol>
<li>漂流模拟，有n段陡坡，在进入每段陡坡瞬间，他们的皮划艇前进速度都会瞬间+1，而当通过陡坡时，由于惯性，皮划艇会保持当前速度前进。</li>
</ol>
<p>在开始漂流时，初始速度为1，已知陡坡信息以及漂流总长度为L，请问他们耗时多久完成漂流。</p>
<p>示例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">1</span><br><span class="line">2 6</span><br><span class="line">2 3</span><br><span class="line">4 7</span><br><span class="line"></span><br><span class="line">输出：3.000000</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) {</span><br><span class="line">        <span class="type">int</span> n, L;</span><br><span class="line">        <span class="type">double</span> t = <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">double</span> v = <span class="number">1.0</span>;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; L;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; doupo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            doupo.<span class="built_in">push_back</span>({l,r});</span><br><span class="line">        }</span><br><span class="line">        <span class="type">double</span> t1, t2;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> end = L + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : doupo) {</span><br><span class="line">            t1 = (p.first - start) / v;</span><br><span class="line">            start = p.first;</span><br><span class="line">            v += <span class="number">1.0</span>;</span><br><span class="line">            t2 = (<span class="type">double</span>)(p.second - start) / v;</span><br><span class="line">            start = p.second;</span><br><span class="line">            t = t + t1 + t2;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">double</span> t3 = (end - start) / v;</span><br><span class="line">        t += t3;</span><br><span class="line">        cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">6</span>) &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ol>
<li>迷宫有唯一的入口和唯一的出口，同时有若干个空地，障碍物，以及一些有效点，给一张地图，看能否从S走到T点，并且经过全部有效点，可以的话输出YES，否则输出NO。</li>
</ol>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">1</span><br><span class="line">3 3</span><br><span class="line">S . X</span><br><span class="line">. . X</span><br><span class="line">X . T</span><br><span class="line"></span><br><span class="line">输出：YES</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="type">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;g, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;vis, <span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> &amp;valid, <span class="type">int</span> count)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (g[i][j] == <span class="string">'T'</span> &amp;&amp; valid == count) {</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) {</span><br><span class="line">        <span class="type">int</span> x = i + dx[k];</span><br><span class="line">        <span class="type">int</span> y = j + dy[k];</span><br><span class="line">        <span class="keyword">if</span> ((x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m) &amp;&amp; vis[x][y] == <span class="number">0</span> &amp;&amp; (g[x][y] ==<span class="string">'.'</span> || g[x][y] == <span class="string">'X'</span> || g[x][y] == <span class="string">'T'</span>)) {</span><br><span class="line">            <span class="keyword">if</span> (g[x][y] == <span class="string">'X'</span>) valid++;</span><br><span class="line">            vis[x][y] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(g, vis, n, m, x, y, valid, count);</span><br><span class="line">            <span class="keyword">if</span> (g[x][y] == <span class="string">'X'</span>) valid--;</span><br><span class="line">            vis[x][y] = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;g, <span class="type">int</span> count)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = g.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vis</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">'S'</span>) {</span><br><span class="line">                <span class="built_in">dfs</span>(g, vis, n, m, i, j, valid, count);</span><br><span class="line">                <span class="keyword">if</span> (flag) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) {</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">g</span>(n, <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;(m));</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                cin &gt;&gt; g[i][j];</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">'X'</span>) count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(g, count)) cout &lt;&lt; <span class="string">"YES"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">"NO"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>2020招商银行Fintech训练营研发赛道题目总结</title>
    <url>/2020/04/29/2020%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8CFintech%E8%AE%AD%E7%BB%83%E8%90%A5%E7%A0%94%E5%8F%91%E8%B5%9B%E9%81%93%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="2020Fintech"><a href="#2020Fintech" class="headerlink" title="2020Fintech"></a>2020Fintech</h1><p>记录一下参加2020招商银行Fintech训练营的初赛题目。<br><span id="more"></span></p>
<h2 id="金币"><a href="#金币" class="headerlink" title="金币"></a><a href="https://ac.nowcoder.com/acm/contest/5246/A">金币</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小招在玩一款游戏：在一个N层高的金字塔上，以金字塔顶为第一层，第i层有i个落点，每个落点有若干枚金币，在落点可以跳向左斜向下或向右斜向下的落点。</p>
<p>若知道金字塔的层数N及每层的金币数量分布，请计算小招在本次游戏中可以获得的最多金币数量。</p>
<p><strong>输入描述:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入共有N + 1行(N ≤ 1024)，第一行为高度N，第二行至N + 1行 ，为该金字塔的金币数量分布。</span><br></pre></td></tr></table></figure><br><strong>输出描述:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出金币数量。</span><br></pre></td></tr></table></figure></p>
<p>示例1:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">3 8</span><br><span class="line">8 1 0</span><br><span class="line">4 7 5 4</span><br><span class="line">3 5 2 6 5</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">31</span><br></pre></td></tr></table></figure></p>
<h3 id="题意概述"><a href="#题意概述" class="headerlink" title="题意概述"></a>题意概述</h3><p>相当于给定一个三角形，找出自顶向下的最大路径和。每一步只能移动到下一行中相邻的结点上。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>dp</p>
<p>  1、<strong>定义状态</strong>：dp[i][j] 表示从上到下到达 i, j 的最大路径和</p>
<p>  2、<strong>状态转移方程</strong></p>
<p>  <img src="/2020/04/29/2020%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8CFintech%E8%AE%AD%E7%BB%83%E8%90%A5%E7%A0%94%E5%8F%91%E8%B5%9B%E9%81%93%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/1.jpg" alt></p>
<p>到达[i,j]这个位置有两种方法：</p>
<ul>
<li><p>从[i-1,j]位置到达</p>
</li>
<li><p>从[i-1,j-1]位置到达</p>
</li>
</ul>
<p>例如：到达coins[3][2]，也就是5这个点，只能从coins[2][2],coins[2][1]这两个点</p>
<p>所以很容易写出<strong>状态转移方程</strong>：</p>
<script type="math/tex; mode=display">
dp[i][j]=max(dp[i-1][j], dp[i][j-1]) + coins[i][j];</script><p>对于首元素与尾元素分别只与一个元素相邻，所以要特殊处理</p>
<script type="math/tex; mode=display">
dp[i][0] = dp[i-1][0] + coins[i][0];</script><script type="math/tex; mode=display">
dp[i][i] = dp[i-1][i-1] + coins[i][i];</script><p>3、初始状态:<br>dp[0][0] = coins[0][0]</p>
<p>4、返回结果:<br>最后一行中最大的dp[i-1][j] (0&lt; j &lt; n)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>dp自顶向下，空间复杂度O(n^2)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (coins.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> coins[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 定义状态dp[i][j]表示从上到下到达 i, j 的最大路径和</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 初始状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = coins[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 首行与尾行分别只与一个元素相邻</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + coins[i][<span class="number">0</span>];</span><br><span class="line">            dp[i][i] = dp[i<span class="number">-1</span>][i<span class="number">-1</span>] + coins[i][i];<span class="function">s</span></span><br><span class="line"><span class="function">            <span class="title">for</span> <span class="params">(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + coins[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果为最后一行中最大的</span></span><br><span class="line">        res = dp[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[n<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">coins</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(i+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i+<span class="number">1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; temp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        coins[i]= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    res = <span class="built_in">test</span>(coins);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优化：dp时候每次只用到上一层数据,如果我们倒着,<strong>自底向上</strong>可以优化成O(n)空间的</p>
<p><img src="/2020/04/29/2020%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8CFintech%E8%AE%AD%E7%BB%83%E8%90%A5%E7%A0%94%E5%8F%91%E8%B5%9B%E9%81%93%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/2.jpg" alt></p>
<p>此时把行省略，dp设置成1维的，因为每个值只依赖当前值和它右侧的一个值（因为自顶向下是与当前值与当前值左边有关，自底向上反过来），这样从左到右遍历的时候，就可以覆盖上一次的值了，不会影响最后结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;coins)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = coins[n<span class="number">-1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移方程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i+<span class="number">1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j],dp[j+<span class="number">1</span>])+coins[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="交换座位"><a href="#交换座位" class="headerlink" title="交换座位"></a><a href="https://ac.nowcoder.com/acm/contest/5246/B">交换座位</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>在一场集体婚礼上，有n对新人需要坐在连续排列的 2n个座位上合影，同一对新人彼此挨着。由于进场时各对新人并未按序入座，请计算最少交换座位的次数，以便使每对新人均可并肩坐在一起。一次交换可选择任意两人，让他们互换座位。</p>
<p>全部新人的序号可用 0 到 2n-1 的整数表示，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。</p>
<p>row[i]指最初坐在第 i 个座位上的新人编号，i是从0到（2n-1）的一个升序全排列，row不存在重复值。</p>
<p><strong>输入描述:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入共有2行，第一行为n，即共有多少对新人(2≤n≤100000 )，第二行为row，即2n个座位上的初始新人编号。</span><br></pre></td></tr></table></figure><br><strong>输出描述:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出最少交换座位的次数。</span><br></pre></td></tr></table></figure></p>
<p>示例1:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">0 2 1 3</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">1</span><br></pre></td></tr></table></figure><br>说明：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们只需要交换1和2的位置即可</span><br></pre></td></tr></table></figure><br>示例2:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">3 2 0 1</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>说明：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无需交换座位，所有的新人都已经并肩坐在一起</span><br></pre></td></tr></table></figure></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>贪心法：</p>
<p>假设husband的编号为 x，那么wife的编号为 x ^ 1， ^ 在这里是异或操作。对于每张沙发上的第一个人 x = row[i]，找到他的同伴，idx = pos[wife]所在的位置 row[idx]，将 row[idx] 和 row[i + 1] 互相交换。pos为最初的位置映射。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSwapsCouples</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = row.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(n,<span class="number">-1</span>)</span></span>; <span class="comment">//pos[num]记录num在row中的下标</span></span><br><span class="line">        <span class="comment">// 第一步：记录各个元素出现的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pos[row[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二步：从左到右扫描整个row，并且进行配对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//根据row[i]的奇偶性确定这对情侣的另个人的数字，</span></span><br><span class="line">            <span class="comment">// 假设丈夫坐在偶数位，妻子坐在奇数位</span></span><br><span class="line">            <span class="type">int</span> wife = row[i]^<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (wife != row[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> idx = pos[wife];</span><br><span class="line">                <span class="built_in">swap</span>(row[i+<span class="number">1</span>],row[idx]);</span><br><span class="line">                <span class="comment">// 调换了位置之后，需要更新调换了的元素的下标</span></span><br><span class="line">                pos[row[idx]] = idx;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">2</span>*n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    res = <span class="built_in">test</span>(nums);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修塔游戏"><a href="#修塔游戏" class="headerlink" title="修塔游戏"></a><a href="https://ac.nowcoder.com/acm/contest/5246/B">修塔游戏</a></h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>小招正在玩一款修塔游戏：系统中有n座高塔，每座高塔由若干个高度相同的方块堆砌而成。修塔游戏的规则为：</p>
<p>（1）每次从最高塔的塔尖拿走一个方块</p>
<p>   （2）每次在最低塔的塔尖堆砌一个方块</p>
<p>   小招每次只能完成上述两个动作中的一个动作。游戏的目标是使n座高塔中至少有k座高塔的高度相同，请问小招最少需要多少次才能完成游戏。</p>
<p><strong>输入描述:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入共有2行，第一行为n和k(1≤k≤n≤200000 )，第二行为n座塔的高度组成的数组 a1, a2, ...an(1≤aj≤10000)。</span><br></pre></td></tr></table></figure><br><strong>输出描述:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出值为最少需要多少次动作才能完成游戏。</span><br></pre></td></tr></table></figure></p>
<p>示例1:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">6 5</span><br><span class="line">1 2 2 4 2 3</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>思路主要是：贪心的思想</p>
<p>遍历所有塔的高度作为基准高度，将数组排序，考虑只增高，先増后减，只减，先减后增的情况</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;heights,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = INT_MAX;</span><br><span class="line">    <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> sum=<span class="built_in">accumulate</span>(heights.<span class="built_in">begin</span>(),heights.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(heights.<span class="built_in">begin</span>(),heights.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> p=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最终的结果肯定是要有某个数出现的个数&gt;=k，把这个数叫做基准数</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        p=i;</span><br><span class="line">        <span class="keyword">while</span>(p&lt;n&amp;&amp;heights[p]==heights[i])</span><br><span class="line">        &#123;</span><br><span class="line">            sum-=heights[i];</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> need = <span class="built_in">max</span>(<span class="number">0</span>,k-p+i);</span><br><span class="line">        <span class="comment">//need的含义是目前如果让heights[i]作为基准数，还差多少个达到k，如果为0说明已经超过k个了，也就是说不需要任何操作就可以满足题意要求</span></span><br><span class="line">        <span class="keyword">if</span> (need==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p&gt;=k) <span class="comment">//p&gt;=k说明以heights[i]为基准数，调整下标i之前的数到达基准数，就可以满足题意，求出这时候需要操作个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res,i*heights[i]-pre-(i-need));<span class="comment">//pre记录的是下标i之前的所有数字之和，要把下标i之前的数调整到等于基准数heights[i]，操作次数=i*heights[i]-pre</span></span><br><span class="line">            <span class="comment">//同时要考虑只需要k个满足就可以了，也就是这时候可以有i-need不满足，也就是i-need个数可以调整等于heights[i]-1，所以要减去i-need.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n-i&gt;=k)<span class="comment">//i往后的数字降到heights[i]就直接可以满足题意，与p&gt;=k类似，只是调整方向不一样</span></span><br><span class="line">        &#123;</span><br><span class="line">            res=<span class="built_in">min</span>(res,sum-(n-p)*heights[i]-(n-p-need));<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">min</span>(res,i*heights[i]-pre+sum-(n-p)*heights[i]-(n-(p-i)-need));<span class="comment">//同时需要判断两边都做操作的情况下调整的个数</span></span><br><span class="line">        pre+=heights[i]*(p-i);<span class="comment">//pre加上heights[i]乘以heights[i]的个数，那么下一步i=p的时候pre就代表i之前所有数之和。</span></span><br><span class="line">        i=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n ,k;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">heights</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; heights[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">test</span>(heights,k);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>左旋转字符串</title>
    <url>/2020/04/10/58-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。<br><span id="more"></span></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h2><p>  方法一：直接法，定义一个左移一位函数leftmove，先定义一个<code>char temp = s[0];</code>。其余<code>s[i]==s[i+1];</code>，n-1位置最后一个字符替换为temp。左移几位就循环几次左移函数。</p>
<p>  方法二：利用reverse函数，原理：YX=(X<sup>T</sup> Y<sup>T</sup>)<sup>T</sup></p>
<p>  以”abcdefg“为例，我们可以把它分为两部分。由于想把它的前两个字.符移到后面，我们就把前两个字符分到第一部分， 把后面的所有字符分到第二部分。我们先分别翻转这两部分，于是就得到”bagfedc“。接下来翻转整个字符串，得到的”cdefgab“刚好就是把原始字符串左旋转两位的结果。</p>
<p>  方法三：取巧法，<code>s+=s;</code>，复制一遍字符串，从n开始处截取原字符串长度返回即可。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ol>
<li><p>O(kn) n为字符串长度，k旋转位数</p>
</li>
<li><p>O(n)</p>
</li>
<li><p>O(n)</p>
</li>
</ol>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><ol>
<li><p>O(1)</p>
</li>
<li><p>O(1)</p>
</li>
<li><p>O(n)</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一：直接左移-超时"><a href="#方法一：直接左移-超时" class="headerlink" title="方法一：直接左移(超时)"></a>方法一：直接左移(超时)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">leftMove</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">leftMove</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m  = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">char</span> temp = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i!=m<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s[i]=s[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：YX-XT-YT-T"><a href="#方法二：YX-XT-YT-T" class="headerlink" title="方法二：YX=(XT YT)^T"></a>方法二：YX=(X<sup>T</sup> Y<sup>T</sup>)^<sup>T</sup></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">begin</span>()+n); </span><br><span class="line">        <span class="comment">//reverse函数反转的范围是[first,last)</span></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+n,s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：s-s"><a href="#方法三：s-s" class="headerlink" title="方法三：s+=s"></a>方法三：s+=s</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        s+=s;</span><br><span class="line">        s = s.<span class="built_in">substr</span>(n,m);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>空间复杂度改善为O(1)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;n+m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=s[i%m];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中只出现一次的两个数字</title>
    <url>/2020/04/28/56-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p><strong>示例1：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><br>  <span id="more"></span></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h1><p>  方法一：次数问题第一时间就会想到哈希表，但是所需空间复杂度是O(n)</p>
<p>  方法二：异或 举例说明。</p>
<p>举例：{2,4,3,6,3,2,5,5}</p>
<p>这个数组中只出现一次的两个数分别是4和6。怎么找到这个两个数字呢？</p>
<p>我们先不看找到俩个的情况，先看这样一个问题，如何在一个数组中找到一个只出现一次的数字呢？比如数组：{4,5,5}，唯一一个只出现一次的数字是4。</p>
<p>我们知道异或的一个性质是：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字。比如数组{4,5,5}，我们先用数组中的第一个元素4（二进制形式：0100）和数组中的第二个元素5（二进制形式：0101）进行异或操作，0100和0101异或得到0001，用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作，0001和0101异或得到0100，正好是结果数字4。这是因为数组中相同的元素异或是为0的，因此就只剩下那个不成对的孤苦伶仃元素。</p>
<p>现在好了，我们已经知道了如何找到一个数组中找到一个只出现一次的数字，那么我们如何在一个数组中找到两个只出现一次的数字呢？如果，我们可以将原始数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现。这样，我们就可以用上述方法找到那个孤苦伶仃的元素。</p>
<p>我们还是从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于两个数字肯定不一样，那么异或的结果肯定不为0，也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。</p>
<p>举例：{2,4,3,6,3,2,5,5}</p>
<p>我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。</p>
<p><strong>trick:</strong></p>
<p> lowbit1 : 是二进制表达式中最低位的 1 所对应的值</p>
<p>  求负数的二进制的步骤：给定一个数，比如 12，我们能求得它的二进制 1100，如何求 −12的二进制？实际上二进制前面有个符号位，正数前面符号位是 0，负数前面符号位是 1，12 的二进制实际上是 01100，那么求 −12的二进制有两步：</p>
<ul>
<li>首先把符号位从 0 改成 1，然后对 12 每位取反。变成 10011</li>
<li>最后 +1，即 10011+1 = 10100，这就是 −12的二进制</li>
</ul>
<p>再细节点：那么给定一个数字 x，它的第 k 位为 1，0～k−1位都为 0，对它进行取反，也就是 0 变 1，1 变 0的操作，得到 ～x的二进制表示中，第 k位为 0 ，第 0 至第 k−1位都为 1。再将 ～x 进行加 1 操作，～x+1的第 k位变为 1，0～k−1位又都变为 000 了。实际上这就是我们求负数的过程，那么我们也就得到了一串 xxxxx10000这样的结果（xxxxx 是和正数对应的相反的），它再去和正数做与运算，我们就能得到 lowbit了。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  设x=8</span><br><span class="line">8的二进制位：0 0 0 0 1 0 0 0</span><br><span class="line">对8取反：1 1 1 1 0 1 1 1</span><br><span class="line">取反后加1: 1 1 1 1 1 0 0 0</span><br><span class="line"></span><br><span class="line">+8:0 0 0 0 1 0 0 0</span><br><span class="line">-8:1 1 1 1 1 0 0 0</span><br><span class="line">&amp;: 0 0 0 0 1 0 0 0 </span><br><span class="line"></span><br><span class="line">lowbit = 8 &amp; (-8) = 8</span><br></pre></td></tr></table></figure>
<h1 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h1><p>  方法一：O(N)</p>
<p>  方法二：O(N)</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度:"></a>空间复杂度:</h1><p>  方法一：O(n)</p>
<p>  方法二：O(1)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h1><p>1.哈希表<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num :  nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[num]==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>2.位运算异或<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span> <span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            number ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// lowbit1 : 是二进制表达式中最低位的 1 所对应的值</span></span><br><span class="line">        <span class="type">int</span> lowbit1 = number&amp;(-number);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; lowbit1) == lowbit1)</span><br><span class="line">            &#123;</span><br><span class="line">                res[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res[<span class="number">1</span>]^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>圆圈中最后剩下的数字</title>
    <url>/2020/03/30/62_%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>0,1，···n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<span id="more"></span>
<h2 id="本题考点："><a href="#本题考点：" class="headerlink" title="本题考点："></a>本题考点：</h2><p>  约瑟夫环问题</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h2><p>  1.) 模拟法</p>
<p>  用数组列表模拟一下。创建一个数组存储0-n-1的数组，但数组长度大于1时，就计算end位置即为(start+m-1)%len(nums) ，删除该元素后然后start再等于之前end，最后数组中剩最后一个元素，返回nums[0]</p>
<p>  时间复杂度O(n),空间复杂度O(n)</p>
<p>  2.) 数学方法：</p>
<p>  将上述问题建模为函数 f(n, m)，该函数的返回值为最终留下的元素的序号。</p>
<p>  每删除一个元素，下一个元素成为最开始的头，相当于把数组向前移动m位。若已知n-1个人时，删除下标位置位f(n−1,m)，则n个人的时候，就是往后移动m位，(因为有可能数组越界，超过的部分会被接到头上，所以还要模n)，既f(n,m) = (f(n-1,m) + m) % n</p>
<p>  递归公式为：$f(n, m)=(f(n-1, m)+m) \% n$</p>
<p>  时间复杂度O(n),空间复杂度O(n)</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="方法一：模拟法"><a href="#方法一：模拟法" class="headerlink" title="方法一：模拟法"></a>方法一：模拟法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> res =<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span> || m&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> start =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> end = (start+m<span class="number">-1</span>)%(nums.<span class="built_in">size</span>());</span><br><span class="line">            nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>()+end);  </span><br><span class="line">            <span class="comment">// vector插入删除操作时间复杂度是O(n)，可能会超时</span></span><br><span class="line">            start = end;</span><br><span class="line">        &#125;</span><br><span class="line">        res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二：数学法"><a href="#方法二：数学法" class="headerlink" title="方法二：数学法"></a>方法二：数学法</h4><p>迭代：空间复杂度O(1)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>递归：空间复杂度O(n)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(n,m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">f</span>(n<span class="number">-1</span>,m) + m) %n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/u011500062/article/details/72855826">约瑟夫环——公式法（递推公式）</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转单词顺序</title>
    <url>/2020/04/10/58-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p><strong>说明：</strong> </p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<span id="more"></span>
</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h2><p>方法一：</p>
<p>1) 翻转整个句子<br>2) 翻转句中单词<br>3) 删除多余的空格</p>
<p>方法二：字符流，用stringstream来做</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>  O(n)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>  O(1)</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(string &amp;s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[start++],s[end--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cleanSpaces</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) j++; <span class="comment">// 跳过空格</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;n &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>)s[i++] = s[j++]; </span><br><span class="line">            <span class="comment">// 保留单词（非空格部分）</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;n &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) j++; </span><br><span class="line">            <span class="comment">// 跳过空格（主要是防止结尾有空格，然后再添加空格越界）</span></span><br><span class="line">            <span class="keyword">if</span> (j&lt;n) s[i++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">// 补充空格</span></span><br><span class="line">        &#125;</span><br><span class="line">        s = s.<span class="built_in">substr</span>(<span class="number">0</span>,i); <span class="comment">// 改成引用减少一次拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//翻转整个语句</span></span><br><span class="line">        <span class="built_in">Reverse</span>(s,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 翻转句中单词</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n &amp;&amp; s[i]==<span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line">            start = end = i;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n &amp;&amp; s[i]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">Reverse</span>(s,start,end<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清除多余空格</span></span><br><span class="line">        s = <span class="built_in">cleanSpaces</span>(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：字符流"><a href="#方法二：字符流" class="headerlink" title="方法二：字符流"></a>方法二：字符流</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stringstream ss;</span><br><span class="line">        string ans=<span class="string">&quot;&quot;</span>,temp;</span><br><span class="line">        ss&lt;&lt;s;</span><br><span class="line">        <span class="keyword">while</span>(ss&gt;&gt;temp)&#123;</span><br><span class="line">            ans=<span class="string">&quot; &quot;</span>+temp+ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans!=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            ans.<span class="built_in">erase</span>(ans.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://segmentfault.com/a/1190000017271382">C++ 学习笔记之——字符串和字符串流</a></li>
<li><a href="https://blog.csdn.net/yyhaohaoxuexi/article/details/51416874">C++ string 类中substr的使用方法</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Struct位域Bit Field用法</title>
    <url>/2020/07/20/C-Struct%E4%BD%8D%E5%9F%9FBit-Field%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>最近在实习工作过程中，需要添加一个uint32位的字段，其中不同位表示不同的意义，使用一个uint32存储就更加轻便，这时就用到了位域这个概念，自己以前不太熟悉就参考网上资料整理总结一下。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>“ 位域 “ 或 “ 位段 “(Bit field)为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。这种数据结构的一个好处是它可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。第二个好处是位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。而这种数据结构的缺点在于，位段实现依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。</p>
<h3 id="位域声明"><a href="#位域声明" class="headerlink" title="位域声明"></a>位域声明</h3><p>位域使用以下的结构声明 , 该结构声明为每个位域成员设置名称，并决定其所占的bit数<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bit_field_name</span>  <span class="comment">// 位域结构名</span></span><br><span class="line">&#123;</span><br><span class="line">	type member_name : width;   <span class="comment">// type 位域成员的类型，必须为 int、signed int 或者 unsigned int 类型</span></span><br><span class="line">    <span class="comment">// width 规定成员所占的位数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><span id="more"></span><br>例如声明如下一个位域:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bs</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a: <span class="number">2</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> b: <span class="number">3</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> b: <span class="number">8</span>;</span><br><span class="line">&#125; test;</span><br></pre></td></tr></table></figure><br>该定义使 test包含 1 个 2 Bits 位域，1 个3 Bit 位域和 1 个 8 Bits 位域，我们可以使用结构体的成员运算符对其进行赋值<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">test.a = <span class="number">1</span>;</span><br><span class="line">test.b = <span class="number">2</span>;</span><br><span class="line">test.c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><br><strong>PS:</strong><br>位域的赋值不能超过该域所能表示的最大值，如b只有3位，能表示的最大数为7，若赋为8，就会出错  。</p>
<h3 id="位域的大小和对齐"><a href="#位域的大小和对齐" class="headerlink" title="位域的大小和对齐"></a>位域的大小和对齐</h3><h4 id="位域的大小"><a href="#位域的大小" class="headerlink" title="位域的大小"></a>位域的大小</h4><p>例如以下位域：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">box</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a: <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  : <span class="number">3</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> b: <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该位域结构体中间有一个未命名的位域，占据 3 Bits，仅起填充作用，并无实际意义。 填充使得该结构总共使用了 8 Bits。但 C 语言使用 unsigned int 作为位域的基本单位，即使一个结构的唯一成员为 1 Bit 的位域，该结构大小也和一个 unsigned int 大小相同。 有些系统中，unsigned int 为 16 Bits，在 x86 系统中为 32 Bits。文章以下均默认 unsigned int 为 32 Bits。</p>
<h4 id="位域的对齐"><a href="#位域的对齐" class="headerlink" title="位域的对齐"></a>位域的对齐</h4><p>一个位域成员不允许跨越两个 unsigned int 的边界，如果成员声明的总位数超过了一个 unsigned int 的大小， 那么编辑器会自动移位位域成员，使其按照 unsigned int 的边界对齐。</p>
<p>例如:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stuff</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> field1: <span class="number">30</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> field2: <span class="number">4</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> field3: <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>field1 + field2 = 34 Bits，超出 32 Bits, 编译器会将field2移位至下一个 unsigned int 单元存放， stuff.field1 和 stuff.field2 之间会留下一个 2 Bits 的空隙， stuff.field3 紧跟在 stuff.field2 之后，该结构大小为 2 * 32 = 64 Bits。</p>
<h3 id="位域的初始化和位的重映射"><a href="#位域的初始化和位的重映射" class="headerlink" title="位域的初始化和位的重映射"></a>位域的初始化和位的重映射</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>位域的初始化与普通结构体初始化的方法相同，这里列举两种，如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stuff</span> s1= &#123;<span class="number">20</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stuff</span> s1;</span><br><span class="line">s1.field1 = <span class="number">20</span>;</span><br><span class="line">s1.field2 = <span class="number">8</span>;</span><br><span class="line">s1.field3 = <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="位域的重映射-Re-mapping"><a href="#位域的重映射-Re-mapping" class="headerlink" title="位域的重映射 (Re-mapping)"></a>位域的重映射 (Re-mapping)</h4><p>声明一个 大小为 32 Bits 的位域<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">box</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ready:     <span class="number">2</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> error:     <span class="number">2</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> command:   <span class="number">4</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sector_no: <span class="number">24</span>;</span><br><span class="line">&#125;b1;</span><br></pre></td></tr></table></figure></p>
<h4 id="利用重映射将位域归零"><a href="#利用重映射将位域归零" class="headerlink" title="利用重映射将位域归零"></a>利用重映射将位域归零</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span> *) &amp;b1;  <span class="comment">// 将 &quot;位域结构体的地址&quot; 映射至 &quot;整形（int*) 的地址&quot; </span></span><br><span class="line">*p = <span class="number">0</span>;                <span class="comment">// 清除 s1，将各成员归零</span></span><br></pre></td></tr></table></figure>
<h4 id="利用联合-union-将-32-Bits-位域-重映射至-unsigned-int-型"><a href="#利用联合-union-将-32-Bits-位域-重映射至-unsigned-int-型" class="headerlink" title="利用联合 (union) 将 32 Bits 位域 重映射至 unsigned int 型"></a>利用联合 (union) 将 32 Bits 位域 重映射至 unsigned int 型</h4><p>联合简介：</p>
<p>“联合” 是一种特殊的类，也是一种构造类型的数据结构。在一个 “联合” 内可以定义多种不同的数据类型， 一个被说明为该 “联合” 类型的变量中，允许装入该 “联合” 所定义的任何一种数据，这些数据<strong>共享同一段内存</strong>，以达到节省空间的目的</p>
<p>“联合” 与 “结构” 有一些相似之处。但两者有本质上的不同。在结构中各成员有各自的内存空间， 一个结构变量的总长度是各成员长度之和（空结构除外，同时不考虑边界调整）。而在 “联合” 中，各成员<em>*共享一段内存空间</em>， 一个联合变量的长度等于各成员中最长的长度。应该说明的是， 这里所谓的共享不是指把多个成员同时装入一个联合变量内， 而是指该联合变量可被赋予任一成员值，但每次只能赋一种值， 赋入新值则冲去旧值。</p>
<p>我们可以声明以下联合:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;  </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> u_test;</span><br><span class="line">  <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> a: <span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>  : <span class="number">3</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> b: <span class="number">4</span>;</span><br><span class="line">    &#125; test;</span><br><span class="line">&#125; u;</span><br></pre></td></tr></table></figure>
<p>x86 系统中 unsigned int 和 box 都为 32 Bits, 通过该联合使 st_box 和 ui_box 共享一块内存。具体位域中哪一位与 unsigned int 哪一位相对应，取决于编译器和硬件。</p>
<p>利用联合将位域归零，代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">u.u_test = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">u.test.a = <span class="number">0</span>;</span><br><span class="line">u.test.b = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.yuan-ji.me/C-C-%E4%BD%8D%E5%9F%9F-Bit-fields-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/">C++ Bit Fields</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ std::move用法</title>
    <url>/2020/08/28/C-std-move%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>std::move函数可以以非常简单的方式将左值引用转换为右值引用.</p>
<ol>
<li><p>C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。</p>
</li>
<li><p>std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.</p>
<span id="more"></span>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4></li>
</ol>
<p>原lvalue值被moved from之后值被转移,所以为空字符串. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line">    <span class="comment">//调用常规的拷贝构造函数，新建字符数组，拷贝数据</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(str);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After copy, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">//调用移动构造函数，掏空str，掏空后，最好不要使用str</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After move, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The contents of the vector are \&quot;&quot;</span> &lt;&lt; v[<span class="number">0</span>]</span><br><span class="line">              &lt;&lt; <span class="string">&quot;\&quot;, \&quot;&quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">After copy, str is &quot;Hello&quot;</span><br><span class="line">After move, str is &quot;&quot;</span><br><span class="line">The contents of the vector are &quot;Hello&quot;, &quot;Hello&quot; </span><br></pre></td></tr></table></figure></p>
<h4 id="std-move-的函数原型定义"><a href="#std-move-的函数原型定义" class="headerlink" title="std::move 的函数原型定义"></a>std::move 的函数原型定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br></pre></td></tr></table></figure>
<h4 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h4><p><a href="https://blog.csdn.net/p942005405/article/details/84644069">https://blog.csdn.net/p942005405/article/details/84644069</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ bitset用法总结</title>
    <url>/2020/05/04/C-bitset%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><p>bitset是STL提供的用于记录01串的容器，也就是bitset的每个元素只能为0/1</p>
<p>bitset主要是用于存储二进制位，在需要大量二进制计算的项目中，直接使用bitset比利用数组或者其它方式要更为方便，位运算在存储状态、模拟行动、搜索很多方面有非常巨大的优势。<br><span id="more"></span></p>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bitset&lt;16&gt; first;  <span class="comment">//构造一个16位的bitset对象，初始值默认为0</span></span><br><span class="line"><span class="function">bitset&lt;16&gt; <span class="title">second</span><span class="params">(<span class="number">177</span>)</span></span>;  <span class="comment">//构造一个16位的bitset对象，将177转换为二进制，拷贝到内存空间</span></span><br><span class="line"><span class="function">bitset&lt;16&gt; <span class="title">secont_m</span><span class="params">(Oxff20)</span></span>;  <span class="comment">//整型常量，可以直接十进制，也可以八进制，十六进制</span></span><br><span class="line"><span class="function">bitset&lt;16&gt; <span class="title">third</span><span class="params">(<span class="string">&quot;1110011&quot;</span>)</span></span>;  <span class="comment">//将二进制字符串初始化到对象中</span></span><br><span class="line"><span class="function">bitset&lt;6&gt; <span class="title">second_t</span><span class="params">(<span class="number">177</span>)</span></span>;</span><br><span class="line"><span class="function">bitset&lt;6&gt; <span class="title">third_t</span><span class="params">(<span class="string">&quot;1110011&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; second &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; third &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="type">second_t</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="type">third_t</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; second[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0000000000000000</span></span><br><span class="line"><span class="comment">0000000010110001</span></span><br><span class="line"><span class="comment">0000000001110011</span></span><br><span class="line"><span class="comment">110001</span></span><br><span class="line"><span class="comment">111001</span></span><br><span class="line"><span class="comment">1000110100000000</span></span><br><span class="line"><span class="comment">//由于bitset重载输出定向符号，为了便于查看，这里输出是逆向输出，长度为n的bitset，是按照n-1——&gt;0的顺输出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>注意bitset声明后长度不可改变，和数组一样，bitset从0开始编号</p>
</li>
<li><p>如果bitset空间比二进制位数大，则在高位补0，(虽然上面输出是左边为0，但左边是高位，也即其索引分别是15~0)</p>
</li>
<li>在将整形常量转换为二进制过后，如果bitset位数不够，则自动放弃原数值高位的二进制位。</li>
</ul>
<h3 id="bitset的操作"><a href="#bitset的操作" class="headerlink" title="bitset的操作"></a>bitset的操作</h3><p>以下是bitset常用操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">size</span>() <span class="comment">// a的位数</span></span><br><span class="line">a.<span class="built_in">any</span>()  <span class="comment">//a中是否含1</span></span><br><span class="line">a.<span class="built_in">none</span>()  <span class="comment">//a是否全为0</span></span><br><span class="line">a.<span class="built_in">all</span>() <span class="comment">// a是否全为1</span></span><br><span class="line">a.<span class="built_in">count</span>()  <span class="comment">//a中有几个1</span></span><br><span class="line">a.[pos]  <span class="comment">//访问第pos位</span></span><br><span class="line">a.<span class="built_in">test</span>(pos)  <span class="comment">//第pos位是否为1</span></span><br><span class="line">a.<span class="built_in">set</span>()  <span class="comment">//全部设为1</span></span><br><span class="line">a.<span class="built_in">reset</span>()  <span class="comment">//全部清零</span></span><br><span class="line">a.<span class="built_in">flip</span>()  <span class="comment">//全部取反</span></span><br><span class="line">a.<span class="built_in">to_ulong</span>()  <span class="comment">//转成32位无符号整数</span></span><br><span class="line">a.<span class="built_in">to_ullong</span>() <span class="comment">// 转换为64位无符号整数，如果超出范围则报错</span></span><br><span class="line">a.<span class="built_in">to_string</span>() <span class="comment">// 转换为string</span></span><br></pre></td></tr></table></figure><br>或者也可以对bitset使用位操作（返回一个bitset）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a|b</span><br><span class="line">a&amp;b</span><br><span class="line">a^b</span><br><span class="line">~a</span><br><span class="line">a&lt;&lt;<span class="number">1</span></span><br><span class="line">a&gt;&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="bitset的原理"><a href="#bitset的原理" class="headerlink" title="bitset的原理"></a>bitset的原理</h3><p>bitset的原理与高精度压位类似即：</p>
<p>将一个很长的01串按64位一组划分每组01串用一个64位无符号整数记录</p>
<p>bitset所有的操作都是基于对整数的位操作实现的。<br>所以bitset的效率非常高，可以看作O(N/64)</p>
<h3 id="bitset应用"><a href="#bitset应用" class="headerlink" title="bitset应用"></a>bitset应用</h3><p>可以方便利用bitset实现十进制到二进制的互相转换。</p>
<p>二进制转成十进制<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitset&lt;16&gt; a; <span class="comment">// 16 bit 二进制数据，还有 bitset&lt;32&gt;</span></span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">to_ulong</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>十进制转成二进制<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; b;</span><br><span class="line">    <span class="function">bitset&lt;16&gt; <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">// 16 bit 二进制数据，还有 bitset&lt;32&gt;</span></span><br><span class="line">    cout &lt;&lt; a&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ vector拷贝使用总结</title>
    <url>/2020/04/02/C-vector%E6%8B%B7%E8%B4%9D%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>一些vector拷贝使用的细节，挖过填过的坑，记录一下。</p>
<p>主要有以下几种方法</p>
<h3 id="初始化构造时拷贝（深复制）"><a href="#初始化构造时拷贝（深复制）" class="headerlink" title="初始化构造时拷贝（深复制）"></a>初始化构造时拷贝（深复制）</h3><p>这种拷贝，相当于复制了一份数据，array中的数据不变。 如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; array&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">outArray</span><span class="params">(array)</span></span>;</span><br></pre></td></tr></table></figure><br><span id="more"></span></p>
<h3 id="利用拷贝赋值操作符（深复制）"><a href="#利用拷贝赋值操作符（深复制）" class="headerlink" title="利用拷贝赋值操作符（深复制）"></a>利用拷贝赋值操作符（深复制）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; array&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; outArray;</span><br><span class="line">outArray = array;</span><br></pre></td></tr></table></figure>
<h3 id="利用assign-函数（清空并深复制）"><a href="#利用assign-函数（清空并深复制）" class="headerlink" title="利用assign()函数（清空并深复制）"></a>利用assign()函数（清空并深复制）</h3><p>一样的复制了一份数据，array中的数据不变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; array&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; outArray&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">outArray.<span class="built_in">assign</span>(array.<span class="built_in">begin</span>(),array.<span class="built_in">end</span>());<span class="comment">//清空原数据，赋予新数据=&#123;3,5,2,6,4&#125;</span></span><br><span class="line">outArray.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="number">0</span>);<span class="comment">//5个0，清空原数据=&#123;0,0,0,0,0,&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="利用swap-函数（交换两个vector）"><a href="#利用swap-函数（交换两个vector）" class="headerlink" title="利用swap()函数（交换两个vector）"></a>利用swap()函数（交换两个vector）</h3><p>会清空原vector数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; array&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; outArray;<span class="comment">//设为空</span></span><br><span class="line">outArray.<span class="built_in">swap</span>(array);<span class="comment">//清空array数组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; array&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; outArray&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">outArray.<span class="built_in">swap</span>(array);<span class="comment">//outArray=&#123;3,5,2,6,4&#125;；array=&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ string.find函数用法</title>
    <url>/2020/05/20/C-string-find%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>整理一些find函数的用法，方便以后使用查看。</p>
<p>1.string中find()返回值是字母在母串中的位置（下标记录），如果没有找到，那么会返回一个特别的标记npos。（返回值可以看成是一个int型的数）<br><span id="more"></span><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">////find函数返回类型 size_type</span></span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;1a2b3c4d5e6f7jkg8h9i1a2b3c4d5e6f7g8ha9i&quot;</span>)</span></span>;</span><br><span class="line">    string flag;</span><br><span class="line">    <span class="type">int</span> position;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//find 函数 返回jk 在s 中的下标位置 </span></span><br><span class="line">    position = s.<span class="built_in">find</span>(<span class="string">&quot;jk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(position !=s.npos)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;postion is: &quot;</span>  &lt;&lt; position &lt;&lt; endl; <span class="comment">//如果没找到，返回一个特别的标志c++中用npos表示，int类型的话，没找到时我这里position=-1，</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Not found the flag&quot;</span> + flag &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.返回子串出现在母串中的首次出现的位置，和最后一次出现的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">flag = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">position = s.<span class="built_in">find_first_of</span>(flag);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s.find_first_of(flag) is : &quot;</span> &lt;&lt; position &lt;&lt; endl;</span><br><span class="line"><span class="comment">// s.find_first_of(flag) is : 5</span></span><br><span class="line"></span><br><span class="line">position = s.<span class="built_in">find_last_of</span>(flag);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s.find_last_of(flag) is : &quot;</span> &lt;&lt; position &lt;&lt; endl;</span><br><span class="line"><span class="comment">//  s.find_last_of(flag) is : 25</span></span><br></pre></td></tr></table></figure>
<p>3.查找某一给定位置后的子串的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从字符串s 下标5开始，查找字符串b ,返回b 在s 中的下标</span></span><br><span class="line">position=s.<span class="built_in">find</span>(<span class="string">&quot;b&quot;</span>,<span class="number">5</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s.find(b,5) is : &quot;</span>&lt;&lt;position&lt;&lt;endl;</span><br><span class="line"><span class="comment">// s.find(b,5) is : 23</span></span><br></pre></td></tr></table></figure>
<p>4.查找所有子串在母串中出现的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找s 中flag 出现的所有位置。</span></span><br><span class="line">    flag=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">    position=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((position=s.<span class="built_in">find</span>(flag,position))!=s.npos)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;position  &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;position&lt;&lt;endl;</span><br><span class="line">        position++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">position  1 : 1</span></span><br><span class="line"><span class="comment">position  2 : 21</span></span><br><span class="line"><span class="comment">position  3 : 36</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>5.反向查找子串在母串中出现的位置，通常我们可以这样来使用，当正向查找与反向查找得到的位置不相同说明子串不唯一。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反向查找，flag 在s 中最后出现的位置</span></span><br><span class="line">    flag=<span class="string">&quot;3&quot;</span>;</span><br><span class="line">    position=s.<span class="built_in">rfind</span> (flag);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s.rfind (flag) :&quot;</span> &lt;&lt; position &lt;&lt; endl;</span><br><span class="line"><span class="comment">// s.rfind (flag) :24</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中explicit关键字的作用</title>
    <url>/2020/05/27/C-%E4%B8%ADexplicit%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>C++ thread用法总结</title>
    <url>/2020/04/04/C-thread%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>C++11中加入了<thread>头文件，此头文件主要声明了std::thread线程类。C++11的标准类std::thread对线程进行了封装，定义了C++11标准中的一些表示线程的类、用于互斥访问的类与方法等。应用C++11中的std::thread便于多线程程序的移值。<br><span id="more"></span><br>std::thread类成员函数：</thread></p>
<p>(1)、get_id：获取线程ID，返回一个类型为std::thread::id的对象。</p>
<p>(2)、joinable：检查线程是否可被join。检查thread对象是否标识一个活动(active)的可行性线程。缺省构造的thread对象、已经完成join的thread对象、已经detach的thread对象都不是joinable。</p>
<p>(3)、join：调用该函数会阻塞当前线程。阻塞调用者(caller)所在的线程直至被join的std::thread对象标识的线程执行结束。</p>
<p>(4)、detach：将当前线程对象所代表的执行实例与该线程对象分离，使得线程的执行可以单独进行。一旦线程执行完毕，它所分配的资源将会被释放。</p>
<p>(5)、native_handle：该函数返回与std::thread具体实现相关的线程句柄。native_handle_type是连接thread类和操作系统SDK API之间的桥梁，如在Linux g++(libstdc++)里，native_handle_type其实就是pthread里面的pthread_t类型，当thread类的功能不能满足我们的要求的时候(比如改变某个线程的优先级)，可以通过thread类实例的native_handle()返回值作为参数来调用相关的pthread函数达到目录。This member function is only present in class thread if the library implementation supports it. If present, it returns a value used to access implementation-specific information associated to the thread.</p>
<p>(6)、swap：交换两个线程对象所代表的底层句柄。</p>
<p>(7)、operator=：moves the thread object</p>
<p>(8)、hardware_concurrency：静态成员函数，返回当前计算机最大的硬件并发线程数目。基本上可以视为处理器的核心数目。</p>
<p>另外，std::thread::id表示线程ID，定义了在运行时操作系统内唯一能够标识该线程的标识符，同时其值还能指示所标识的线程的状态。Values of this type are returned by thread::get_id and this_thread::get_id to identify threads.</p>
<p>有时候我们需要在线程执行代码里面对当前调用者线程进行操作，针对这种情况，C++11里面专门定义了一个命名空间this_thread，此命名空间也声明在<thread>头文件中，其中包括get_id()函数用来获取当前调用者线程的ID；yield()函数可以用来将调用者线程跳出运行状态，重新交给操作系统进行调度，即当前线程放弃执行，操作系统调度另一线程继续执行；sleep_until()函数是将线程休眠至某个指定的时刻(time point),该线程才被重新唤醒；sleep_for()函数是将线程休眠某个指定的时间片(time span)，该线程才被重新唤醒，不过由于线程调度等原因，实际休眠实际可能比sleep_duration所表示的时间片更长。</thread></p>
<h3 id="1-创建一个线程"><a href="#1-创建一个线程" class="headerlink" title="1.创建一个线程"></a>1.创建一个线程</h3><p>创建线程比较简单，使用std的thread实例化一个线程对象就创建完成了，示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//sleep</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">t1</span><span class="params">()</span>  <span class="comment">//普通的函数，用来执行线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;t1111\n&quot;</span>;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">t2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;t22222\n&quot;</span>;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(t1)</span></span>;  <span class="comment">//实例化一个线程对象th1，使用函数t1构造，然后该线程就开始执行了（t1()）</span></span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(t2)</span></span>;</span><br><span class="line"> </span><br><span class="line">    th1.<span class="built_in">join</span>(); <span class="comment">// 必须将线程join或者detach 等待子线程结束主进程才可以退出</span></span><br><span class="line">    th2.<span class="built_in">join</span>(); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//or use detach</span></span><br><span class="line">    <span class="comment">//th1.detach();</span></span><br><span class="line">    <span class="comment">//th2.detach();</span></span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;here is main\n\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述提到的问题，还可以使用detach来解决，detach是用来和线程对象分离的，这样线程可以独立地执行，不过这样由于没有thread对象指向该线程而失去了对它的控制，当对象析构时线程会继续在后台执行，但是当主程序退出时并不能保证线程能执行完。如果没有良好的控制机制或者这种后台线程比较重要，最好不用detach而应该使用join。</p>
<h3 id="2-mutex和std-lock-guard的使用"><a href="#2-mutex和std-lock-guard的使用" class="headerlink" title="2. mutex和std::lock_guard的使用"></a>2. mutex和std::lock_guard的使用</h3><p>头文件是#include <mutex>，mutex是用来保证线程同步的，防止不同的线程同时操作同一个共享数据。</mutex></p>
<p>但使用lock_guard则相对安全，它是基于作用域的，能够自解锁，当该对象创建时，它会像m.lock()一样获得互斥锁，当生命周期结束时，它会自动析构(unlock)，不会因为某个线程异常退出而影响其他线程。示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> cnt = <span class="number">20</span>;</span><br><span class="line">std::mutex m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">t1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockGuard</span><span class="params">(m)</span></span>;</span><br><span class="line">       <span class="comment">// std::m.lock();</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//sleep(1);</span></span><br><span class="line">            --cnt;</span><br><span class="line">            std::cout &lt;&lt; cnt &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// std::m.unlock();</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">t2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockGuard</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="comment">// std::m.lock();</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">            std::cout &lt;&lt; cnt &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// std::m.unlock();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">th1</span><span class="params">(t1)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">th2</span><span class="params">(t2)</span></span>;</span><br><span class="line"> </span><br><span class="line">	th1.<span class="built_in">join</span>();    <span class="comment">//等待t1退出</span></span><br><span class="line">	th2.<span class="built_in">join</span>();    <span class="comment">//等待t2退出</span></span><br><span class="line"> </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;here is the main()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果，cnt是依次递减的，没有因为多线程而打乱次序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="function">here is the <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中static和const的使用</title>
    <url>/2020/06/21/C-%E4%B8%ADstatic%E5%92%8Cconst%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul>
<li>作用域隐藏。当一个工程有多个文件的时候，用static修饰的函数或变量只能够在本文件中可见，文件外不可见。</li>
<li>全局生命周期。用static修饰的变量或函数生命周期是全局的。被static修饰的变量存储在静态数据区。</li>
<li>static修饰的变量默认初始化为0。(初始化会存在data段，未初始化是在bss段)</li>
<li>在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的静态成员变量。<span id="more"></span>
</li>
</ul>
<p>1、修饰普通变量：修改变量的存储区域和生命周期，使变量存储在静态区，在main函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</p>
<p>2、修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为static。</p>
<p>3、修饰成员变量，属于整个类所拥有，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见。静态成员变量是静态存储的，所以必须对它进行初始化</p>
<p>4、修饰成员函数，属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</p>
<h3 id="static成员函数不能为virtual："><a href="#static成员函数不能为virtual：" class="headerlink" title="static成员函数不能为virtual："></a>static成员函数不能为virtual：</h3><p>1.static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。</p>
<p>2.静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。</p>
<p>   虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.</p>
<p>   对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual.</p>
<p>   <strong>虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function</strong></p>
<p>通过下面例子可以确定，当类增加了一个虚函数后，类的大小会增大4字节(指针的大小).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="type">int</span> _m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(Test) = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入虚函数后</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="type">int</span> _m;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(Test) = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="static成员函数不能为const函数"><a href="#static成员函数不能为const函数" class="headerlink" title="static成员函数不能为const函数"></a>static成员函数不能为const函数</h3><p>C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的中参数的值，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。</p>
<p>volatile的道理也是如此。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>1、修饰变量，说明该变量不可以被改变；</p>
<p>2、修饰指针，有以下三种情况：</p>
<ul>
<li>A: const 修饰指针指向的内容，则内容为不可变量。</li>
<li>B: const 修饰指针，则指针为不可变量。</li>
<li>C: const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。</li>
</ul>
<p>对于 A:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><br>则指针指向的内容 8 不可改变。简称左定值，因为 const 位于 * 号的左边。</p>
<p>对于B：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;a;</span><br><span class="line">*p = <span class="number">9</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="type">int</span>  b = <span class="number">7</span>;</span><br><span class="line">p = &amp;b; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><br>对于 const 指针 p 其指向的内存地址不能够被改变，但其内容可以改变。简称，右定向。因为 const 位于 * 号的右边。</p>
<p>对于C：则是 A 和 B的合并<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span>  p = &amp;a;</span><br></pre></td></tr></table></figure></p>
<p>这时，const p 的指向的内容和指向的内存地址都已固定，不可改变。</p>
<p>对于 A，B，C 三种情况，根据 const 位于 <em> 号的位置不同，总结三句话便于记忆的话：<em>*”左定值，右定向，const修饰不变量”</em></em>。</p>
<p>3、常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</p>
<p>4、修饰成员函数，说明该成员函数内不能修改成员变量，如果要修改可以使用mutable关键字修饰这个成员变量。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> _m,<span class="type">int</span> <span class="type">_t</span>):_cm(_m),_ct(<span class="type">_t</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Kf</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++_cm; <span class="comment">// 错误</span></span><br><span class="line">        ++_ct; <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _cm;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> _ct;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">8</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="const和define的区别"><a href="#const和define的区别" class="headerlink" title="const和define的区别"></a>const和define的区别</h3><p><strong>类型和安全检查不同</strong></p>
<p>宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；</p>
<p>const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查</p>
<p><strong>编译器处理阶段不同</strong></p>
<p>宏定义是一个”编译时”概念，在预处理阶段展开；</p>
<p>const常量是一个”运行时”概念，在程序运行使用，类似于一个只读行数据</p>
<p><strong>存储方式不同</strong></p>
<p>宏定义是直接替换，不会分配内存，存储于程序的代码段中；我理解的是给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大；</p>
<p>const常量需要进行内存分配，存储于程序的数据段中，编译期最初将其保存在符号表中，第一次使用时为其分配内存，在程序结束时释放；const局部变量存储在栈中，代码块结束时释放</p>
<p><strong>定义域不同</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> N 12</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;N &lt;&lt;endl; <span class="comment">//正确，N已经定义过，不受定义域限制</span></span><br><span class="line">    cout&lt;&lt;n &lt;&lt;endl; <span class="comment">//错误，n定义域只在f1函数中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>定义后能否取消</strong><br>宏定义可以通过#undef来使之前的宏定义失效</p>
<p>const常量定义后将在定义域内永久有效<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> N 12</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> n = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> N <span class="comment">//取消宏定义后，即使在f1函数中，N也无效了</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> N 21<span class="comment">//取消后可以重新定义</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>是否可以做函数参数</strong></p>
<p>宏定义不能作为参数传递给函数</p>
<p>const常量可以在函数的参数列表中出现</p>
<h2 id="static和const联合使用"><a href="#static和const联合使用" class="headerlink" title="static和const联合使用"></a>static和const联合使用</h2><p>static与const作用:声明一个只读的静态变量</p>
<p>static const,既是只读的,又是只在当前模块中可见的</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.runoob.com/w3cnote/cpp-const-keyword.html">https://www.runoob.com/w3cnote/cpp-const-keyword.html</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++“字母数字”判断相关的函数</title>
    <url>/2020/06/25/C-%E2%80%9D%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E2%80%9D%E5%88%A4%E6%96%AD%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>LeetCode中做题遇到一个，需要解决数字、小写字母、大写字母的问题，可以用C++内置的函数，整理一下，做一下记录：</p>
<ol>
<li>islower(char c) 是否为小写字母</li>
<li>isupper(char c) 是否为大写字母</li>
<li>isdigit(char c) 是否为数字</li>
<li>isalpha(char c) 是否为字母</li>
<li>isalnum(char c) 是否为字母或者数字</li>
<li>toupper(char c) 字母小转大</li>
<li>tolower(char c) 字母大转小</li>
</ol>
<span id="more"></span>
<h3 id="题目描述-验证回文串"><a href="#题目描述-验证回文串" class="headerlink" title="题目描述:  验证回文串"></a>题目描述:  验证回文串</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><br><strong>示例 2:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p>
<h3 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">islower</span>(c) || <span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                tmp += c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isupper</span>(c)) &#123;</span><br><span class="line">                tmp += (c+<span class="number">32</span>);  <span class="comment">// tmp += tolower(c);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = tmp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i]!=tmp[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/25/C-%E2%80%9D%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E2%80%9D%E5%88%A4%E6%96%AD%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0/1.jpg" alt></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的绝对值函数：abs()、cabs()、fabs()、labs()</title>
    <url>/2020/08/22/C-%E4%B8%AD%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%9Aabs-%E3%80%81cabs-%E3%80%81fabs-%E3%80%81labs/</url>
    <content><![CDATA[<p>不同类型的数据使用不同类型的绝对值函数：</p>
<p>整型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> i)</span>  <span class="comment">//返回整型参数i的绝对值 </span></span></span><br></pre></td></tr></table></figure>
<p>双精度浮点型：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">fabs</span><span class="params">(<span class="type">double</span> x)</span>  <span class="comment">//返回双精度参数x的绝对值    </span></span></span><br></pre></td></tr></table></figure></p>
<p>长整型：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">labs</span><span class="params">(<span class="type">long</span> n)</span>  <span class="comment">//返回长整型参数n的绝对值 </span></span></span><br></pre></td></tr></table></figure></p>
<p>复数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cabs</span><span class="params">(<span class="keyword">struct</span> complex znum)</span>  <span class="comment">//返回复数znum的绝对值  </span></span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++函数返回局部变量的问题</title>
    <url>/2020/04/08/C-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="常见栈内变量"><a href="#常见栈内变量" class="headerlink" title="常见栈内变量"></a>常见栈内变量</h3><p>一般来说，在函数内对于存在栈上的局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放。因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错；但是如果返回的是局部变量的地址（指针）的话，就造成了野指针，程序运行会出错，因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。<br><span id="more"></span><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// OK.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>* ip = &amp;i;</span><br><span class="line">    <span class="keyword">return</span> ip; <span class="comment">// Wrong!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r1 = <span class="built_in">fun1</span>();</span><br><span class="line">    cout &lt;&lt; r1 &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    <span class="type">int</span>* r2 = <span class="built_in">fun2</span>();</span><br><span class="line">    cout &lt;&lt; *r2 &lt;&lt; endl; </span><br><span class="line">    <span class="comment">// 这里有可能可以打印出结果：2，看似正确的，但其实是有问题的。</span></span><br><span class="line">    <span class="comment">//这是因为相应的内存还未被覆盖，但这块内存已经是自由的、不被保护的了。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// OK.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">fun4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// Wrong!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* r3 = <span class="built_in">fun3</span>();</span><br><span class="line">    cout &lt;&lt; r3 &lt;&lt; endl; <span class="comment">// Hello</span></span><br><span class="line">    <span class="type">char</span>* r4 = <span class="built_in">fun4</span>();</span><br><span class="line">    cout &lt;&lt; r4 &lt;&lt; endl; <span class="comment">// 内存已经无效的了。打印出乱码。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>如果函数的返回值非要是一个局部变量地址，可以把局部变量声明为static静态变量。这样变量存储在静态存储区，程序运行过程中一直存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">fun5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;i; <span class="comment">// OK.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">fun6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> s[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// OK.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* r5 = <span class="built_in">fun5</span>();</span><br><span class="line">    cout &lt;&lt; *r5 &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">    <span class="type">char</span>* r6 = <span class="built_in">fun6</span>();</span><br><span class="line">    cout &lt;&lt; r6 &lt;&lt; endl; <span class="comment">// Hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是不能作为函数的返回值的。因为编译器会把数组名认为是局部变量（数组）的地址。返回一个数组，实际上是返回指向这个数组首地址的指针。函数结束后，数组作为局部变量被释放，这个指针则变成了野指针。同1的fun2()及2的fun4()（字符数组）。但是声明数组是静态的，然后返回是可以的.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">fun7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> a; <span class="comment">// Wrong!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">fun8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> a; <span class="comment">// OK.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* r7 = <span class="built_in">fun7</span>();</span><br><span class="line">    cout &lt;&lt; *r7 &lt;&lt; endl; <span class="comment">// 内存已经是无效的了。</span></span><br><span class="line">    <span class="type">int</span>* r8 = <span class="built_in">fun8</span>();</span><br><span class="line">    cout &lt;&lt; *r8 &lt;&lt;endl; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆内变量"><a href="#堆内变量" class="headerlink" title="堆内变量"></a>堆内变量</h3><p>函数返回指向存储在堆上的变量的指针是可以的。但是，程序员要自己负责在函数外释放（free/delete）分配（malloc/new）在堆上的内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">fun9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* s = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// OK. 但需要程序员自己释放内存。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* r9 = <span class="literal">NULL</span>;</span><br><span class="line">    r9 = <span class="built_in">fun9</span>();</span><br><span class="line">    <span class="built_in">strcpy</span>(r9, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    cout &lt;&lt; r9 &lt;&lt; endl; <span class="comment">// Hello</span></span><br><span class="line">    <span class="built_in">free</span>(r9); <span class="comment">// 要记得自己释放内存。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++内存管理</title>
    <url>/2020/04/16/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。
　　</p>
<ul>
<li><strong>栈：</strong>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li><strong>堆：</strong>是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。。</li>
<li><strong>自由存储区：</strong>是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。</li>
<li><strong>全局/静态存储区：</strong>全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</li>
<li><p><strong>常量存储区：</strong>这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p>
<span id="more"></span>
<p>PS：</p>
<p>  自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>
</li>
</ul>
<h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><p>栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>如下代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b;				<span class="comment">//栈</span></span><br><span class="line">	<span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>; 	<span class="comment">//栈</span></span><br><span class="line">	<span class="type">char</span> *p2;			<span class="comment">//栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式类似于链表。<br>如下代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// C 中用 malloc() 函数申请</span></span><br><span class="line">	<span class="type">char</span>* p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">	cout&lt;&lt;(<span class="type">int</span>*)p1&lt;&lt;endl;		<span class="comment">//输出：00000000003BA0C0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用 free() 函数释放</span></span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">   </span><br><span class="line">	<span class="comment">// C++ 中用 new 运算符申请</span></span><br><span class="line">	<span class="type">char</span>* p2 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>*)p2 &lt;&lt; endl;		<span class="comment">//输出：00000000003BA0C0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用 delete 运算符释放</span></span><br><span class="line">	<span class="keyword">delete</span>[] p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>堆和栈的具体区别：</p>
<p>（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏。</p>
<p>（2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，<br>进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</p>
<p>（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。</p>
<p>（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。<br>静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，<br>但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。</p>
<p>（5）分配效率不同。堆的效率比栈要低得多</p>
<p>（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。而堆中具体存放内容是由程序员来填充的。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 分割字符串套路</title>
    <url>/2020/05/24/C-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<p>做题时经常会遇到字符串分割（类似python的split函数）。C++并没有提供关于这个函数的功能，所以要自己实现，现整理一些套路，以后直接套用。</p>
<ol>
<li><p>直接暴力分割<br>比如分割字符串s=”hello world hello C++”，要按照空格分割出单词，可以直接暴力模拟</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello world hello c++&quot;</span>;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">const</span> <span class="type">char</span> pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="type">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i]== <span class="string">&#x27; &#x27;</span>)  <span class="comment">// 如果以逗号分割，改为&#x27;,&#x27;即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意最后一个单词</span></span><br><span class="line">    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用stringstream进行字符串分割<br>stringstream为字符串输入输出流，继承自iostream，灵活地使用stringstream流可以完成很多字符串处理功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">const</span> <span class="type">char</span> pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;   <span class="comment">//读取str到字符串流中</span></span><br><span class="line">    string temp;</span><br><span class="line">    <span class="comment">//使用getline函数从字符串流中读取,遇到分隔符时停止,和从cin中读取类似，注意,getline默认是可以读取空格的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以空格分割可以这样写</span></span><br><span class="line">    <span class="keyword">while</span>(ss &gt;&gt; temp)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以逗号分割</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(input, temp, <span class="string">&#x27;,&#x27;</span>)) <span class="comment">// pattern为分割标示符</span></span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>利用find和substr这两个函数来实现<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">const</span> string &amp;pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//在字符串末尾也加入分隔符，方便截取最后一段</span></span><br><span class="line">    <span class="comment">// 如果pattern为&quot; &quot; 为空格分割，&quot;,&quot;为逗号分割</span></span><br><span class="line">    string strs = str + pattern;</span><br><span class="line">    <span class="type">int</span> pos = strs.<span class="built_in">find</span>(pattern); <span class="comment">// find返回分割符的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pos != strs.npos) </span><br><span class="line">    <span class="comment">// npos可以表示string的结束位置，是string::type_size类型的，也就是find（）返回的类型。find函数在找不到指定值得情况下会返回string::npos</span></span><br><span class="line">    &#123;</span><br><span class="line">        string temp = strs.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="comment">//去掉已分割的字符串,在剩下的字符串中进行分割</span></span><br><span class="line">        strs = strs.<span class="built_in">substr</span>(pos+<span class="number">1</span>, strs.<span class="built_in">size</span>());</span><br><span class="line">        pos = strs.<span class="built_in">find</span>(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>PS：<br>如果用Python split函数更方便，可以直接改用python<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world hello c++&quot;</span></span><br><span class="line"></span><br><span class="line">s = s.split()</span><br><span class="line"><span class="comment"># s= [&#x27;hello&#x27;, &#x27;world&#x27;,&#x27;hello&#x27;,&#x27;c++&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.split(str=&quot;&quot;, num=string.count(str)).</span></span><br><span class="line"><span class="comment"># str -- 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。</span></span><br><span class="line"><span class="comment"># num -- 分割次数。默认为 -1, 即分隔所有。</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++内存分配</title>
    <url>/2020/06/26/C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。
　　</p>
<ul>
<li><strong>栈：</strong> 存放<strong>函数的参数值，局部变量</strong>，函数执行结束时会被自动释放。栈内存分配运算内置于处理器的指令集中，效率高，但是容量有限。</li>
<li><strong>堆：</strong> 是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。。</li>
<li><strong>自由存储区：</strong> 是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。</li>
<li><strong>全局/静态存储区：</strong> 全局变量和静态变量被分配到同一块内存中，在C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。（data段：初始化的段；bss段：未初始化的段）</li>
<li><strong>字符常量存储区：</strong> 常量字符串存于此，程序结束时由系统释放；<span id="more"></span>
</li>
</ul>
<p>实例代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a;  <span class="comment">// 未初始化的静态变量——全局/静态存储区（bss段）</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b = <span class="number">1</span>;  <span class="comment">// 初始化的静态变量——全局/静态存储区（data段）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c;  <span class="comment">// 未初始化的全局变量——全局/静态存储区（bss段）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>; <span class="comment">// 初始化为0的全局变量——全局/静态存储区（bss段）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d = <span class="number">2</span>;  <span class="comment">// 初始化的全局变量——全局/静态存储区（读写data段）</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> e =<span class="number">3</span>;  <span class="comment">// const 全局变量——全局/静态存储区（只读data段）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f = <span class="number">4</span>;  <span class="comment">// 初始化静态局部变量——全局/静态存储区（data段）</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> g;   <span class="comment">// 未初始化静态局部变量——全局/静态存储区（bss段）</span></span><br><span class="line">    <span class="type">int</span> h = <span class="number">5</span>;   <span class="comment">// 初始化局部变量——栈</span></span><br><span class="line">    <span class="type">int</span> i;      <span class="comment">// 未初始化局部变量——栈（值不确定）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> j = <span class="number">6</span>;   <span class="comment">// const局部变量——栈</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *k = <span class="string">&quot;123456&quot;</span>; <span class="comment">//123456存储在常量区，k在栈上。</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 全局或静态变量未初始化则默认值为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>static无论是全局变量还是局部变量都存储在全局/静态区域，在编译期就为其分配内存，在程序结束时释放，例如：a、b、f、g。</p>
</li>
<li><p>const全局变量存储在只读数据段，编译期最初将其保存在符号表中，第一次使用时为其分配内存，在程序结束时释放，例如：e；const局部变量存储在栈中，代码块结束时释放，例如：j。</p>
</li>
<li><p>全局变量存储在全局/静态区域，在编译期为其分配内存，在程序结束时释放，例如：c、d。</p>
</li>
<li><p>局部变量存储在栈中，代码块结束时释放，例如：h、i、j。</p>
</li>
</ol>
<p>内存分区示意图：</p>
<p><img src="/2020/06/26/C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/3.png" alt></p>
<p>我们说的data(初始化的段)   bbs段(未初始化的段) 都是针对全局变量和静态变量来说的.</p>
<p>data又分为读写数据段(rw data) 和 只读数据段(ro data)</p>
<p>bbs是未初始化的全局变量和静态变量和 初始化为0 的全局变量和静态变量.</p>
<p>我们在函数里面的定义的局部变量(除static xxx)都是在stack or  heap里面.  </p>
<p>bbs段不影响a.out的大小,bbs段的数据用占位符标示而已，不在a.out里面.运行才产生.</p>
<p>stack heap也都是在运行的时候产生.</p>
<p><img src="/2020/06/26/C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1.jpg" alt></p>
<p><img src="/2020/06/26/C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/2.jpg" alt></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol>
<li><a href="https://blog.csdn.net/lxw907304340/article/details/79982824">https://blog.csdn.net/lxw907304340/article/details/79982824</a></li>
<li><a href="https://www.cnblogs.com/jcsu/articles/1051579.html">https://www.cnblogs.com/jcsu/articles/1051579.html</a></li>
<li><a href="https://www.polarxiong.com/archives/C-C-%E4%B8%AD%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A8%E5%B1%80-%E9%9D%99%E6%80%81-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E5%B8%B8%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.html">https://www.polarxiong.com/archives/C-C-%E4%B8%AD%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A8%E5%B1%80-%E9%9D%99%E6%80%81-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E5%B8%B8%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.html</a></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板Template</title>
    <url>/2020/05/03/C-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>
<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>
<p>每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector <int> 或 vector <string>。<br><span id="more"></span></string></int></p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>函数模板可以理解为一个公式，可用来生成针对特定类型的函数版本。</p>
<h4 id="普通函数模板"><a href="#普通函数模板" class="headerlink" title="　普通函数模板"></a>　普通函数模板</h4><p>下面定义了一个名叫compare的函数模板，支持多种类型的通用比较逻辑。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">// 模板关键字template，后边为模板参数列表，不能为空</span></span><br><span class="line"><span class="comment">//  类型参数前必须使用关键字class 或者 typename，这两个没什么区别</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; left) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">compare</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//使用模板函数</span></span><br></pre></td></tr></table></figure></p>
<h4 id="成员函数模板"><a href="#成员函数模板" class="headerlink" title="成员函数模板"></a>成员函数模板</h4><p>不仅普通函数可以定义为模板，类的成员函数也可以定义为模板。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; t &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Printer p;</span><br><span class="line">p.<span class="built_in">print</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="string">&quot;abc&quot;</span>); <span class="comment">//打印abc</span></span><br></pre></td></tr></table></figure>
<h4 id="为什么成员函数模板不能是虚函数-virtual-？"><a href="#为什么成员函数模板不能是虚函数-virtual-？" class="headerlink" title="为什么成员函数模板不能是虚函数(virtual)？"></a>为什么成员函数模板不能是虚函数(virtual)？</h4><p>编译器都期望在处理类的定义的时候就能确定这个类的虚函数表的大小，如果允许有类的虚成员模板函数，那么就必须要求编译器提前知道程序中所有对该类的该虚成员模板函数的调用，而这是不可行的。 </p>
<p>在实例化模板类时，需要创建virtual table。<br>在模板类被实例化完成之前不能确定函数模板(包括虚函数模板，加入支持的话)会被实例化多少个。</p>
<p>普通成员函数模板无所谓，什么时候需要什么时候就给你实例化，编译器不用知道到底需要实例化多少个，虚函数的个数必须知道，否则这个类就无法被实例化(因为要创建virtual table)。因此，不支持虚函数模板。</p>
<h4 id="实参推断"><a href="#实参推断" class="headerlink" title="实参推断"></a>实参推断</h4><p>为了方便使用，除了直接为函数模板指定类型参数之外，我们还可以让编译器从传递给函数的实参推断类型参数，这一功能被称为模板实参推断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//推断T的类型为int</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="number">1.0</span>, <span class="number">2.0</span>); <span class="comment">//推断T的类型为double</span></span><br><span class="line">p.<span class="built_in">print</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">//推断T的类型为const char*</span></span><br></pre></td></tr></table></figure>
<h4 id="当返回值类型也是参数时"><a href="#当返回值类型也是参数时" class="headerlink" title="当返回值类型也是参数时"></a>当返回值类型也是参数时</h4><p>当一个模板函数的返回值类型需要用另外一个模板参数表示时，你无法利用实参推断获取全部的类型参数，这时有两种解决办法：</p>
<ul>
<li><p>返回值类型与参数类型完全无关，那么就需要显示的指定返回值类型，其他的类型交给实参推断。</p>
<pre><code>  注意：此行为与函数的默认实参相同，我们必须从左向右逐一指定。
</code></pre>   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function">    T1 <span class="title">sum</span><span class="params">(T2 v2, T3 v3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T1&gt;(v2 + v3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">sum</span>&lt;<span class="type">long</span>&gt;(<span class="number">1L</span>, <span class="number">23</span>); <span class="comment">//指定T1, T2和T3交由编译器来推断</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function">    T3 <span class="title">sum_alternative</span><span class="params">(T1 v1, T2 v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T1&gt;(v1 + v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">sum_alternative</span>&lt;<span class="type">long</span>&gt;(<span class="number">1L</span>, <span class="number">23</span>); <span class="comment">//error，只能从左向右逐一指定</span></span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">sum_alternative</span>&lt;<span class="type">long</span>,<span class="type">int</span>,<span class="type">long</span>&gt;(<span class="number">1L</span>,<span class="number">23</span>); <span class="comment">//ok, 谁叫你把最后一个T3作为返回类型的呢？</span></span><br><span class="line">     ```   </span><br><span class="line">- 返回值类型可以从参数类型中获得，那么把函数写成尾置返回类型的形式，就可以愉快的使用实参推断了。</span><br><span class="line"></span><br><span class="line">    ```c++</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">sum</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span>   <span class="comment">// 尾置返回类型</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">decltype</span>(*beg) ret = *beg;</span><br><span class="line">        <span class="keyword">for</span> (It it = beg+<span class="number">1</span>; it != end; it++) &#123;</span><br><span class="line">            ret  = ret + *it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> s = <span class="built_in">sum</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">//s = 10</span></span><br></pre></td></tr></table></figure>
<h4 id="实参推断时的自动类型转换"><a href="#实参推断时的自动类型转换" class="headerlink" title="实参推断时的自动类型转换"></a>实参推断时的自动类型转换</h4><p>编译器进行模板实参推断时通常不会对实参进行类型转换，只有以下几种情况例外：</p>
</li>
<li><p>普通对象赋值给const引用 <code>int a = 0; -&gt; const T&amp;</code></p>
</li>
<li>数组名转换为头指针 <code>int a[10] = &#123;0&#125;; -&gt; T*</code></li>
<li>函数名转换为函数指针<code>void func(int a)&#123;...&#125; -&gt; T*</code></li>
</ul>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板也是公共逻辑的抽象，通常用来作为容器（例如：vector）或者行为（例如：clonable）的封装。</p>
<p>参考侯捷老师《STL源码分析》的视频理解，设计一个复数</p>
<p><img src="/2020/05/03/C-%E6%A8%A1%E6%9D%BF/1.png" alt></p>
<p>与函数模板不同，类模板不能推断实例化。所以你只能显示指定类型参数使用complex<double>  c1(2.5, 1.5)，complex<int>  c2(2, 6)，而不能让编译器自行推断complex  c1。</int></double></p>
<h4 id="类模板中的成员函数模板"><a href="#类模板中的成员函数模板" class="headerlink" title="类模板中的成员函数模板"></a>类模板中的成员函数模板</h4><p>我们还可以把类模板和函数模板结合起来，定义一个含有成员函数模板的类模板。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Printer</span><span class="params">(<span class="type">const</span> T&amp; param)</span>:t(param)&#123;</span>&#125;</span><br><span class="line">    <span class="comment">//成员函数模板</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">add_and_print</span><span class="params">(<span class="type">const</span> U&amp; u)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里要有两层template的说明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">void</span> Printer&lt;T&gt;::<span class="built_in">add_and_print</span>(<span class="type">const</span> U&amp; u) &#123;</span><br><span class="line">    cout &lt;&lt; t + u &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">add_and_print</span>(<span class="number">1.1</span>); <span class="comment">//自动推断U为double，打印出43.1</span></span><br></pre></td></tr></table></figure></p>
<h4 id="类模板中的static成员"><a href="#类模板中的static成员" class="headerlink" title="类模板中的static成员"></a>类模板中的static成员</h4><p>类模板中可以声明static成员，在类外定义的时候要增加template相关的关键词。另外，需要注意的是：每个不同的模板实例都会有一个独有的static成员对象。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态成员属于类共享，不独享于某一个实例对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Printer</span><span class="params">(<span class="type">const</span> T&amp; param)</span>:t(param)&#123;</span>&#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_value;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//注意这里的定义方式</span></span><br><span class="line"><span class="type">int</span> Printer&lt;T&gt;::s_value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Printer&lt;<span class="type">int</span>&gt; <span class="title">pi2</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Printer&lt;<span class="type">double</span>&gt; <span class="title">pd</span><span class="params">(<span class="number">1.0</span>)</span></span>;</span><br><span class="line">pi.s_value += <span class="number">1</span>; <span class="comment">//pi和pi2中的改变了，pd的没改变</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>其实这个结论是显然的，static成员属于实例化后的类，不同的实例化当然有不同static成员。就像上面的例子一样，pi.s_value += 1只影响到了Printer<int>，而不会影响到Printer<double>。</double></int></p>
<h4 id="类模板成员函数实例化"><a href="#类模板成员函数实例化" class="headerlink" title="类模板成员函数实例化"></a>类模板成员函数实例化</h4><p>为了节省资源，类模板实例化时并不是每个成员函数都实例化了，而是使用到了哪个成员函数，那个成员函数才实例化。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Printer</span><span class="params">(<span class="type">const</span> T&amp; param)</span>:t(param)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    T t;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">empty</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">empty e;</span><br><span class="line"><span class="function">Printer&lt;empty&gt; <span class="title">p</span><span class="params">(e)</span></span>; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><br>虽然成员函数print无法通过编译，但是因为没有使用到，也就没有实例化print，所以没有触发编译错误。</p>
<h4 id="类模板别名"><a href="#类模板别名" class="headerlink" title="类模板别名"></a>类模板别名</h4><p>为了简化代码，我们可以使用typedef为类模板的某个实例定义一个别名，也可以使用using语句固定一个或多个类型参数（这有点偏特化的意思了）。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PairOfInt; <span class="comment">//ok，为std::pair&lt;int, int&gt;定义了一个别名</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> WithNum = std::pair&lt;T, <span class="type">int</span>&gt;; <span class="comment">//ok，相当于定义了一个std::pair的偏特化</span></span><br><span class="line"></span><br><span class="line">PairOfInt poi; <span class="comment">//实际类型，std::pair&lt;int, int&gt;</span></span><br><span class="line">WithNum&lt;std::string&gt; strs; <span class="comment">//实际类型，std::pair&lt;string, int&gt;</span></span><br><span class="line">WithNum&lt;<span class="type">int</span>&gt; ints; <span class="comment">//实际类型，std::pair&lt;int, int&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><h3 id="特化与偏特化"><a href="#特化与偏特化" class="headerlink" title="特化与偏特化"></a>特化与偏特化</h3><h4 id="类模板的特化与偏特化"><a href="#类模板的特化与偏特化" class="headerlink" title="类模板的特化与偏特化"></a>类模板的特化与偏特化</h4><p>就像函数模板重载那样，你可以通过特化（偏特化）类模板来为特定的类型指定你想要的行为。类模板的特化（偏特化）只需要模板名称相同并且特化列表&lt;&gt;中的参数个数与原始模板对应上即可，模板参数列表不必与原始模板相同模板名称相同。一个类模板可以有多个特化，与函数模板相同，编译器会自动实例化那个最特殊的版本。</p>
<p>模板特化指的是模板中指定特定的数据类型，这和泛化是不同的：</p>
<p><img src="/2020/05/03/C-%E6%A8%A1%E6%9D%BF/2.png" alt></p>
<p>模板特化也有程度之分，可以部分类型指定，称之为偏特化：</p>
<p><img src="/2020/05/03/C-%E6%A8%A1%E6%9D%BF/3.png" alt></p>
<p><img src="/2020/05/03/C-%E6%A8%A1%E6%9D%BF/4.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//基本模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;In base template\n&quot;</span>); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">//特化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span>&lt;<span class="type">int</span>&gt; &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;In int specialization\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//偏特化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span>&lt;T*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;In pointer specialization\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="comment">//另外一个偏特化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span>&lt;<span class="built_in">T</span>(U)&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In function specialization\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">S&lt;<span class="type">float</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">info</span>();     <span class="comment">//调用base模板                </span></span><br><span class="line">S&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">s2.<span class="built_in">info</span>();     <span class="comment">//调用int特化版本</span></span><br><span class="line">S&lt;<span class="type">float</span>*&gt; s3;</span><br><span class="line">s3.<span class="built_in">info</span>();     <span class="comment">//调用T*特化版本 </span></span><br><span class="line">S&lt;<span class="keyword">decltype</span>(func)&gt; s4;</span><br><span class="line">s4.<span class="built_in">info</span>();     <span class="comment">//调用函数特化版本</span></span><br></pre></td></tr></table></figure>
<p>提供了所有类型实参的特化是完全特化，只提供了部分类型实参或者T的类型受限（例如：T*）的特化被认为是不完整的，所以也被称为偏特化。完全特化的结果是一个实际的class，而偏特化的结果是另外一个同名的模板。</p>
<h4 id="类模板成员特化"><a href="#类模板成员特化" class="headerlink" title="类模板成员特化"></a>类模板成员特化</h4><p>除了可以特化类模板之外，还可以对类模板中的成员函数和普通静态成员变量进行特化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In base template\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> code;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> S&lt;T&gt;::code = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">int</span> S&lt;<span class="type">int</span>&gt;::code = <span class="number">100</span>;    <span class="comment">//普通静态成员变量的int特化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> S&lt;<span class="type">int</span>&gt;::<span class="built_in">info</span>() &#123;    <span class="comment">//成员函数的int特化</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;In int specialization\n&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">S&lt;<span class="type">float</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">info</span>();    <span class="comment">//普通版本</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Code is: %d\n&quot;</span>, s1.code);    <span class="comment">//code = 10</span></span><br><span class="line"></span><br><span class="line">S&lt;<span class="type">int</span>&gt; s2; </span><br><span class="line">s2.<span class="built_in">info</span>();   <span class="comment">//int特化版本</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Code is: %d\n&quot;</span>, s2.code);   <span class="comment">//code = 100</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++二维数组按行遍历和按列遍历的区别</title>
    <url>/2020/04/03/C-%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E5%92%8C%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>按行遍历的效率更高。</p>
<p>数组在内存中是按行储存的，按行遍历时可以由指向数组第一个数的指针一直往下走，就可以遍历完整个数组，而按列遍历则要获得指向每一列的第一行的元素的指针，然后每次将指针指下一行，但是指针的寻址很快，所以不会有明显的区别。<br><span id="more"></span></p>
<p>按行遍历比按列遍历效率高具体体现在以下几点</p>
<p>1、<a href="https://zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98">CPU高速缓存</a></p>
<p>计算机存在Cache机制，当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在，则不经访问内存直接返回该数据；如果不存在，则要先把内存中的相应数据载入缓存，再将其返回处理器。</p>
<p>缓存从内存中抓取一般都是整个数据块，所以它的物理内存是连续的，几乎都是同行不同列的，而如果内循环以列的方式进行遍历的话，将会使整个缓存块无法被利用，而不得不从内存中读取数据，而从内存读取速度是远远小于从缓存中读取数据的。</p>
<p>2、分页调度</p>
<p>物理内存是以页的方式进行划分的，当一个二维数组很大是如 int[128][1024],假设一页的内存为4096个字节，而每一行正好占据内存的一页（int 存储是4个字节），如果以列的形式进行遍历，就会发生128*1024次的页面调度，而如果以行遍历则只有128次页面调度，而页面调度是有时间消耗的，因而调度次数越多，遍历的时间就越长。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针详解</title>
    <url>/2020/04/01/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>智能指针分为三种：shared_ptr, unique_ptr, weak_ptr。本文就是详细介绍一下智能指针，作为笔记，方便理解。</p>
<p>智能指针的作用是动态分配内存，避免内存泄漏。<br><span id="more"></span><br>    PS:<br>    内存泄漏：<br>        程序没有释放已经不再使用的内存，由于设计错误，导致在释放该段内存<br>        之前就失去了对该段内存的控制，因此这段内存一直被占用，无法释放，造<br>        成空间的浪费。</p>
<pre><code>内存溢出：
    要求分配的内存超过了系统所能给我的，系统不能满足需求。内存泄漏的堆
    积如果不及时处理最终会导致内存溢出。
</code></pre><h2 id="shared-ptr介绍"><a href="#shared-ptr介绍" class="headerlink" title="shared_ptr介绍"></a>shared_ptr介绍</h2><p>shared_ptr是一个引用计数智能指针，用于共享对象的所有权，也就是说它允许多个指针指向同一个对象</p>
<h3 id="shared-ptr的简单使用："><a href="#shared-ptr的简单使用：" class="headerlink" title="shared_ptr的简单使用："></a>shared_ptr的简单使用：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Example</span>() : <span class="built_in">e</span>(<span class="number">1</span>) &#123; cout &lt;&lt; <span class="string">&quot;Example Constructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">        ~<span class="built_in">Example</span>() &#123; cout &lt;&lt; <span class="string">&quot;Example Destructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">shared_ptr&lt;Example&gt; <span class="title">pInt</span><span class="params">(<span class="keyword">new</span> Example())</span></span>;</span><br><span class="line">    cout &lt;&lt; (*pInt).e &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pInt引用计数: &quot;</span> &lt;&lt; pInt.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Example&gt; pInt2 = pInt;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pInt引用计数: &quot;</span> &lt;&lt; pInt.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pInt2引用计数: &quot;</span> &lt;&lt; pInt2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Example Constructor...</span><br><span class="line">pInt: <span class="number">1</span></span><br><span class="line">pInt引用计数: <span class="number">1</span></span><br><span class="line">pInt引用计数: <span class="number">2</span></span><br><span class="line">pInt2引用计数: <span class="number">2</span></span><br><span class="line">Example Destructor...</span><br></pre></td></tr></table></figure><br>从上面这段代码中，我们对shared_ptr指针有了一些直观的了解。一方面，跟STL中大多数容器类型一样，shared_ptr也是模板类，因此在创建shared_ptr时需要指定其指向的类型。另一方面，正如其名一样，shared_ptr指针允许让多个该类型的指针共享同一堆分配对象。同时shared_ptr使用经典的“引用计数”方法来管理对象资源，每个shared_ptr对象关联一个共享的引用计数。</p>
<p>对于shared_ptr在拷贝和赋值时的行为，《C++Primer第五版》中有详细的描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每个shared_ptr都有一个关联的计数值，通常称为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。</span><br><span class="line"></span><br><span class="line">例如，当用一个shared_ptr初始化另一个shred_ptr，或将它当做参数传递给一</span><br><span class="line">个函数以及作为函数的返回值时，它所关联的计数器就会递增。</span><br><span class="line"></span><br><span class="line">当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的</span><br><span class="line">shared_ptr离开其作用域）时，计数器就会递减。一旦一个shared_ptr的计数</span><br><span class="line">器变为0，它就会自动释放自己所管理的对象。</span><br></pre></td></tr></table></figure>
<p>对比我们上面的代码可以看到：当我们将一个指向Example对象的指针交给pInt管理后，其关联的引用计数为1。接下来，我们用pInt初始化pInt2，两者关联的引用计数值增加为2。随后，函数结束，pInt和PInt2相继离开函数作用于，相应的引用计数值分别自减1最后变为0，于是Example对象被自动释放（调用其析构函数）。</p>
<h3 id="shared-ptr的常见用法"><a href="#shared-ptr的常见用法" class="headerlink" title="shared_ptr的常见用法"></a>shared_ptr的常见用法</h3><h4 id="1、创建shared-ptr实例"><a href="#1、创建shared-ptr实例" class="headerlink" title="1、创建shared_ptr实例"></a>1、创建shared_ptr实例</h4><p>最安全和高效的方法是调用make_shared库函数，该函数会在堆中分配一个对象并初始化，最后返回指向此对象的share_ptr实例。如果你不想使用make_ptr，也可以先明确new出一个对象，然后把其原始指针传递给share_ptr的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递给make_shared函数的参数必须和shared_ptr所指向类型的某个构造函数相匹配</span></span><br><span class="line">    shared_ptr&lt;string&gt; pStr = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; *pStr &lt;&lt; endl;  <span class="comment">//  aaaaaaaaaa</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt</span><span class="params">(p)</span></span>;</span><br><span class="line">    cout &lt;&lt; *pInt &lt;&lt; endl;  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、访问所指对象"><a href="#2、访问所指对象" class="headerlink" title="2、访问所指对象"></a>2、访问所指对象</h4><p>shared_ptr的使用方式与普通指针的使用方式类似，既可以使用解引用操作符*获得原始对象进而访问其各个成员，也可以使用指针访问符-&gt;来访问原始对象的各个成员。</p>
<h4 id="3、拷贝和赋值操作"><a href="#3、拷贝和赋值操作" class="headerlink" title="3、拷贝和赋值操作"></a>3、拷贝和赋值操作</h4><p>我们可以用一个shared_ptr对象来初始化另一个share_ptr实例，该操作会增加其引用计数值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;string&gt; pStr = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; pStr.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">//  1</span></span><br><span class="line"></span><br><span class="line">    <span class="function">shared_ptr&lt;string&gt; <span class="title">pStr2</span><span class="params">(pStr)</span></span>;</span><br><span class="line">    cout &lt;&lt; pStr.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">//  2</span></span><br><span class="line">    cout &lt;&lt; pStr2.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">//  2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果shared_ptr实例p和另一个shared_ptr实例q所指向的类型相同或者可以相互转换，我们还可以进行诸如p = q这样赋值操作。该操作会递减p的引用计数值，递增q的引用计数值。</p>
<p>例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(string n) : <span class="built_in">name</span>(n) &#123; cout &lt;&lt; n &lt;&lt; <span class="string">&quot; constructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Example</span>() &#123; cout &lt;&lt; name &lt;&lt; <span class="string">&quot; destructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Example&gt; pStr = <span class="built_in">make_shared</span>&lt;Example&gt;(<span class="string">&quot;a object&quot;</span>);</span><br><span class="line">    shared_ptr&lt;Example&gt; pStr2 = <span class="built_in">make_shared</span>&lt;Example&gt;(<span class="string">&quot;b object&quot;</span>);</span><br><span class="line">    cout &lt;&lt; pStr.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pStr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pStr = pStr2;   <span class="comment">// 此后pStr和pStr指向相同对象</span></span><br><span class="line">    cout &lt;&lt; pStr-&gt;name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pStr2-&gt;name &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a object constructor...</span><br><span class="line">b object constructor...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">a object destructor...</span><br><span class="line">b object</span><br><span class="line">b object</span><br><span class="line">b object destructor...</span><br></pre></td></tr></table></figure></p>
<h4 id="4、检查引用计数"><a href="#4、检查引用计数" class="headerlink" title="4、检查引用计数"></a>4、检查引用计数</h4><p>shared_ptr提供了两个函数来检查其共享的引用计数值，分别是unique()和use_count()。</p>
<p>在前面，我们已经多次使用过use_count()函数，该函数返回当前指针的引用计数值。值得注意的是use_count()函数可能效率很低，应该只把它用于测试或调试。</p>
<p>unique()函数用来测试该shared_ptr是否是原始指针唯一拥有者，也就是use_count()的返回值为1时返回true，否则返回false。</p>
<p>示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;string&gt; pStr = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; pStr.<span class="built_in">unique</span>() &lt;&lt; endl;  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="function">shared_ptr&lt;string&gt; <span class="title">pStr2</span><span class="params">(pStr)</span></span>;</span><br><span class="line">    cout &lt;&lt; pStr2.<span class="built_in">unique</span>() &lt;&lt; endl; <span class="comment">// false;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="weak-ptr介绍"><a href="#weak-ptr介绍" class="headerlink" title="weak_ptr介绍"></a>weak_ptr介绍</h2><p>在正式介绍weak_ptr之前，我们先来回忆一下shared_ptr的一些知识。我们知道shared_ptr是采用引用计数的智能指针，多个shared_ptr实例可以指向同一个动态对象，并维护了一个共享的引用计数器。对于引用计数法实现的计数，总是避免不了循环引用（或环形引用）的问题，shared_ptr也不例外。</p>
<p>我们先来看看下面这个例子：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassA</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassA Constructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">ClassA</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassA Destructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    shared_ptr&lt;ClassB&gt; pb;  <span class="comment">// 在A中引用B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassB</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassB Constructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">ClassB</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassB Destructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    shared_ptr&lt;ClassA&gt; pa;  <span class="comment">// 在B中引用A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;ClassA&gt; spa = <span class="built_in">make_shared</span>&lt;ClassA&gt;();</span><br><span class="line">    shared_ptr&lt;ClassB&gt; spb = <span class="built_in">make_shared</span>&lt;ClassB&gt;();</span><br><span class="line">    spa-&gt;pb = spb;</span><br><span class="line">    spb-&gt;pa = spa;</span><br><span class="line">    <span class="comment">// 函数结束，思考一下：spa和spb会释放资源么？</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClassA Constructor...</span><br><span class="line">ClassB Constructor...</span><br><span class="line">Program ended with exit code: <span class="number">0</span></span><br></pre></td></tr></table></figure><br>从上面代码中，ClassA和ClassB间存在着循环引用，从运行结果中我们可以看到：当main函数运行结束后，spa和spb管理的动态资源并没有得到释放，产生了内存泄漏。</p>
<p>为了解决类似这样的问题，C++11引入了weak_ptr，来打破这种循环引用。</p>
<p>weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。</p>
<h3 id="weak-ptr用法"><a href="#weak-ptr用法" class="headerlink" title="weak_ptr用法"></a>weak_ptr用法</h3><h4 id="1、创建weak-ptr实例"><a href="#1、创建weak-ptr实例" class="headerlink" title="1、创建weak_ptr实例"></a>1、创建weak_ptr实例</h4><p>当我们创建一个weak_ptr时，需要用一个shared_ptr实例来初始化weak_ptr，由于是弱共享，weak_ptr的创建并不会影响shared_ptr的引用计数值。</p>
<p>示例:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建前sp的引用计数：&quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// use_count = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建后sp的引用计数：&quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// use_count = 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、判断weak-ptr指向对象是否存在"><a href="#2、判断weak-ptr指向对象是否存在" class="headerlink" title="2、判断weak_ptr指向对象是否存在"></a>2、判断weak_ptr指向对象是否存在</h4><p>既然weak_ptr并不改变其所共享的shared_ptr实例的引用计数，那就可能存在weak_ptr指向的对象被释放掉这种情况。这时，我们就不能使用weak_ptr直接访问对象。那么我们如何判断weak_ptr指向对象是否存在呢？C++中提供了lock函数来实现该功能。如果对象存在，lock()函数返回一个指向共享对象的shared_ptr，否则返回一个空shared_ptr。</p>
<p>示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">a</span>(<span class="number">3</span>) &#123; cout &lt;&lt; <span class="string">&quot;A Constructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A Destructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;A&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="comment">//sp.reset();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shared_ptr&lt;A&gt; pa = wp.<span class="built_in">lock</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; pa-&gt;a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;wp指向对象为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果把sp.reset()这行的注释去掉会导致wp指向对象为空。</p>
<p>weak_ptr还提供了expired()函数来判断所指对象是否已经被销毁。</p>
<p>示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">a</span>(<span class="number">3</span>) &#123; cout &lt;&lt; <span class="string">&quot;A Constructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A Destructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;A&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    sp.<span class="built_in">reset</span>(); <span class="comment">// 此时sp被销毁</span></span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">expired</span>() &lt;&lt; endl;  <span class="comment">// true表示已被销毁，否则为false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A Constructor...</span><br><span class="line">A Destructor...</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3、具体使用weak-ptr"><a href="#3、具体使用weak-ptr" class="headerlink" title="3、具体使用weak_ptr"></a>3、具体使用weak_ptr</h4><p>weak_ptr并没有重载operator-&gt;和operator *操作符，因此不可直接通过weak_ptr使用对象，典型的用法是调用其lock函数来获得shared_ptr示例，进而访问原始对象.</p>
<p>下面使用weak_ptr来改造最前面的代码，打破循环引用问题。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassA</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassA Constructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">ClassA</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassA Destructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    weak_ptr&lt;ClassB&gt; pb;  <span class="comment">// 在A中引用B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassB</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassB Constructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">ClassB</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassB Destructor...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    weak_ptr&lt;ClassA&gt; pa;  <span class="comment">// 在B中引用A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;ClassA&gt; spa = <span class="built_in">make_shared</span>&lt;ClassA&gt;();</span><br><span class="line">    shared_ptr&lt;ClassB&gt; spb = <span class="built_in">make_shared</span>&lt;ClassB&gt;();</span><br><span class="line">    spa-&gt;pb = spb;</span><br><span class="line">    spb-&gt;pa = spa;</span><br><span class="line">    <span class="comment">// 函数结束，思考一下：spa和spb会释放资源么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从运行结果可以看到spa和spb指向的对象都得到释放。</p>
<h2 id="unique-ptr介绍"><a href="#unique-ptr介绍" class="headerlink" title="unique_ptr介绍"></a>unique_ptr介绍</h2><p>unique是独特的、唯一的意思，故名思议，unique_ptr可以“独占”地拥有它所指向的对象，它提供一种严格意义上的所有权。这一点和我们前面介绍的shared_ptr类型指针有很大的不同：shared_ptr允许多个指针指向同一对象，而unique_ptr在某一时刻只能有一个指针指向该对象。unique_ptr保存指向某个对象的指针，当它本身被删除或者离开其作用域时会自动释放其指向对象所占用的资源。</p>
<p>下图演示了两个 unique_ptr 实例之间的所有权转换。</p>
<p><img src="/2020/04/01/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/unique_ptr.png" alt></p>
<h3 id="unique-ptr的基本特性"><a href="#unique-ptr的基本特性" class="headerlink" title="unique_ptr的基本特性"></a>unique_ptr的基本特性</h3><h4 id="1、创建unique-ptr"><a href="#1、创建unique-ptr" class="headerlink" title="1、创建unique_ptr"></a>1、创建unique_ptr</h4><p>示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个unique_ptr实例</span></span><br><span class="line">    <span class="comment">// unique_ptr&lt;int&gt; pInt(new int(5));</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; pInt = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; *pInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、无法进行复制构造和赋值操作"><a href="#2、无法进行复制构造和赋值操作" class="headerlink" title="2、无法进行复制构造和赋值操作"></a>2、无法进行复制构造和赋值操作</h4><p>unique_ptr没有copy构造函数，不支持普通的拷贝和赋值操作。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个unique_ptr实例</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; pInt = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt2</span><span class="params">(pInt)</span></span>;    <span class="comment">// 报错</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; pInt3 = pInt;   <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3、可以进行移动构造和移动赋值操作"><a href="#3、可以进行移动构造和移动赋值操作" class="headerlink" title="3、可以进行移动构造和移动赋值操作"></a>3、可以进行移动构造和移动赋值操作</h4><p>unique_ptr虽然没有支持普通的拷贝和赋值操作，但却提供了一种移动机制来将指针的所有权从一个unique_ptr转移给另一个unique_ptr。如果需要转移所有权，可以使用std::move()函数。</p>
<p>示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; pInt = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; pInt2 = std::<span class="built_in">move</span>(pInt);    <span class="comment">// 转移所有权</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *pInt &lt;&lt; endl; // 出错，pInt为空</span></span><br><span class="line">    cout &lt;&lt; *pInt2 &lt;&lt; endl;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt3</span><span class="params">(std::move(pInt2))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4、可以返回unique-ptr"><a href="#4、可以返回unique-ptr" class="headerlink" title="4、可以返回unique_ptr"></a>4、可以返回unique_ptr</h4><p>unique_ptr不支持拷贝操作，但却有一个例外：可以从函数中返回一个unique_ptr。</p>
<p>示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; pInt = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> pInt;    <span class="comment">// 返回unique_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">5</span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ret = <span class="built_in">clone</span>(p);</span><br><span class="line">    cout &lt;&lt; *ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="unique-ptr使用场景"><a href="#unique-ptr使用场景" class="headerlink" title="unique_ptr使用场景"></a>unique_ptr使用场景</h3><h4 id="1、为动态申请的资源提供异常安全保证"><a href="#1、为动态申请的资源提供异常安全保证" class="headerlink" title="1、为动态申请的资源提供异常安全保证"></a>1、为动态申请的资源提供异常安全保证</h4><p>我们先来看看下面这一段代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（可能会抛出异常）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这是我们传统的写法：当我们动态申请内存后，有可能我们接下来的代码由于抛出异常或者提前退出（if语句）而没有执行delete操作。</p>
<p>解决的方法是使用unique_ptr来管理动态内存，只要unique_ptr指针创建成功，其析构函数都会被调用。确保动态资源被释放。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; pInt = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（可能会抛出异常）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、返回函数内动态申请资源的所有权"><a href="#2、返回函数内动态申请资源的所有权" class="headerlink" title="2、返回函数内动态申请资源的所有权"></a>2、返回函数内动态申请资源的所有权</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">Func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; pInt = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> pInt;    <span class="comment">// 返回unique_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">5</span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ret = <span class="built_in">Func</span>(p);</span><br><span class="line">    cout &lt;&lt; *ret &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 函数结束后，自动释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、在容器中保存指针"><a href="#3、在容器中保存指针" class="headerlink" title="3、在容器中保存指针"></a>3、在容器中保存指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;unique_ptr&lt;<span class="type">int</span>&gt;&gt; vec;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; p= <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(p));    <span class="comment">// 使用移动语义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、管理动态数组"><a href="#4、管理动态数组" class="headerlink" title="4、管理动态数组"></a>4、管理动态数组</h4><p>标准库提供了一个可以管理动态数组的unique_ptr版本。</p>
<p>可以使用make_unique来创建一个到数组的 unique_ptr，但不能使用 make_unique 来初始化数组元素<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// unique_ptr&lt;int[]&gt; p(new int[5] &#123;1, 2, 3, 4, 5&#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a unique_ptr to an array of 5 integers.</span></span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the array.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        wcout &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">// 重载了operator[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5、作为auto-ptr的替代品"><a href="#5、作为auto-ptr的替代品" class="headerlink" title="5、作为auto_ptr的替代品"></a>5、作为auto_ptr的替代品</h4>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++单例模式Singleton的实现</title>
    <url>/2020/04/01/C-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FSingleton%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="问题情景"><a href="#问题情景" class="headerlink" title="问题情景"></a>问题情景</h3><p>在windows下面打开任务管理器，我们会发现，你只能打开一个任务管理器。如果在已打开一个任务管理器的情况下，再次打开任务管理器，系统会调出已经打开的窗口，而不是重新打开新的窗口。在系统中，之多只能存在一个任务管理器的实例。按照一般的思路，我们需要定义一个TaskManager的类（如下）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TaskManager</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><span id="more"></span></p>
<p>但这存在问题，只要我们调用一次初始化函数，系统就会生成一个TaskManager的实例，不能保证系统中之多只存在一个实例的要求。于是我们需要采用设计模式中的单例模式（Singleton）来实现。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>单例模式的两个功能：仅有一个实例和全局访问点。我们通过Singleton的类图来看一下这个模式：</p>
<p><img src="/2020/04/01/C-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FSingleton%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png" alt></p>
<p>在Singleton中，类的初始化函数被设为了private，这就意味着Client是不能通过调用类的初始化函数来生成一个实例，防止Client多次调用初始化函数生成多个实例出来。如果要访问Singleton，需要通过GetInstance方法，这是一个静态的方法，主要负责创建自己的实例，返回实例的指针给Client。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)<span class="comment">//第一次调用要判断指针是否为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                p_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">Singleton</span>()&#123;&#125;; <span class="comment">//构造函数设计成私有的</span></span><br><span class="line">        <span class="type">static</span> Singleton *p_instance; <span class="comment">//用类的指针指向唯一的实例</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//静态数据成员是静态存储的，必须对他进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *object = Singleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Singleton类封装了它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单的说就是对唯一实例的受控访问。一般的，Singleton不会定义析构函数，由于实例分配的是全局地址，在程序运行结束，被系统收回所有分配空间时，Singleton才会被销毁，如果Singleton成员数据太多的话，可能占用了大量的内存空间而不能被释放，这需要我们注意。</p>
<h3 id="Singleton与全局变量的区别"><a href="#Singleton与全局变量的区别" class="headerlink" title="Singleton与全局变量的区别"></a>Singleton与全局变量的区别</h3><p>Singleton与全局变量都有全局访问的功能，但两者之间存在一些差别，全局变量在使用的过程中会存在一些问题：</p>
<ul>
<li>变量名冲突：必须小心维护变量名，每遇到一个全局变量，都必须仔细分辨该变量属于哪个模块、哪个程序。</li>
<li>耦合度难题：使用全局变量增加了函数与模块间的耦合程度，不易维护。</li>
<li>单个实体问题：全局变量不能防止一个类生成多个实例出来。</li>
<li>多线程访问：并发访问时需要使用同步机制，小心保护全局变量，避免冲突。</li>
</ul>
<p>看起来，使用Singleton可以避免上面的这些问题，但Singleton自身也有一些弊端。</p>
<h3 id="Singleton的优缺点"><a href="#Singleton的优缺点" class="headerlink" title="Singleton的优缺点"></a>Singleton的优缺点</h3><p>Singleton的优点：</p>
<ul>
<li>跨平台：使用合适的中间件可以把Singleton扩展为跨多个计算机工作。</li>
<li>适用于任何类：只要将初始化函数设为私有，并增加相应的静态函数和变量，就能把类变成Singleton。</li>
<li>延迟性：如果Singleton从未使用，就不会创建（仅指懒汉模式）</li>
</ul>
<p>Singleton的缺点：</p>
<ul>
<li>效率问题：由于if语句的存在，调用方法的效率收到影响。</li>
<li>不变重用：在C++下需要定义模板才能实现Singleton的重用。</li>
</ul>
<h3 id="Singleton的懒汉模式与饿汉模式"><a href="#Singleton的懒汉模式与饿汉模式" class="headerlink" title="Singleton的懒汉模式与饿汉模式"></a>Singleton的懒汉模式与饿汉模式</h3><p>针对Singleton初始化函数的调用策略，有两种选择，分别是懒汉模式和饿汉模式。</p>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><p>使用懒汉模式时，Singleton在程序第一次调用的时候才会初始化自己，代码如下。使用该模式时，由于if语句的存在，会影响调用的效率。而且，在多线程环境下使用时，为了保证只能初始化一个实例，需要用锁来保证线程安全性，防止同时多个线程进入if语句中。如果遇到处理大量数据时，锁会成为整个性能的瓶颈。一般懒汉模式适用于程序一部分中需要使用Singleton，且在实例化后没有大量频繁访问或线程访问的情况。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mtx.<span class="built_in">lock</span>();</span><br><span class="line">                <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    p_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                mtx.<span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">Singleton</span>()&#123;&#125;; <span class="comment">//构造函数设计成私有的</span></span><br><span class="line">        <span class="type">static</span> Singleton *p_instance; <span class="comment">//用类的指针指向唯一的实例</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//静态数据成员是静态存储的，必须对他进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *object = Singleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>PS:
GCC在Linux下的std::mutex工作良好。 然而，在Windows上很遗憾，
_GLIBCXX_HAS_GTHREADS没有在Windows上定义。mutex运行时支持是不存在的。
</code></pre><h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>使用饿汉模式时，Singleton在程序一开始就将自己实例化，之后的GetInstance方法仅返回实例的指针即可，这样就解决了上述提到的if语句影响效率的问题。代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Singleton* p_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();<span class="comment">//在此直接实例化</span></span><br><span class="line">        <span class="built_in">Singleton</span>()&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>饿汉模式适用于Singleton在程序运行过程中一直被频繁调用，这样由于预先加载了实例，访问实例时没有if语句，效率更高。但要注意到，如果Singleton的成员比较庞大、复杂，实例化Singleton会花一些时间，且这个实例一直占用着大量内存，在使用时要注意这部分的开销。使用饿汉模式用于多线程编程的话，由于线程访问之前，实例已存在，就不需要像懒汉模式中加入锁，因此饿汉模式保证了多线程安全。饿汉模式比较适用于程序整个运行过程中都需要访问、会被频繁访问或者需要被多线程访问的情况。</p>
<pre><code>PS:
类名加*，有两种作用情况：
1. 用于定义时，或用于函数参数，返回值时，表示对应变量值为类指针类型；
2. 用于变量前，以(CLASS_NAME *)var_name，形式出现时，表示将变量或
常量var_name强制转换为类指针类型。
</code></pre>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++线程安全的单例模式总结</title>
    <url>/2020/07/19/C-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h3><p>在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p>
<h3 id="如何保证线程安全？"><a href="#如何保证线程安全？" class="headerlink" title="如何保证线程安全？"></a>如何保证线程安全？</h3><ol>
<li>给共享的资源加把锁，保证每个资源变量每时每刻至多被一个线程占用。</li>
<li>让线程也拥有资源，不用去共享进程中的资源。如： 使用threadlocal可以为每个线程的维护一个私有的本地变量。</li>
</ol>
<h3 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h3><p>单例模式指在整个系统生命周期里，保证一个类只能产生一个实例，确保该类的<strong>唯一性</strong>。</p>
<h4 id="单例模式分类"><a href="#单例模式分类" class="headerlink" title="单例模式分类"></a>单例模式分类</h4><p>单例模式可以分为<strong>懒汉式</strong>和<strong>饿汉式</strong>，两者之间的区别在于创建实例的时间不同：</p>
<ul>
<li>懒汉式：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。（这种方式要考虑线程安全）</li>
<li>饿汉式：指系统一运行，就初始化创建实例，当需要时，直接调用即可。（本身就线程安全，没有多线程的问题）<span id="more"></span>
<h4 id="单例类的特点"><a href="#单例类的特点" class="headerlink" title="单例类的特点"></a>单例类的特点</h4></li>
<li>构造函数和析构函数为private类型，目的禁止外部构造和析构</li>
<li>拷贝构造和赋值构造函数为private类型，目的是禁止外部拷贝和赋值，确保实例的唯一性</li>
<li>类里有个获取实例的静态函数，可以全局访问</li>
</ul>
<h3 id="01-普通懒汉式单例-（-线程不安全-）"><a href="#01-普通懒汉式单例-（-线程不安全-）" class="headerlink" title="01 普通懒汉式单例 （ 线程不安全 ）"></a>01 普通懒汉式单例 （ 线程不安全 ）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////  普通懒汉式实现 -- 线程不安全 //////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放单例，进程退出时调用</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印单例地址</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将其构造和析构成为私有的, 禁止外部构造和析构</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>();</span><br><span class="line">    ~<span class="built_in">SingleInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance &amp;signal);</span><br><span class="line">    <span class="type">const</span> SingleInstance &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SingleInstance &amp;signal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 唯一单例对象指针</span></span><br><span class="line">    <span class="type">static</span> SingleInstance *m_SingleInstance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态成员变量</span></span><br><span class="line">SingleInstance *SingleInstance::m_SingleInstance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleInstance* <span class="title">SingleInstance::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_SingleInstance == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_SingleInstance = <span class="keyword">new</span> <span class="built_in">SingleInstance</span>();  <span class="comment">// 没有加锁是线程不安全的，当线程并发时会创建多个实例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_SingleInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SingleInstance::deleteInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_SingleInstance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_SingleInstance;</span><br><span class="line">        m_SingleInstance = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SingleInstance::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;实例内存地址:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::<span class="built_in">SingleInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::~<span class="built_in">SingleInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////  普通懒汉式实现 -- 线程不安全  //////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程 ID:[&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印实例地址</span></span><br><span class="line">    SingleInstance::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 2 <span class="comment">// 线程个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;thread&gt; thread_group;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建线程:[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        thread_group.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(Print,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        thread_group[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 手动释放单实例的资源</span></span><br><span class="line">    SingleInstance::<span class="built_in">deleteInstance</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="普通懒汉式单例运行结果："><a href="#普通懒汉式单例运行结果：" class="headerlink" title="普通懒汉式单例运行结果："></a>普通懒汉式单例运行结果：</h4><p>从运行结果可知，单例构造函数创建了两个，内存地址分别为0x102c04570和0x102b05670，所以普通懒汉式单例只适合单进程不适合多线程，因为是线程不安全的。<br><img src="/2020/07/19/C-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/2.png" alt></p>
<h3 id="02-加锁的懒汉式单例-（-线程安全-）"><a href="#02-加锁的懒汉式单例-（-线程安全-）" class="headerlink" title="02 加锁的懒汉式单例 （ 线程安全 ）"></a>02 加锁的懒汉式单例 （ 线程安全 ）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////  加锁的懒汉式实现  //////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放单例，进程退出时调用</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印单例地址</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将其构造和析构成为私有的, 禁止外部构造和析构</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>();</span><br><span class="line">    ~<span class="built_in">SingleInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance &amp;signal);</span><br><span class="line">    <span class="type">const</span> SingleInstance &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SingleInstance &amp;signal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 唯一单例对象指针</span></span><br><span class="line">    <span class="type">static</span> SingleInstance *m_SingleInstance;</span><br><span class="line">    <span class="type">static</span> std::mutex m_Mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态成员变量</span></span><br><span class="line">SingleInstance *SingleInstance::m_SingleInstance = <span class="literal">NULL</span>;</span><br><span class="line">std::mutex SingleInstance::m_Mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleInstance* <span class="title">SingleInstance::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  这里使用了两个 if判断语句的技术称为双检锁；好处是，只有判断指针为空的时候才加锁，</span></span><br><span class="line">    <span class="comment">//  避免每次调用 GetInstance的方法都加锁，锁的开销毕竟还是有点大的。</span></span><br><span class="line">    <span class="keyword">if</span> (m_SingleInstance == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Mutex.<span class="built_in">lock</span>(); <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">if</span> (m_SingleInstance == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_SingleInstance = <span class="keyword">new</span> <span class="built_in">SingleInstance</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_Mutex.<span class="built_in">unlock</span>(); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_SingleInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SingleInstance::deleteInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_SingleInstance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_SingleInstance;</span><br><span class="line">        m_SingleInstance = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SingleInstance::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;实例内存地址:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::<span class="built_in">SingleInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::~<span class="built_in">SingleInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////  加锁的懒汉式实现  //////////////////</span></span><br></pre></td></tr></table></figure>
<h4 id="加锁的懒汉式单例的运行结果："><a href="#加锁的懒汉式单例的运行结果：" class="headerlink" title="加锁的懒汉式单例的运行结果："></a>加锁的懒汉式单例的运行结果：</h4><p>从运行结果可知，只创建了一个实例，内存地址是0x10050d300，所以加了互斥锁的普通懒汉式是线程安全的<br><img src="/2020/07/19/C-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/3.png" alt></p>
<h3 id="03-内部静态变量的懒汉单例（C-11-线程安全）"><a href="#03-内部静态变量的懒汉单例（C-11-线程安全）" class="headerlink" title="03 内部静态变量的懒汉单例（C++11 线程安全）"></a>03 内部静态变量的懒汉单例（C++11 线程安全）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////  内部静态变量的懒汉实现  //////////////////</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单实例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印实例地址</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 禁止外部构造</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止外部析构</span></span><br><span class="line">    ~<span class="built_in">SingleInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止外部复制构造</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance &amp;signal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止外部赋值操作</span></span><br><span class="line">    <span class="type">const</span> SingleInstance &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SingleInstance &amp;signal);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleInstance &amp;<span class="title">SingleInstance::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部静态特性的方式实现单实例</span></span><br><span class="line">    <span class="type">static</span> SingleInstance signal;</span><br><span class="line">    <span class="keyword">return</span> signal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SingleInstance::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;实例内存地址:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::<span class="built_in">SingleInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::~<span class="built_in">SingleInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////  内部静态变量的懒汉实现  //////////////////</span></span><br></pre></td></tr></table></figure>
<h4 id="内部静态变量的懒汉单例的运行结果："><a href="#内部静态变量的懒汉单例的运行结果：" class="headerlink" title="内部静态变量的懒汉单例的运行结果："></a>内部静态变量的懒汉单例的运行结果：</h4><p>使用了C++11的特性，在C++11内部静态变量的方式里是线程安全的，只创建了一次实例，内存地址是0x100006168，这个方式非常推荐，实现的代码最少！<br><img src="/2020/07/19/C-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/4.png" alt></p>
<h3 id="04-饿汉式单例-（本身就线程安全）"><a href="#04-饿汉式单例-（本身就线程安全）" class="headerlink" title="04 饿汉式单例 （本身就线程安全）"></a>04 饿汉式单例 （本身就线程安全）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////  普通懒汉式实现 -- 线程不安全 //////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////// 饿汉实现 /////////////////////</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放单实例，进程退出时调用</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印实例地址</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将其构造和析构成为私有的, 禁止外部构造和析构</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>();</span><br><span class="line">    ~<span class="built_in">SingleInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance &amp;signal);</span><br><span class="line">    <span class="type">const</span> SingleInstance &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SingleInstance &amp;signal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 唯一单实例对象指针</span></span><br><span class="line">    <span class="type">static</span> SingleInstance *g_pSingleInstance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码一运行就初始化创建实例 ，本身就线程安全</span></span><br><span class="line">SingleInstance* SingleInstance::g_pSingleInstance = <span class="keyword">new</span> <span class="built_in">SingleInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">SingleInstance* <span class="title">SingleInstance::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g_pSingleInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SingleInstance::deleteInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pSingleInstance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> g_pSingleInstance;</span><br><span class="line">        g_pSingleInstance = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SingleInstance::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;实例内存地址:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::<span class="built_in">SingleInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::~<span class="built_in">SingleInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////////////////////// 饿汉实现 /////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程 ID:[&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印实例地址</span></span><br><span class="line">    SingleInstance::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 2 <span class="comment">// 线程个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;thread&gt; thread_group;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建线程:[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        thread_group.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(Print,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        thread_group[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="饿汉式单例的运行结果："><a href="#饿汉式单例的运行结果：" class="headerlink" title="饿汉式单例的运行结果："></a>饿汉式单例的运行结果：</h4><p>从运行结果可知，饿汉式在程序一开始就构造函数初始化了，所以本身就线程安全的。代码一运行就初始化创建单实例。<br><img src="/2020/07/19/C-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/5.png" alt></p>
<h3 id="特点与选择"><a href="#特点与选择" class="headerlink" title="特点与选择"></a>特点与选择</h3><ul>
<li>懒汉式是以时间换空间，适应于访问量较小时；推荐使用内部静态变量的懒汉单例，代码量少</li>
<li>饿汉式是以空间换时间，适应于访问量较大时，或者线程比较多的的情况</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>C++源文件到可执行文件的过程</title>
    <url>/2020/04/01/C-%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>对于C/C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤：</p>
<p>1、预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。</p>
<p>2、编译：将预处理后的文件转换成汇编语言，生成.s文件</p>
<p>3、汇编：汇编变为目标代码(机器代码)生成.o的文件</p>
<p>4、链接：连接目标代码,生成可执行程序<br><span id="more"></span><br>程序的基本流程如图：</p>
<p><img src="/2020/04/01/C-%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/1.jfif" alt></p>
<p>下面以一个简单的代码执行上述的四个过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; <span class="number">1</span> + pi &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -E test.cc -o test.i</span><br></pre></td></tr></table></figure>
<p>预处理主要包含下面的内容：</p>
<ul>
<li>对所有的“#define”进行宏展开；</li>
<li>处理所有的条件编译指令，比如“#if”,“#ifdef”，“#elif”，“#else”,“#endif”</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归的，也就是说被包含的文件可能还包含其他文件</li>
<li>删除所有的注释“//”和“/**/”</li>
<li>添加行号和文件标识</li>
<li>保留所有的“#pragma”编译器指令</li>
</ul>
<p>注意：</p>
<ul>
<li>若用&lt;&gt;扩起文件则在系统的INCLUDE目录中寻找文件</li>
<li>若用””扩起的文件则在当前目录中寻找文件</li>
</ul>
<p>如下是替换之后的部分文件。</p>
<p><img src="/2020/04/01/C-%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/1.jpg" alt></p>
<p>可以看到文件行数暴增，而且后面的部分没有发生什么变化，前面进行了替换，而且对宏进行了替换。</p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>将预处理完的文件（.i文件）进行一系列词法分析、语法分析、语义分析及优化后，产生相应的汇编代码文件(.s文件)。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -S test.i</span><br></pre></td></tr></table></figure><br>上述命令会生成test.s文件，内容如下，为汇编指令<br><img src="/2020/04/01/C-%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/2.jpg" alt></p>
<h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p>汇编是将汇编代码转变成机器可以执行的代码，每一个汇编语句几乎都对应一条机器指令。最终产生目标文件(.o或.obj文件)。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -c test.s</span><br></pre></td></tr></table></figure><br>这一步生成了.o文件，用vim打开为二进制机器码。<br><img src="/2020/04/01/C-%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/3.jpg" alt></p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>连接目标代码,生成可执行程序。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.o -o test #  -o用于指定生成的文件名，如果不指定-o的话，则会生成a.out文件</span><br></pre></td></tr></table></figure><br>生成二进制文件内容:<br><img src="/2020/04/01/C-%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/4.jpg" alt></p>
<p><strong>程序库</strong></p>
<p>可复用的代码，一般编译成程序库来使用，可以分为两种：</p>
<ol>
<li>静态链接库，在程序编译阶段被链接进可执行程序。一般为.a结尾</li>
<li>动态链接库，不连接进可执行程序，程序记录需要的动态库，运行的时候才搜索加载。采用动态编译库的程序，编译后生成的可执行文件更为短小。一般为.so结尾。</li>
<li>程序启动后需要搜索动态链接库，默认在/lib、/usr/lib等路径下搜索动态库，还可以通过修改LD_LIBRARY_PATH环境变量来指定动态库搜索路径。</li>
<li>静态库和动态库都是由.o文件创建的。</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 重载(overload)、重写(overrride)、重定义(redefine)总结</title>
    <url>/2020/06/25/C-%E9%87%8D%E8%BD%BD-overload-%E3%80%81%E9%87%8D%E5%86%99-overrride-%E3%80%81%E9%87%8D%E5%AE%9A%E4%B9%89-redefine-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这三个概念很重要但是自己容易混淆，就整理记录一下。</p>
<h3 id="一、重载（overload）"><a href="#一、重载（overload）" class="headerlink" title="一、重载（overload）"></a>一、重载（overload）</h3><p>同一作用域内的函数名相同，但是它的参数表列个数或顺序，类型不同，就称之为重载。</p>
<p>（1）相同的范围（在同一个作用域中）；</p>
<p>（2）函数名字相同；</p>
<p>（3）参数不同；</p>
<p>（4）virtual 关键字可有可无；</p>
<p>（5）返回值可以不同；<br><span id="more"></span></p>
<h3 id="二、重写（override）"><a href="#二、重写（override）" class="headerlink" title="二、重写（override）"></a>二、重写（override）</h3><p>是指派生类重新定义基类的虚函数，特征是：</p>
<p>（1）不在同一个作用域（分别位于派生类与基类）；</p>
<p>（2）函数名字相同；</p>
<p>（3）参数相同；</p>
<p>（4）基类函数必须有 virtual 关键字，不能有 static 。</p>
<p>（5）返回值相同（或是协变），否则报错；&lt;—-协变这个概念我也是第一次才知道…</p>
<p>（6）重写函数的访问修饰符可以不同。尽管 virtual 是 private 的，派生类中重写改写为 public,protected 也是可以的</p>
<h3 id="三、重定义（也称为隐藏）"><a href="#三、重定义（也称为隐藏）" class="headerlink" title="三、重定义（也称为隐藏）"></a>三、重定义（也称为隐藏）</h3><p>也叫做隐藏，子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) ，指派生类的函数屏蔽了与其同名的基类函数。可以理解成发生在继承中的重载。</p>
<p>（1）不在同一个作用域（分别位于派生类与基类）；</p>
<p>（2）函数名字相同；</p>
<p>（3）返回值可以不同；</p>
<p>（4）参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载以及重写混淆）。</p>
<p>（5）参数相同，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（注意别与重写混淆（有virtual 就是重写了））。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Base::a(int)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数重载</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Base::a(double)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">b</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Base::b(int)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">c</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Base::c(int)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//函数的重定义 会隐藏父类同名方法 (参数不同)</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Derived::a(char)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数的重写， 覆盖父类的方法 override</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">b</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Derived::b(int)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数的重定义 会隐藏父类同名方法 (参数相同)</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">c</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Derived::c(int)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base B;</span><br><span class="line">    Derived D;</span><br><span class="line">    Base* pb = <span class="keyword">new</span> Derived;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定义 父类的方法已经被隐藏 (参数不同的情形)</span></span><br><span class="line">    D.<span class="built_in">a</span>(<span class="string">&#x27;c&#x27;</span>); <span class="comment">// Derived::a(char)</span></span><br><span class="line">    B.<span class="built_in">a</span>(<span class="number">1</span>); <span class="comment">// Base::a(int)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数重载 (参数类型不同)</span></span><br><span class="line">    B.<span class="built_in">a</span>(<span class="number">1.0</span>);  <span class="comment">// Base::a(double)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基类中 a 不是虚函数没有发生重写，就依旧调用基类</span></span><br><span class="line">    pb-&gt;<span class="built_in">a</span>(<span class="number">1.0</span>); <span class="comment">// Base::a(double)</span></span><br><span class="line"></span><br><span class="line">    B.<span class="built_in">b</span>(<span class="number">1</span>); <span class="comment">// Base::b(int)</span></span><br><span class="line">    D.<span class="built_in">b</span>(<span class="number">1</span>); <span class="comment">// Derived::b(int)</span></span><br><span class="line">    <span class="comment">// b 是虚函数，在派生类中发生重写</span></span><br><span class="line">    pb-&gt;<span class="built_in">b</span>(<span class="number">1</span>); <span class="comment">// Derived::b(int)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码输出结果：<br><img src="/2020/06/25/C-%E9%87%8D%E8%BD%BD-overload-%E3%80%81%E9%87%8D%E5%86%99-overrride-%E3%80%81%E9%87%8D%E5%AE%9A%E4%B9%89-redefine-%E6%80%BB%E7%BB%93/1.png" alt></p>
<p>通过这个实例可以看出：</p>
<ol>
<li><p>Base类中的第二个函数a是对第一个的重载</p>
</li>
<li><p>Derived类中的函数b是对Base类中函数b的重写，即使用了虚函数特性。</p>
</li>
<li><p>Derived类中的函数a是对Base类中函数a的隐藏，即重定义了。</p>
</li>
<li><p>pb指针是一个指向Base类型的指针，但是它实际指向了一个Derived的空间，这里对pd调用函数的处理(多态性)取决于是否重写(虚函数特性)了函数，若没有，则依然调用基类。</p>
</li>
<li><p>只有在通过基类指针或基类引用 间接指向派生类类型时多态性才会起作用。</p>
</li>
<li><p>因为Base类的函数c没有定义为virtual虚函数，所以Derived类的函数c是对Base::c()的重定义。</p>
</li>
</ol>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol>
<li>cnblogs.com/tanky_woo/archive/2012/02/08/2343203.html</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++虚函数与纯虚函数区别和重载的概念</title>
    <url>/2020/04/04/C-%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>虚函数是在类中添加函数的修饰关键字“Virtual”，且对它进行定义，这时函数变被指定为虚函数。格式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CInterFace</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func_Virtual</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><span id="more"></span></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。</p>
<h3 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h3><p>为了方便使用多态特性，常常需要在基类中定义虚函数。下面顺便列出C++实现多态的三个条件：</p>
<p>（1）在基类中将这些成员函数声明为虚函数，并实现（必须要实现）。</p>
<p>（2）在派生类中也声明这些成员函数并实现（必须实现），基类和派生类的这些函数必须同名，而且其形参个数和类型，返回值类型必须与基类中的这些函数完全相同。</p>
<p>（3）将派生类对象赋给基类的指针变量或者引用。至此，多态实现，可用基类指针或引用调用派生类的方法（符合多态条件的方法，而不是普通方法）。</p>
<p>相应的不是多态的情况：</p>
<p>（1）基类中声明为虚函数，派生类中也声明为虚函数，并且也同名。但是派生类中该函数的形参类型或者形参个数和基类中的不相同。此时，多态不满足，派生类和基类的这两个虚函数仅仅是隐藏关系，没有虚特性。</p>
<p>（2）基类中声明为虚函数，派生类中也声明了一个同名函数，但没有使用virtual，并且形参类型或者形参个数和基类不相同。这时候基类中的虚函数也丢失虚特性，派生类的该函数不会被虚化，当然也就够不成多态，这两个函数也仅仅是隐藏关系。</p>
<p>（3）基类中的函数不是虚函数，派生类中声明为虚函数，它们同名，这时也够不成多态，派生类的虚函数没有虚特性，它们也是隐藏关系。</p>
<p>（4）基类和派生类的两个函数同名，都是虚函数，形参的个数和类型也都相同，但是返回值类型不同，这时编译会报错，因为两个虚函数在隐藏时，返回值类型发生了冲突，因此隐藏发生错误。注意，如果这两个函数不是虚函数，这不会报错，隐藏会成功；同时，如果派生类中是虚函数，基类中不是虚函数，也不过报错，隐藏也是成功的。这也说明，虚化并隐藏时，返回值类型一定要保持相同。</p>
<h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>是通过虚函数表机制来实现的，当类中存在虚函数时，编译器会在类中自动生成一个虚函数表，并由编译器自动生成和维护，virtual 修饰的成员函数会被编译器放入虚函数表中。</p>
<p>虚表指针：指向自己所使用的虚表</p>
<p>虚函数表:虚函数表是顺序存放虚函数地址的，虚表是顺序表，表里存放了虚函数的地址。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>纯虚函数是在基类中声明的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。</p>
<p>在基类中实现纯虚函数的方法是在函数原型后加“=0”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CInterFace</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func_PureVirtual</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。包含纯虚函数的类叫做抽象类（ 也叫接口类） ， 抽象类不能实例化出对象。 纯虚函数在派生类中重新定义以后， 派生类才能实例化出对象。</p>
<h2 id="虚函数和纯虚函数总结"><a href="#虚函数和纯虚函数总结" class="headerlink" title="虚函数和纯虚函数总结"></a>虚函数和纯虚函数总结</h2><ol>
<li><p>虚函数的定义形式：virtual {method body}   纯虚函数的定义形式：virtual { } = 0;</p>
</li>
<li><p>虚函数和纯虚函数可定义在同一个类(class)中，含有纯虚函数的类是抽象类(abstract class)，而含有虚函数的类则不是。</p>
</li>
<li><p>虚函数可以被直接使用，也可以被子类(sub class)重载以后以多态的形式调用，而纯虚函数必须在子类(sub class)中实现该函数才可以使用，因为纯虚函数在基类(base class)只有声明而没有定义。</p>
</li>
<li><p>在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时候要求前期bind,然而虚函数却是动态绑定(run-time bind)，而且被两者修饰的函数生命周期(life recycle)也不一样。</p>
</li>
</ol>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>就是函数或者方法有相同的名称，但是参数列表不同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。</p>
<p>重载的规则：<br>   1、在使用重载时只能通过相同的方法名、不同的参数形式实现。不同的参数可以是参数类型，参数个数，参数顺序（参数类型必须不一样）；</p>
<p>   2、不能通过访问权限、返回类型、抛出的异常进行重载；</p>
<p>   3、方法的异常类型和数目不会对重载造成影响；</p>
<p>成员函数被重载的特征：</p>
<p>（1）相同的范围（在同一个类中）； </p>
<p>（2）函数名字相同； </p>
<p>（3）参数不同； </p>
<p>（4）virtual 关键字可有可无 。</p>
<p><strong>函数重载在同一个作用域内。</strong>，重载绝对不会发生在基类和派生类之间，在同一个类中，重载函数之间必须依靠形参个数或者形参类型来进行区分，不能依靠返回类型。</p>
<h3 id="函数重载与虚函数的区别"><a href="#函数重载与虚函数的区别" class="headerlink" title="函数重载与虚函数的区别"></a>函数重载与虚函数的区别</h3><p>1.函数重载可以用于非成员函数和类的成员函数，而虚函数只能用于类的成员函数</p>
<p>2.函数重载可用于构造函数，而虚函数不能用于构造函数</p>
<p>3.如果对成员函数进行重载，重载的函数与被重载的函数应该是用一个类中的成员函数，不能分属于两个不同继承层次的类，函数重载处理的是横向的重载。虚函数是对同一类族中的基类和派生类的同名函数的处理，即允许在派生类中对基类的成员函数重新定义。虚函数处理的是纵向的同名函数。</p>
<p>4.重载的函数必须具有相同的函数名，函数类型可以相同也可以不同，但函数的参数个数和参数类型二者中至少有一个不同，否则在编译时无法区分。而虚函数则要求同一类族中的所有虚函数的函数名，函数类型，函数的参数个数和参数类型都全部相同，否则就不是重定义了，也就不是虚函数了</p>
<p>5.函数重载是在程序编译阶段确定操作的对象的，属于静态关联。虚函数是在程序运行阶段确定操作对象的，属于动态关联。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>RoaringBitmap原理 &amp; CRoaring源码解读</title>
    <url>/2023/12/29/CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="RoaringBitMap原理"><a href="#RoaringBitMap原理" class="headerlink" title="RoaringBitMap原理"></a>RoaringBitMap原理</h2><p>Roaring Bitmap实现的主要思路是将32位无符号整数（0~4294967295）分成高16位和低16位两部分。通过高 16 位找到该数据存储在哪个桶中（高 16 位可以划分 2<sup>16</sup>个桶），把剩余的低 16 位放入该桶对应的 Container 中。<br>每个桶都有对应的 Container，不同的 Container 存储方式不同。依据不同的场景，主要有 2 种不同的 Container，分别是 Array Container 和 Bitmap Container。Array Container 存放稀疏的数据，Bitmap Container 存放稠密的数据。若一个 Container 里面的元素数量小于 4096，使用 Array Container 来存储。当 Array Container 超过最大容量 4096 时，会转换为 Bitmap Container。<br><span id="more"></span><br>简单举2个例子，说明rbm是如何存储数据的。</p>
<p>例1：0x00020032（十进制131122）放入一个 RBM 的过程如下图所示：</p>
<p>131122 的高 16 位是 0002，找到对应的桶 0x0002。在桶对应的 Container 中存储低 16 位，因为 Container 元素个数不足 4096，因此是一个 Array Container。低 16 位为 0032（十进制为50）, 在 Array Container 中二分查找找到相应的位置插入即可（如上图50的位置）。相较于纯Bitmap 需要占用 16K (131122/8/1024) 内存来存储这个数，而这种存储实际只占用了4B（桶中占 2 B，Container中占 2 B，不考虑数组的初始容量）。</p>
<p>例2：0xFFFF3ACB（十进制4294916811）放入一个 RBM 的过程如下图所示：</p>
<p>4294916811 的高 16 位是 FFFF，找到对应的桶 0xFFFF。在桶对应的 Container 中存储低 16 位，因为 Container 中元素个数已经超过 4096，底层是一个 Bitmap Container。低 16 位为 3ACB（十进制为15051）, 因此在 Bitmap Container 中通过下标直接寻址找到相应的位置，将其置为 1 即可（如上图15051的位置）。由于每个 Bitmap Container 需要处理低 16 位数据，使用 Bitmap 来存储需要 8192 Bytes（2^16/8）, 而一个 long 值占 8 个 Bytes，所以数组大小为 1024。因此一个 Bitmap Container 固定占用内存 8 KB。</p>
<h2 id="RoaringBitmap数据结构"><a href="#RoaringBitmap数据结构" class="headerlink" title="RoaringBitmap数据结构"></a>RoaringBitmap数据结构</h2><p>RoaringBitmap的基本构成如下:首先是一个RoaringArray，名字是high_low_container，该结构中存储了每个uint32整数的高16bit的索引keys以及具体存储数字的container。</p>
<h3 id="RoaringArray"><a href="#RoaringArray" class="headerlink" title="RoaringArray"></a>RoaringArray</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">roaring_bitmap_s</span> &#123;</span><br><span class="line">    <span class="type">roaring_array_t</span> high_low_container;</span><br><span class="line">&#125; <span class="type">roaring_bitmap_t</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">roaring_array_s</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> size;</span><br><span class="line">    <span class="type">int32_t</span> allocation_size;</span><br><span class="line">    ROARING_CONTAINER_T **containers;  <span class="comment">// Use container_t in non-API files!</span></span><br><span class="line">    <span class="type">uint16_t</span> *keys;</span><br><span class="line">    <span class="type">uint8_t</span> *typecodes;</span><br><span class="line">    <span class="type">uint8_t</span> flags;</span><br><span class="line">&#125; <span class="type">roaring_array_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>roaring_array：每个RBM都包含了一个roaring_array，名字是high_low_container，该结构主要有下面几个重要属性：<ul>
<li>keys：short数组，用来存储高16位作为索引</li>
<li>containers：container数组，用来存储低16位数据</li>
<li>typecodes：可理解为container type的数组，标识container的类型</li>
<li>size：可理解为rbm包含的key-value有效数量</li>
</ul>
</li>
</ul>
<p>PS：keys数组和containers数组是一一对应的，且keys永远保证有序，这是为了之后索引的二分查找</p>
<h3 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h3><p>Container用于存储低16位的数据，根据数据量以及疏密程度分为以下3个容器：</p>
<ul>
<li>ArrayContainer</li>
<li>BitmapContainer</li>
<li>RunContainer</li>
</ul>
<h4 id="1、ArrayContainer"><a href="#1、ArrayContainer" class="headerlink" title="1、ArrayContainer"></a>1、ArrayContainer</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ArrayContainer允许的最大数据量</span></span><br><span class="line"><span class="keyword">enum</span> &#123; DEFAULT_MAX_SIZE = <span class="number">4096</span> &#125;;<span class="comment">/* Containers with DEFAULT_MAX_SIZE or less integers should be arrays */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct array_container - sparse representation of a bitmap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @cardinality: number of indices in `array` (and the bitmap)</span></span><br><span class="line"><span class="comment"> * @capacity:    allocated size of `array`</span></span><br><span class="line"><span class="comment"> * @array:       sorted list of integers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">STRUCT_CONTAINER</span>(array_container_s) &#123;</span><br><span class="line">    <span class="type">int32_t</span> cardinality;</span><br><span class="line">    <span class="type">int32_t</span> capacity;</span><br><span class="line">    <span class="type">uint16_t</span> *array;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Array Container 是 Roaring Bitmap 初始化默认的 Container。Array Container 适合存放稀疏的数据，其内部数据结构是一个<strong>有序的 short 数组</strong>。数组初始容量为 4，数组最大容量为 4096，存储元素始终有序，方便二分查找，<strong>查询复杂度O(logn)</strong></p>
<h4 id="2、BitmapContainer"><a href="#2、BitmapContainer" class="headerlink" title="2、BitmapContainer"></a>2、BitmapContainer</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BITSET_CONTAINER_SIZE_IN_WORDS = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) / <span class="number">64</span>,</span><br><span class="line">    BITSET_UNKNOWN_CARDINALITY = <span class="number">-1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">STRUCT_CONTAINER</span>(bitset_container_s) &#123;</span><br><span class="line">    <span class="type">int32_t</span> cardinality;</span><br><span class="line">    <span class="type">uint64_t</span> *words;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BitmapContainer采用<strong>long数组</strong>存储低16位数据，这就是一个未压缩的普通Bitmap，每一个bit位置代表一个数字。每一个Container最多可以处理2<sup>16</sup>个数字，基于位图的原理需要2<sup>16</sup>个bit，每个long是8字节64bit，所以数组大小是2<sup>16</sup>/64=1024，始终<strong>占据8kb</strong>的空间，<strong>查询复杂度O(1)</strong></p>
<h4 id="3、RunContainer"><a href="#3、RunContainer" class="headerlink" title="3、RunContainer"></a>3、RunContainer</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* struct rle16_s - run length pair</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @value:  start position of the run</span></span><br><span class="line"><span class="comment"> * @length: length of the run is `length + 1`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An RLE pair &#123;v, l&#125; would represent the integers between the interval</span></span><br><span class="line"><span class="comment"> * [v, v+l+1], e.g. &#123;3, 2&#125; = [3, 4, 5].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rle16_s</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> value;</span><br><span class="line">    <span class="type">uint16_t</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct run_container_s - run container bitmap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @n_runs:   number of rle_t pairs in `runs`.</span></span><br><span class="line"><span class="comment"> * @capacity: capacity in rle_t pairs `runs` can hold.</span></span><br><span class="line"><span class="comment"> * @runs:     pairs of rle_t.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">STRUCT_CONTAINER</span>(run_container_s) &#123;</span><br><span class="line">    <span class="type">int32_t</span> n_runs;</span><br><span class="line">    <span class="type">int32_t</span> capacity;</span><br><span class="line">    <span class="type">rle16_t</span> *runs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要解决了连续1的情况，例如15、16、17、18可以被优化成15,3。RunContainer中的关键变量为value，length，类型是short。其中，value是具体数值，length为value往后的连续个数。</p>
<p>例如：3,4,5,10,20,21,22,23这样一组数据会被优化成3,2,10,0,20,3，原理就是记录初始数字以及连续的数量，并把压缩后的数据记录在short数组中。这种压缩方式对于数据的疏密程度非常敏感，举两个最极端的例子：如果这个Container中所有数据都是连续的，也就是[0,1,2…..65535]，压缩后为0,65535，即2个short，4字节。若这个container中所有数据都是间断的（都是偶数或奇数），也就是[0,2,4,6….65532,65534]，压缩后为0,0,2,0…..65534,0，这不仅没有压缩反而膨胀了一倍，65536个short，即128kb</p>
<p>因此是否选择RunContainer是需要判断的，RBM提供了一个转化方法runOptimize()用于对比和其他两种Container的空间大小，若占据优势则会进行转化。</p>
<p><strong>各个Container之间比较如下</strong>：</p>
<p><strong>1. 读取时间</strong></p>
<p>只有BitmapContainer可根据下标直接寻址，复杂度为O(1)，ArrayContainer和RunContainer都需要二分查找，复杂度O(log n)</p>
<p><strong>2. 内存占用</strong></p>
<h3 id="RoaringBitmap源码分析"><a href="#RoaringBitmap源码分析" class="headerlink" title="RoaringBitmap源码分析"></a>RoaringBitmap源码分析</h3><p>CRoaring源码：<a href="https://github.com/RoaringBitmap/CRoaring">https://github.com/RoaringBitmap/CRoaring</a></p>
<h4 id="1、Add"><a href="#1、Add" class="headerlink" title="1、Add"></a>1、Add</h4><p>Add大致流程：</p>
<ol>
<li>二分判断新加的Value的高16位是否存在，不存在新建一个ArrayContainer，然后添加低16位数值即可</li>
<li><p>若存在，确定低16位Container位置后，判断对应Container的类型：<br> a. Array Container：</p>
<pre><code> i. 通过二分查找Value低16位所在的ArrayContainer中的位置，若存在说明已经添加了则不处理
 ii. 不存在则对元素容量Cardinality进行判断，决定是否需要扩容或者升级为BitmapContainer
 iii. 将ArrayContainer中insert_idx之后的子数组后移一位，将数据插入，形成新的Array数组
</code></pre><p> b. Bitmap Container</p>
<pre><code> i. 通过pos/64找到bitmap中的long数组中的位置得到原值old_word
 ii. old_word | (1 &lt;&lt; (pos%64) ) 得到new_word并赋值
 iii. 更新Cardinality
</code></pre><p>高16位<br>void roaring_bitmap_add(roaring_bitmap_t <em>r, uint32_t val) {<br> roaring_array_t </em>ra = &amp;r-&gt;high_low_container;</p>
<pre><code> // 获取待插入数val的高16位
</code></pre><p> const uint16_t hb = val &gt;&gt; 16;<br> // 计算高16位对应的索引值的下标位置(底层是个二分查找)<br> const int i = ra_get_index(ra, hb);<br> uint8_t typecode;</p>
<pre><code>// 索引下标大于0说明该索引已存在且创建了对应的Container，则将低16位存入该Container中
</code></pre><p> if (i &gt;= 0) {</p>
<pre><code> ra_unshare_container_at_index(ra, i);
 container_t *container =
     ra_get_container_at_index(ra, i, &amp;typecode);
 uint8_t newtypecode = typecode;
 container_t *container2 =
     container_add(container, val &amp; 0xFFFF, typecode, &amp;newtypecode);
 if (container2 != container) &#123;
     container_free(container, typecode);
     ra_set_container_at_index(&amp;r-&gt;high_low_container, i, container2,
                               newtypecode);
 &#125;
</code></pre><p> } else {</p>
<pre><code>   // 若索引下标小于0说明该索引不存在，则直接创建一个ArrayContainer并将低16位放入其中
 array_container_t *newac = array_container_create();
 container_t *container = container_add(newac, val &amp; 0xFFFF,
                                 ARRAY_CONTAINER_TYPE, &amp;typecode);
 // we could just assume that it stays an array container
 ra_insert_new_key_value_at(&amp;r-&gt;high_low_container, -i - 1, hb,
                            container, typecode);
</code></pre><p> }<br>}<br>Array Container Add<br>/**</p>
<ul>
<li>Add value to the set if final cardinality doesn’t exceed max_cardinality.</li>
<li>Return code:</li>
<li>1  — value was added</li>
<li>0  — value was already present</li>
<li><p>-1 — value was not added because cardinality would exceed max_cardinality<br><em>/<br>static inline int array_container_try_add(array_container_t </em>arr, uint16_t value,</p>
<pre><code>                                 int32_t max_cardinality) &#123;
</code></pre><p>const int32_t cardinality = arr-&gt;cardinality;</p>
<p>// best case, we can append.<br> // 两种场景可以不走二分查找：<br> // 1、基数为0<br>// 2、当前值大于容器中的最大值，因为array是有序的，最后一个即最大值<br>if ((array_container_empty(arr) || arr-&gt;array[cardinality - 1] &lt; value) &amp;&amp;<br>   cardinality &lt; max_cardinality) {<br>   array_container_append(arr, value);<br>   return 1;<br>}</p>
<p>   // 通过二分查找找到对应的插入位置<br>const int32_t loc = binarySearch(arr-&gt;array, cardinality, value);</p>
<p>// 存在则不处理直接返回（去重效果）<br>if (loc &gt;= 0) {<br>   return 0;<br>} else if (cardinality &lt; max_cardinality) {</p>
<pre><code> // 判断是否需要扩容
</code></pre><p>   if (array_container_full(arr)) {</p>
<pre><code>   array_container_grow(arr, arr-&gt;capacity + 1, true);
</code></pre><p>   }<br>   const int32_t insert_idx = -loc - 1;<br>   // 通过拷贝数组将val插入array数组<br>   memmove(arr-&gt;array + insert_idx + 1, arr-&gt;array + insert_idx,</p>
<pre><code>       (cardinality - insert_idx) * sizeof(uint16_t));
</code></pre><p>   arr-&gt;array[insert_idx] = value;<br>   arr-&gt;cardinality++;<br>   return 1;<br>} else {</p>
<pre><code> //容量大于等于4096需转化为BitmapContainer，返回-1
</code></pre><p>   return -1;<br>}<br>}<br>add流程：<br>1、通过二分查找找到val所在的array中的位置，若存在则不处理，不存在则进入下一步。<br>2、对cardinality进行判断，决定是否需要升级为BitmapContainer或者扩容。<br>3、将array中insert_idx之后的子数组后移一位，将数据插入，形成新的Array数组。<br>Bitmap Container Add<br>// file contains grubby stuff that must know impl. details of all container<br>// types.<br>bitset_container_t <em>bitset_container_from_array(const array_container_t </em>ac) {<br>bitset_container_t *ans = bitset_container_create();<br> // 获取array container的cardinality<br>int limit = array_container_cardinality(ac);<br>for (int i = 0; i &lt; limit; ++i) bitset_container_set(ans, ac-&gt;array[i]);<br>return ans;<br>}</p>
</li>
</ul>
</li>
</ol>
<p>…</p>
<p>/<em> Set the ith bit.  </em>/<br>static inline void bitset_container_set(bitset_container_t *bitset,<br>                                        uint16_t pos) {<br>    uint64_t shift = 6;<br>    uint64_t offset;<br>    uint64_t p = pos;<br>    // 利用汇编指令右移6位，相当于/64，目的是找到第几个long<br>    ASM_SHIFT_RIGHT(p, shift, offset);<br>    uint64_t load = bitset-&gt;words[offset];<br>      // 找到对应的long的旧值，对应位置set为1后，与旧值取或得到新值<br>    ASM_SET_BIT_INC_WAS_CLEAR(load, p, bitset-&gt;cardinality);<br>    bitset-&gt;words[offset] = load;<br>}</p>
<p>/* Add <code>pos&#39; to</code>bitset’. Returns true if `pos’ was not present. Might be slower</p>
<ul>
<li>than bitset_container_set.  <em>/<br>static inline bool bitset_container_add(bitset_container_t </em>bitset,<pre><code>                                 uint16_t pos) &#123;
</code></pre>   // 右移6位，取到对应long数组的旧值<br> const uint64_t old_word = bitset-&gt;words[pos &gt;&gt; 6];<br>   // 相当于%63，取到是long的第几位<br> const int index = pos &amp; 63;<br>   // 按位或得到新值<br> const uint64_t new_word = old_word | (UINT64_C(1) &lt;&lt; index);<br> const uint64_t increment = (old_word ^ new_word) &gt;&gt; index;<br> bitset-&gt;cardinality += (uint32_t)increment;<br> bitset-&gt;words[pos &gt;&gt; 6] = new_word;<br> return increment &gt; 0;<br>}</li>
</ul>
<p>add流程：<br>1、通过pos/64找到bitmap中的long数组中的位置得到原值old_word。<br>2、old_word | (1 &lt;&lt; (pos%64) ) 得到new_word。<br>3、改变cardinality。<br>2、And<br>And流程：</p>
<ol>
<li>获取high_low_container，判断keys数组中元素是否相等，即判断高16位</li>
<li><p>在高16位元素相等的情况下，去判断对应Container中存储的低16位元素：<br> a. Bitmap Container &amp; Bitmap Container</p>
<pre><code> i. 快速获取两个Bitmap求交后的元素个数（底层AVX2指令集优化）
 ii. 若求交后元素个数大于4096，用Bitmap Container存储，否则用Array Container存储。
</code></pre><p> b. Array Container &amp; Array Container</p>
<pre><code> i. 计算结果集的cardinality的上限，并初始化
 ii. 两个Array Container元素相差较大，差距大于64倍的时候，会调用intersect_skewed_uint16，步长为2的幂次方的形式递增，加速跳过不相交的元素。如果相差不大的时候，调用intersect_uint16步长为1进行比较（底层就是两个有序数组求交集） 或者intersect_vector16进行AVX2指令集加速
</code></pre><p> c. Bitmap Container &amp; Array Container</p>
<pre><code> i. 给结果数组dst申请扩容，初始长度为Array Container的array的长度
 ii. for循环遍历Array Container，依次其中的元素是否在Bitmap Container中存在，如果存在的话，则更新到结果answer中，并更新Cardinality。
</code></pre><p> d. Array Container &amp; Bitmap Container</p>
<pre><code> i. 同上
</code></pre><p>高16位<br>roaring_bitmap_t <em>roaring_bitmap_and(const roaring_bitmap_t </em>x1,</p>
<pre><code>                              const roaring_bitmap_t *x2) &#123;
</code></pre><p> uint8_t result_type = 0;<br> // 获取两个rbm的对应high_low_container的size<br> const int length1 = x1-&gt;high_low_container.size,</p>
<pre><code>       length2 = x2-&gt;high_low_container.size;
</code></pre><p> // 取两者较小的length<br> uint32_t neededcap = length1 &gt; length2 ? length2 : length1;<br>   // 构建一个新的answer rbm<br> roaring_bitmap_t *answer = roaring_bitmap_create_with_capacity(neededcap);<br> roaring_bitmap_set_copy_on_write(answer, is_cow(x1) &amp;&amp; is_cow(x2));</p>
<p> int pos1 = 0, pos2 = 0;</p>
<p> while (pos1 &lt; length1 &amp;&amp; pos2 &lt; length2) {</p>
<pre><code> const uint16_t s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);
 const uint16_t s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);
   // 高16位相等
 if (s1 == s2) &#123;
     uint8_t type1, type2;
       // 获取对应的container
     container_t *c1 = ra_get_container_at_index(
                             &amp;x1-&gt;high_low_container, pos1, &amp;type1);
     container_t *c2 = ra_get_container_at_index(
                             &amp;x2-&gt;high_low_container, pos2, &amp;type2);
     // 两个container之间求and
     container_t *c = container_and(c1, type1, c2, type2, &amp;result_type);

     if (container_nonzero_cardinality(c, result_type)) &#123;
         ra_append(&amp;answer-&gt;high_low_container, s1, c, result_type);
     &#125; else &#123;
         container_free(c, result_type);  // otherwise: memory leak!
     &#125;
     ++pos1;
     ++pos2;
 &#125; else if (s1 &lt; s2) &#123;  // s1 &lt; s2
       // 底层是二分查找，找到第一个x1中的第一个大于等于s2的位置
     pos1 = ra_advance_until(&amp;x1-&gt;high_low_container, s2, pos1);
 &#125; else &#123;  // s1 &gt; s2
     pos2 = ra_advance_until(&amp;x2-&gt;high_low_container, s1, pos2);
 &#125;
</code></pre><p> }<br> return answer;<br>}<br>低16位<br>static inline container_t <em>container_and(<br> const container_t </em>c1, uint8_t type1,<br> const container_t <em>c2, uint8_t type2,<br> uint8_t </em>result_type<br>){<br> c1 = container_unwrap_shared(c1, &amp;type1);<br> c2 = container_unwrap_shared(c2, &amp;type2);<br> container_t *result = NULL;<br> // 不同container之间的组合<br> switch (PAIR_CONTAINER_TYPES(type1, type2)) {</p>
<pre><code>     // 1、两个Bitmap Container 求交
 case CONTAINER_PAIR(BITSET,BITSET):
     *result_type = bitset_bitset_container_intersection(
                         const_CAST_bitset(c1),
                         const_CAST_bitset(c2), &amp;result)
                             ? BITSET_CONTAINER_TYPE
                             : ARRAY_CONTAINER_TYPE;
     return result;
 // 2、两个Array Container 求交
 case CONTAINER_PAIR(ARRAY,ARRAY):
     result = array_container_create();
     array_container_intersection(const_CAST_array(c1),
                                  const_CAST_array(c2),
                                  CAST_array(result));
     *result_type = ARRAY_CONTAINER_TYPE;  // never bitset
     return result;
 // 3、两个Run Container 求交
 case CONTAINER_PAIR(RUN,RUN):
     result = run_container_create();
     run_container_intersection(const_CAST_run(c1),
                                const_CAST_run(c2),
                                CAST_run(result));
     return convert_run_to_efficient_container_and_free(
                 CAST_run(result), result_type);

 // 4、Bitmap Container 和 Array Container求交
 case CONTAINER_PAIR(BITSET,ARRAY):
     result = array_container_create();
     array_bitset_container_intersection(const_CAST_array(c2),
                                         const_CAST_bitset(c1),
                                         CAST_array(result));
     *result_type = ARRAY_CONTAINER_TYPE;  // never bitset
     return result;
 // 5、Array Container 和 Bitmap Container求交
 case CONTAINER_PAIR(ARRAY,BITSET):
     result = array_container_create();
     *result_type = ARRAY_CONTAINER_TYPE;  // never bitset
     array_bitset_container_intersection(const_CAST_array(c1),
                                         const_CAST_bitset(c2),
                                         CAST_array(result));
     return result;
 ...

 default:
     assert(false);
     __builtin_unreachable();
     return NULL;
</code></pre><p> }<br>}<br>Bitmap Container &amp; Bitmap Container<br>两个Bitmap Container求And流程：<br>1、快速获取两个Bitmap求交后的元素个数<br>2、若求交后元素个数大于4096，用Bitmap Container存储，否则用Array Container存储。<br>bool bitset_bitset_container_intersection(<br> const bitset_container_t <em>src_1, const bitset_container_t </em>src_2,<br> container_t **dst<br>){</p>
<pre><code> // 计算两个bitmap求交后的元素个数（avx2指令集优化）
</code></pre><p> const int newCardinality = bitset_container_and_justcard(src_1, src_2);<br> // 求交后元素个数大于4096<br> if (newCardinality &gt; DEFAULT_MAX_SIZE) {</p>
<pre><code>     // 创建一个新的bitmap container
 *dst = bitset_container_create();
 if (*dst != NULL) &#123;
         // 成为
     bitset_container_and_nocard(src_1, src_2, CAST_bitset(*dst));
     CAST_bitset(*dst)-&gt;cardinality = newCardinality;
 &#125;
 return true;  // it is a bitset
</code></pre><p> }<br> <em>dst = array_container_create_given_capacity(newCardinality);<br> if (</em>dst != NULL) {</p>
<pre><code> CAST_array(*dst)-&gt;cardinality = newCardinality;
 // 两个Bitmap Container求交集，并输出到数组
 bitset_extract_intersection_setbits_uint16(
     src_1-&gt;words, src_2-&gt;words, BITSET_CONTAINER_SIZE_IN_WORDS,
     CAST_array(*dst)-&gt;array, 0);
</code></pre><p> }<br> return false;  // not a bitset<br>}</p>
</li>
</ol>
<p>// 将两个Bitmap的交集输出到数组，复杂度为二进制中1的位数。<br>size<em>t bitset<em>extract<em>intersection<em>setbits_uint16(const uint64_t * __restrict</em></em> words1,<br>                                                  const uint64_t * __restrict</em></em> words2,<br>                                                  size_t length, uint16_t <em>out,<br>                                                  uint16_t base) {<br>    int outpos = 0;<br>    for (size_t i = 0; i &lt; length; ++i) {<br>          // 求交<br>        uint64_t w = words1[i] &amp; words2[i];<br>        while (w != 0) {<br>              // 获取最低位的1<br>            uint64_t t = w &amp; (~w + 1);<br>              // 获取有多少个0<br>            int r = __builtin_ctzll(w);<br>              // 后边有几个0就表示真正的数字几<br>            out[outpos++] = r + base;<br>              // 异或，便于取下一个1<br>            w ^= t;<br>        }<br>        base += 64;<br>    }<br>    return outpos;<br>}<br>Array Container &amp; Array Container<br>两个Array Container求And流程：<br>1、首先计算结果集的cardinality的上限，并初始化<br>2、两个Array Container元素相差较大，差距大于64倍的时候，会调用intersect_skewed_uint16，步长为2的幂次方的形式递增，加速跳过不相交的元素。如果相差不大的时候，调用intersect_uint16步长为1进行比较（底层就是两个有序数组求交集） 或者intersect_vector16进行avx2指令集加速。<br>void array_container_intersection(const array_container_t </em>array1,<br>                                  const array_container_t <em>array2,<br>                                  array_container_t </em>out) {<br>    int32_t card_1 = array1-&gt;cardinality, card_2 = array2-&gt;cardinality,<br>            min_card = minimum_int32(card_1, card_2);<br>    const int threshold = 64;  // subject to tuning</p>
<h1 id="ifdef-CROARING-IS-X64"><a href="#ifdef-CROARING-IS-X64" class="headerlink" title="ifdef CROARING_IS_X64"></a>ifdef CROARING_IS_X64</h1><pre><code>if (out-&gt;capacity &lt; min_card) &#123;
  // 申请扩容
  array_container_grow(out, min_card + sizeof(__m128i) / sizeof(uint16_t),
    false);
&#125;
</code></pre><h1 id="else"><a href="#else" class="headerlink" title="else"></a>else</h1><pre><code>if (out-&gt;capacity &lt; min_card) &#123;
  array_container_grow(out, min_card, false);
&#125;
</code></pre><h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><pre><code>    // 两个Array Container元素相差较大，64倍的时候
  // 步长为2的幂次方的形式递增，可以加速跳过不相交的元素
if (card_1 * threshold &lt; card_2) &#123;
    out-&gt;cardinality = intersect_skewed_uint16(
        array1-&gt;array, card_1, array2-&gt;array, card_2, out-&gt;array);
&#125; else if (card_2 * threshold &lt; card_1) &#123;
    out-&gt;cardinality = intersect_skewed_uint16(
        array2-&gt;array, card_2, array1-&gt;array, card_1, out-&gt;array);
&#125; else &#123;
  // 如果两个Array Container的元素相差不大的时候，
  // 调用intersect_uint16步长为1进行比较（底层就是两个有序数组求交集） 
  // 或者intersect_vector16内部指令集加速
</code></pre><h1 id="ifdef-CROARING-IS-X64-1"><a href="#ifdef-CROARING-IS-X64-1" class="headerlink" title="ifdef CROARING_IS_X64"></a>ifdef CROARING_IS_X64</h1><pre><code>   if( croaring_avx2() ) &#123;
    out-&gt;cardinality = intersect_vector16(
        array1-&gt;array, card_1, array2-&gt;array, card_2, out-&gt;array);
   &#125; else &#123;
    out-&gt;cardinality = intersect_uint16(array1-&gt;array, card_1,
                                        array2-&gt;array, card_2, out-&gt;array);
   &#125;
</code></pre><h1 id="else-1"><a href="#else-1" class="headerlink" title="else"></a>else</h1><pre><code>    out-&gt;cardinality = intersect_uint16(array1-&gt;array, card_1,
                                        array2-&gt;array, card_2, out-&gt;array);
</code></pre><h1 id="endif-1"><a href="#endif-1" class="headerlink" title="endif"></a>endif</h1><pre><code>&#125;
</code></pre><p>}<br>Bitmap Container &amp; Array Container<br>Bitmap Container 和 Array Container And流程：<br>1、首先，给dst申请扩容，初始长度为ArrayContainer的array的长度<br>2、然后for循环遍历ArrayContainer，依次其中的元素是否在BitmapContainer中存在，如果存在的话，则更新到结果answer中，并增加cardinality。void array_bitset_container_intersection(const array_container_t <em>src_1,<br>                                         const bitset_container_t </em>src_2,<br>                                         array_container_t *dst) {<br>    if (dst-&gt;capacity &lt; src_1-&gt;cardinality) {<br>        array_container_grow(dst, src_1-&gt;cardinality, false);<br>    }<br>    int32_t newcard = 0;  // dst could be src_1<br>    const int32_t origcard = src_1-&gt;cardinality;<br>    for (int i = 0; i &lt; origcard; ++i) {<br>        uint16_t key = src_1-&gt;array[i];<br>        dst-&gt;array[newcard] = key;<br>        newcard += bitset_container_contains(src_2, key);<br>    }<br>    dst-&gt;cardinality = newcard;<br>}<br>Array Container &amp; Bitmap Container<br>同上Bitmap Container &amp; Array Container的原理。<br>同时还有iand，标识inplace的And操作，原理与上述基本类似。<br>3、Or<br>Or流程：</p>
<ol>
<li>获取high_low_container，while循环遍历判断keys数组中元素，在高16位相等的情况下，调用container_or求两个container的并集<br> a. Bitmap Container | Bitmap Container<pre><code> i. 两个Bitmap求并集（底层使用AVX2指令集加速批量处理）
</code></pre> b. Array Container | Array Container<pre><code> i. 预估取并集后的元素个数是否小于4096，
     1. 是，则新建一个Array Container
     2. 否，则新建一个Bitmap Container
</code></pre> c. Bitmap Container | Array Container<pre><code> i. Copy一份Bitmap Container
 i. 遍历Array Container的元素，添加进新的Bitmap Container
</code></pre> b. Array Container | Bitmap Container<pre><code> i. 同上
</code></pre></li>
<li><p>高16位元素不相等，直接给answer添加对应的key及container<br>roaring_bitmap_t <em>roaring_bitmap_or(const roaring_bitmap_t </em>x1,</p>
<pre><code>                             const roaring_bitmap_t *x2) &#123;
</code></pre><p> uint8_t result_type = 0;<br> const int length1 = x1-&gt;high_low_container.size,</p>
<pre><code>       length2 = x2-&gt;high_low_container.size;
</code></pre><p> if (0 == length1) {</p>
<pre><code> return roaring_bitmap_copy(x2);
</code></pre><p> }<br> if (0 == length2) {</p>
<pre><code> return roaring_bitmap_copy(x1);
</code></pre><p> }<br> roaring_bitmap_t *answer =</p>
<pre><code> roaring_bitmap_create_with_capacity(length1 + length2);
</code></pre><p> roaring_bitmap_set_copy_on_write(answer, is_cow(x1) &amp;&amp; is_cow(x2));<br> int pos1 = 0, pos2 = 0;<br> uint8_t type1, type2;<br> uint16_t s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);<br> uint16_t s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);<br> while (true) {</p>
<pre><code>   // 高16位相等，底层container进行求or
 if (s1 == s2) &#123;
     container_t *c1 = ra_get_container_at_index(
                             &amp;x1-&gt;high_low_container, pos1, &amp;type1);
     container_t *c2 = ra_get_container_at_index(
                             &amp;x2-&gt;high_low_container, pos2, &amp;type2);
     container_t *c = container_or(c1, type1, c2, type2, &amp;result_type);

     ra_append(&amp;answer-&gt;high_low_container, s1, c, result_type);
     ++pos1;
     ++pos2;
     if (pos1 == length1) break;
     if (pos2 == length2) break;
     s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);
     s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);

 &#125; else if (s1 &lt; s2) &#123;  // s1 &lt; s2
       // 拷贝 s1 对应的container
     container_t *c1 = ra_get_container_at_index(
                             &amp;x1-&gt;high_low_container, pos1, &amp;type1);
     c1 = get_copy_of_container(c1, &amp;type1, is_cow(x1));
     if (is_cow(x1)) &#123;
         ra_set_container_at_index(&amp;x1-&gt;high_low_container, pos1, c1,
                                   type1);
     &#125;
     ra_append(&amp;answer-&gt;high_low_container, s1, c1, type1);
     pos1++;
     if (pos1 == length1) break;
     s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);

 &#125; else &#123;  // s1 &gt; s2
     container_t *c2 = ra_get_container_at_index(
                             &amp;x2-&gt;high_low_container, pos2, &amp;type2);
     // c2 = container_clone(c2, type2);
     c2 = get_copy_of_container(c2, &amp;type2, is_cow(x2));
     if (is_cow(x2)) &#123;
         ra_set_container_at_index(&amp;x2-&gt;high_low_container, pos2, c2,
                                   type2);
     &#125;
     ra_append(&amp;answer-&gt;high_low_container, s2, c2, type2);
     pos2++;
     if (pos2 == length2) break;
     s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);
 &#125;
</code></pre><p> }<br> if (pos1 == length1) {</p>
<pre><code> ra_append_copy_range(&amp;answer-&gt;high_low_container,
                      &amp;x2-&gt;high_low_container, pos2, length2,
                      is_cow(x2));
</code></pre><p> } else if (pos2 == length2) {</p>
<pre><code> ra_append_copy_range(&amp;answer-&gt;high_low_container,
                      &amp;x1-&gt;high_low_container, pos1, length1,
                      is_cow(x1));
</code></pre><p> }<br> return answer;<br>}<br>ContainerOr<br>static inline container_t <em>container_or(<br> const container_t </em>c1, uint8_t type1,<br> const container_t <em>c2, uint8_t type2,<br> uint8_t </em>result_type<br>){<br> c1 = container_unwrap_shared(c1, &amp;type1);<br> c2 = container_unwrap_shared(c2, &amp;type2);<br> container_t *result = NULL;<br> switch (PAIR_CONTAINER_TYPES(type1, type2)) {</p>
<pre><code> case CONTAINER_PAIR(BITSET,BITSET):
     result = bitset_container_create();
     // 1、两个Bitmap Container求or，底层会用avx2指令集优化
     bitset_container_or(const_CAST_bitset(c1),
                         const_CAST_bitset(c2),
                         CAST_bitset(result));
     *result_type = BITSET_CONTAINER_TYPE;
     return result;

 case CONTAINER_PAIR(ARRAY,ARRAY):
         // 2、两个Array Container求or
     *result_type = array_array_container_union(
                         const_CAST_array(c1),
                         const_CAST_array(c2), &amp;result)
                             ? BITSET_CONTAINER_TYPE
                             : ARRAY_CONTAINER_TYPE;
     return result;

 case CONTAINER_PAIR(RUN,RUN):
         // 3、两个Run Container求or
     result = run_container_create();
     run_container_union(const_CAST_run(c1),
                         const_CAST_run(c2),
                         CAST_run(result));
     *result_type = RUN_CONTAINER_TYPE;
     // todo: could be optimized since will never convert to array
     result = convert_run_to_efficient_container_and_free(
                     CAST_run(result), result_type);
     return result;
     // 4、Array Container 和 求or
 case CONTAINER_PAIR(BITSET,ARRAY):
     result = bitset_container_create();
     array_bitset_container_union(const_CAST_array(c2),
                                  const_CAST_bitset(c1),
                                  CAST_bitset(result));
     *result_type = BITSET_CONTAINER_TYPE;
     return result;

 case CONTAINER_PAIR(ARRAY,BITSET):
     result = bitset_container_create();
     array_bitset_container_union(const_CAST_array(c1),
                                  const_CAST_bitset(c2),
                                  CAST_bitset(result));
     *result_type = BITSET_CONTAINER_TYPE;
     return result;
 ...

 default:
     assert(false);
     __builtin_unreachable();
     return NULL;  // unreached
</code></pre><p> }<br>}<br>两个Array Container求Or<br>bool array_array_container_union(<br> const array_container_t <em>src_1, const array_container_t </em>src_2,<br> container_t **dst<br>){<br> int totalCardinality = src_1-&gt;cardinality + src_2-&gt;cardinality;<br> // 预估or的元素个数还是小于4096，则还是新建一个Array Container<br> // 用于存储并集结果<br> if (totalCardinality &lt;= DEFAULT_MAX_SIZE) {</p>
<pre><code> *dst = array_container_create_given_capacity(totalCardinality);
 if (*dst != NULL) &#123;
         // 该函数底层会调用fast_union_uint16，进行avx2指令集优化加速
     array_container_union(src_1, src_2, CAST_array(*dst));
 &#125; else &#123;
     return true; // otherwise failure won&#39;t be caught
 &#125;
 return false;  // not a bitset
</code></pre><p> }<br> // 预估or元素个数大于4096，则创建一个Bitmap Container<br> <em>dst = bitset_container_create();<br> bool returnval = true;  // expect a bitset<br> if (</em>dst != NULL) {</p>
<pre><code> bitset_container_t *ourbitset = CAST_bitset(*dst);
 // 这里底层会调用_asm_bitset_set_list，使用avx2指令集优化
 bitset_set_list(ourbitset-&gt;words, src_1-&gt;array, src_1-&gt;cardinality);
 ourbitset-&gt;cardinality = (int32_t)bitset_set_list_withcard(
     ourbitset-&gt;words, src_1-&gt;cardinality, src_2-&gt;array,
     src_2-&gt;cardinality);
 //如果最终求or发现元素个数小于4096，还会转成ArrayContainer
 if (ourbitset-&gt;cardinality &lt;= DEFAULT_MAX_SIZE) &#123;
     // need to convert!
     *dst = array_container_from_bitset(ourbitset);
     bitset_container_free(ourbitset);
     returnval = false;  // not going to be a bitset
 &#125;
</code></pre><p> }<br> return returnval;<br>}<br>Array Container 和 Bitmap Container求 Or<br>void array_bitset_container_union(const array_container_t *src_1,</p>
<pre><code>                           const bitset_container_t *src_2,
                           bitset_container_t *dst) &#123;
</code></pre><p>   // 先copy一份Bitmap Container个answer<br> if (src_2 != dst) bitset_container_copy(src_2, dst);<br>   // 调用bitset_set_list_withcard，底层可以调用avx2指令集优化<br> dst-&gt;cardinality = (int32_t)bitset_set_list_withcard(</p>
<pre><code> dst-&gt;words, dst-&gt;cardinality, src_1-&gt;array, src_1-&gt;cardinality);
</code></pre><p>}</p>
</li>
</ol>
<p>…</p>
<p>uint64_t bitset_set_list_withcard(uint64_t <em>words, uint64_t card,<br>                                  const uint16_t </em>list, uint64_t length) {<br>    uint64_t offset, load, newload, pos, index;<br>    const uint16_t <em>end = list + length;<br>    while (list != end) {<br>        pos = </em>list;<br>        offset = pos &gt;&gt; 6;<br>        index = pos % 64;<br>        load = words[offset];<br>        newload = load | (UINT64_C(1) &lt;&lt; index);<br>        card += (load ^ newload) &gt;&gt; index;<br>        words[offset] = newload;<br>        list++;<br>    }<br>    return card;<br>}<br>4、FastUnion<br>static Roaring fastunion(size_t n, const Roaring <strong>inputs) {<br>        const roaring_bitmap_t </strong>x =<br>            (const roaring_bitmap_t <em>*)malloc(n </em> sizeof(roaring_bitmap_t <em>));<br>        if (x == NULL) {<br>            ROARING_TERMINATE(“failed memory alloc in fastunion”);<br>        }<br>        for (size_t k = 0; k &lt; n; ++k) x[k] = &amp;inputs[k]-&gt;roaring;<br>              // 调用roaring_bitmap_or_many<br>        roaring_bitmap_t </em>c_ans = api::roaring_bitmap_or_many(n, x);<br>              // 调用堆结构实现的有时效率会更快些<br>              // roaring_bitmap_t *c_ans = api::roaring_bitmap_or_many_heap(n, x);<br>        if (c_ans == NULL) {<br>            free(x);<br>            ROARING_TERMINATE(“failed memory alloc in fastunion”);<br>        }<br>        Roaring ans(c_ans);<br>        free(x);<br>        return ans;<br>    }</p>
<p>…<br>roaring_bitmap_t <em>roaring_bitmap_or_many(size_t number,<br>                                         const roaring_bitmap_t **x) {<br>    if (number == 0) {<br>        return roaring_bitmap_create();<br>    }<br>    if (number == 1) {<br>        return roaring_bitmap_copy(x[0]);<br>    }<br>      // 先前两个求或<br>    roaring_bitmap_t </em>answer =<br>        roaring_bitmap_lazy_or(x[0], x[1], LAZY_OR_BITSET_CONVERSION);<br>    // 两两求或<br>      for (size_t i = 2; i &lt; number; i++) {<br>        roaring_bitmap_lazy_or_inplace(answer, x[i], LAZY_OR_BITSET_CONVERSION);<br>    }<br>      // lazy or的方式是会将array_contianer 转成 bitmap_container<br>      // 此处会修复把可以转成ArrayContainer的再转回来<br>    roaring_bitmap_repair_after_lazy(answer);<br>    return answer;<br>}</p>
<p>…</p>
<p>roaring_bitmap_t <em>roaring_bitmap_lazy_or(const roaring_bitmap_t </em>x1,<br>                                         const roaring_bitmap_t <em>x2,<br>                                         const bool bitsetconversion) {<br>    uint8_t result_type = 0;<br>    const int length1 = x1-&gt;high_low_container.size,<br>              length2 = x2-&gt;high_low_container.size;<br>    if (0 == length1) {<br>        return roaring_bitmap_copy(x2);<br>    }<br>    if (0 == length2) {<br>        return roaring_bitmap_copy(x1);<br>    }<br>    roaring_bitmap_t </em>answer =<br>        roaring_bitmap_create_with_capacity(length1 + length2);<br>    roaring_bitmap_set_copy_on_write(answer, is_cow(x1) &amp;&amp; is_cow(x2));<br>    int pos1 = 0, pos2 = 0;<br>    uint8_t type1, type2;<br>    uint16_t s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);<br>    uint16_t s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);<br>    while (true) {<br>        if (s1 == s2) {<br>            container_t <em>c1 = ra_get_container_at_index(<br>                                    &amp;x1-&gt;high_low_container, pos1, &amp;type1);<br>            container_t </em>c2 = ra_get_container_at_index(<br>                                    &amp;x2-&gt;high_low_container, pos2, &amp;type2);<br>            container_t <em>c;<br>              // 转成bitmap container<br>            if (bitsetconversion &amp;&amp;<br>                (get_container_type(c1, type1) != BITSET_CONTAINER_TYPE) &amp;&amp;<br>                (get_container_type(c2, type2) != BITSET_CONTAINER_TYPE)<br>            ){<br>                container_t </em>newc1 =<br>                    container_mutable_unwrap_shared(c1, &amp;type1);<br>                newc1 = container_to_bitset(newc1, type1);<br>                type1 = BITSET_CONTAINER_TYPE;<br>                  // 根据container的类型，底层是去调用 bitset_container_or<br>                  // array_bitset_container_lazy_union<br>                c = container_lazy_ior(newc1, type1, c2, type2,<br>                                       &amp;result_type);<br>                if (c != newc1) {  // should not happen<br>                    container_free(newc1, type1);<br>                }<br>            } else {<br>                c = container_lazy_or(c1, type1, c2, type2, &amp;result_type);<br>            }<br>            // since we assume that the initial containers are non-empty,<br>            // the<br>            // result here<br>            // can only be non-empty<br>            ra_append(&amp;answer-&gt;high_low_container, s1, c, result_type);<br>            ++pos1;<br>            ++pos2;<br>            if (pos1 == length1) break;<br>            if (pos2 == length2) break;<br>            s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);<br>            s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);</p>
<pre><code>    &#125; else if (s1 &lt; s2) &#123;  // s1 &lt; s2
        container_t *c1 = ra_get_container_at_index(
                                &amp;x1-&gt;high_low_container, pos1, &amp;type1);
        c1 = get_copy_of_container(c1, &amp;type1, is_cow(x1));
        if (is_cow(x1)) &#123;
            ra_set_container_at_index(&amp;x1-&gt;high_low_container, pos1, c1,
                                      type1);
        &#125;
        ra_append(&amp;answer-&gt;high_low_container, s1, c1, type1);
        pos1++;
        if (pos1 == length1) break;
        s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);

    &#125; else &#123;  // s1 &gt; s2
        container_t *c2 = ra_get_container_at_index(
                                &amp;x2-&gt;high_low_container, pos2, &amp;type2);
        c2 = get_copy_of_container(c2, &amp;type2, is_cow(x2));
        if (is_cow(x2)) &#123;
            ra_set_container_at_index(&amp;x2-&gt;high_low_container, pos2, c2,
                                      type2);
        &#125;
        ra_append(&amp;answer-&gt;high_low_container, s2, c2, type2);
        pos2++;
        if (pos2 == length2) break;
        s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);
    &#125;
&#125;
if (pos1 == length1) &#123;
    ra_append_copy_range(&amp;answer-&gt;high_low_container,
                         &amp;x2-&gt;high_low_container, pos2, length2,
                         is_cow(x2));
&#125; else if (pos2 == length2) &#123;
    ra_append_copy_range(&amp;answer-&gt;high_low_container,
                         &amp;x1-&gt;high_low_container, pos1, length1,
                         is_cow(x1));
&#125;
return answer;
</code></pre><p>}</p>
<p>EXPERIMENTS<br>参考论文：<a href="https://arxiv.org/pdf/1709.07821.pdf">https://arxiv.org/pdf/1709.07821.pdf</a><br>内存使用：</p>
<p>遍历一遍所使用的耗时：</p>
<p>随机获取某个元素的耗时：</p>
<p>两两求交集：</p>
<p>两两求并集：</p>
<p>多个集合求并集： </p>
]]></content>
      <categories>
        <category>RoaringBitmap</category>
      </categories>
      <tags>
        <tag>RoaringBitmap</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象的设计原则</title>
    <url>/2020/06/26/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>只知道面向对象的三个特性：封装、继承、多态。被问到面相对象的设计原则，结果答不上来，就查资料整理了一下。</p>
<ol>
<li><p>单一职责原则（Single Responsibility Principle）</p>
<p> 每一个类应该专注于做一件事情。</p>
</li>
<li><p>里氏替换原则（Liskov Substitution Principle）</p>
<p> 超类存在的地方，子类是可以替换的。</p>
</li>
<li><p>依赖倒置原则（Dependence Inversion Principle）</p>
<p> 实现尽量依赖抽象，不依赖具体实现。</p>
<span id="more"></span></li>
<li><p>接口隔离原则（Interface Segregation Principle）</p>
<p> 应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。</p>
</li>
<li><p>迪米特法则（Law Of Demeter）</p>
<p> 又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。</p>
</li>
<li><p>开闭原则（Open Close Principle）</p>
<p> 面向扩展开放，面向修改关闭。</p>
</li>
<li><p>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）</p>
<p> 尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。</p>
</li>
</ol>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol>
<li><a href="https://blog.csdn.net/yanbober/article/details/45312243">https://blog.csdn.net/yanbober/article/details/45312243</a></li>
<li><a href="https://segmentfault.com/a/1190000020182270">https://segmentfault.com/a/1190000020182270</a></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra算法</title>
    <url>/2020/07/12/Dijkstra%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>学习了一下关于Dijlstra最短路的算法，做一下总结，梳理一下思路。</p>
<p>求最短路算法一般分为求单源最短路和多源汇最短路，思维导图如图所示：<br><img src="/2020/07/12/Dijkstra%E7%AE%97%E6%B3%95/1.jpeg" alt></p>
<p>其中n表示节点数，m表示边数。</p>
<p>稠密图：m与n^2是一个级别的，用邻接矩阵来表示。</p>
<p>稀疏图：m远远小于n^2，用邻接表来表示，比邻接矩阵更节省空间</p>
<p>具体邻接矩阵和邻接表可以参考这篇文章<a href="https://blog.csdn.net/qq_29134495/article/details/51376580">图的邻接矩阵和邻接表的比较</a><br><span id="more"></span></p>
<h4 id="朴素Dijkstra算法"><a href="#朴素Dijkstra算法" class="headerlink" title="朴素Dijkstra算法"></a>朴素Dijkstra算法</h4><p>给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p>
<p>请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。</p>
<p><strong>输入格式</strong><br>第一行包含整数n和m。</p>
<p>接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示1号点到n号点的最短距离。</p>
<p>如果路径不存在，则输出-1。</p>
<p><strong>数据范围</strong><br>1≤n≤500,<br>1≤m≤105,<br>图中涉及边长均不超过10000。</p>
<p><strong>输入样例：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 2</span><br><span class="line">2 3 1</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure><br><strong>输出样例：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">//为稠密阵所以用邻接矩阵存储</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">//用于在更新最短距离时 判断当前的点的最短距离是否确定 是否需要更新</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">//用于存储每个点到起点的最短距离</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化dist</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));   <span class="comment">//初始化距离  0x3f代表无限大</span></span><br><span class="line"></span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;   <span class="comment">//第一个点到自身的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;   <span class="comment">//t存储当前访问的点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// t 不在s中，距离最近的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="comment">//该步骤即寻找还未确定最短路的点中路径最短的点</span></span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) &#123;</span><br><span class="line">                t = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过上述操作当前我们的t代表就是剩余未确定最短路的点中 路径最短的点</span></span><br><span class="line">        <span class="comment">// 同时该点的最短路径也已经确定我们将该点标记</span></span><br><span class="line">        st[t] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用t去更新其他所有点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;=n; ++j) &#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在到这条边的情况</span></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g)); <span class="comment">//求最短路所以每个点初始为无限大</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="comment">// a -&gt; b 之间可能有多条边，只保留长度最短（权重最小）的那条边就可以了</span></span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t =<span class="built_in">dijkstra</span>();</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="堆优化Dijkstra算法"><a href="#堆优化Dijkstra算法" class="headerlink" title="堆优化Dijkstra算法"></a>堆优化Dijkstra算法</h4><p>给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为非负值。</p>
<p>请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。</p>
<p><strong>输入格式</strong><br>第一行包含整数n和m。</p>
<p>接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示1号点到n号点的最短距离。</p>
<p>如果路径不存在，则输出-1。</p>
<p><strong>数据范围</strong><br>1≤n,m≤1.5×105,<br>图中涉及边长均不小于0，且不超过10000。<br><strong>输入样例：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 2</span><br><span class="line">2 3 1</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure><br><strong>输出样例：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><br>// 使用邻接表实现（稀疏图用邻接表来实现）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; g;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(N,<span class="number">1e9</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">    <span class="comment">// 第一个是距离， 第二个参数是标号</span></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> curPos = p.second;</span><br><span class="line">        <span class="keyword">if</span> (st[curPos]) <span class="keyword">continue</span>;</span><br><span class="line">        st[curPos] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : g[curPos]) &#123;</span><br><span class="line">            <span class="type">int</span> distance = next.second;</span><br><span class="line">            <span class="type">int</span> nextPos = next.first;</span><br><span class="line">            <span class="keyword">if</span> (distance + dist[curPos] &lt; dist[nextPos]) &#123;</span><br><span class="line">                dist[nextPos] = distance + dist[curPos];</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dist[nextPos], nextPos));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">1e9</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    g.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a].<span class="built_in">push_back</span>(&#123;b,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">dijkstra</span>();</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>根据今天LC周赛，总结一套Dijkstra的模板，以后直接套这个模板就好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DIJ</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector &lt;vector &lt;pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; g;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        g.<span class="built_in">clear</span>();</span><br><span class="line">        g.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        g[a].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(b, c));</span><br><span class="line">        <span class="comment">// 无向边需修改push两次</span></span><br><span class="line">        <span class="comment">// g[b].push_back(make_pair(a, c));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetDist</span><span class="params">(<span class="type">int</span> start, vector &lt;<span class="type">int</span>&gt; &amp;dist)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; <span class="built_in">visited</span>(n,<span class="number">0</span>);</span><br><span class="line">        priority_queue &lt;pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; ,vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dist[i] = (i == start ? <span class="number">0</span> : <span class="number">2e9</span>);; <span class="comment">// 初始化为最远距离</span></span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dist[start], start));<span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> now = q.<span class="built_in">top</span>().second;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[now]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[now] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) g[now].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="type">int</span> next = g[now][i].first;</span><br><span class="line">                <span class="type">int</span> distance = g[now][i].second;</span><br><span class="line">                <span class="keyword">if</span> (!visited[next] &amp;&amp; dist[now] + distance &lt; dist[next]) &#123;</span><br><span class="line">                    dist[next] = dist[now] + distance;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dist[next], next));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DIJ</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector &lt;vector &lt;pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; g;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        g.<span class="built_in">clear</span>();</span><br><span class="line">        g.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        g[a].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(b, c));</span><br><span class="line">        <span class="comment">// 无向边需修改push两次</span></span><br><span class="line">        <span class="comment">// g[b].push_back(make_pair(a, c));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetDist</span><span class="params">(<span class="type">int</span> start, vector &lt;<span class="type">int</span>&gt; &amp;dist)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; <span class="built_in">visited</span>(n,<span class="number">0</span>);</span><br><span class="line">        priority_queue &lt;pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; ,vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dist[i] = (i == start ? <span class="number">0</span> : <span class="number">2e9</span>); <span class="comment">// 初始化为最远距离</span></span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dist[start], start));<span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> now = q.<span class="built_in">top</span>().second;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[now]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[now] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) g[now].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="type">int</span> next = g[now][i].first;</span><br><span class="line">                <span class="type">int</span> distance = g[now][i].second;</span><br><span class="line">                <span class="keyword">if</span> (!visited[next] &amp;&amp; dist[now] + distance &lt; dist[next]) &#123;</span><br><span class="line">                    dist[next] = dist[now] + distance;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dist[next], next));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist[n<span class="number">-1</span>] == <span class="number">2e9</span>)</span><br><span class="line">            dist[n<span class="number">-1</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;  <span class="comment">// n是节点数，m是边数</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    DIJ dij;</span><br><span class="line">    dij.<span class="built_in">Init</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        dij.<span class="built_in">Add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n+<span class="number">10</span>)</span></span>;</span><br><span class="line">    dij.<span class="built_in">GetDist</span>(<span class="number">1</span>,dist);</span><br><span class="line">    cout &lt;&lt; dist[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase API操作</title>
    <url>/2023/12/23/HBase-API%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="HBase-API操作"><a href="#HBase-API操作" class="headerlink" title="HBase API操作"></a>HBase API操作</h1><h2 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h2><p>新建项目后在pom.xml中添加依赖：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jdk.tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdk.tools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;JAVA_HOME&#125;/lib/tools.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br><span id="more"></span></p>
<h2 id="2、HBase-API"><a href="#2、HBase-API" class="headerlink" title="2、HBase API"></a>2、HBase API</h2><h3 id="1）获取Configuration对象"><a href="#1）获取Configuration对象" class="headerlink" title="1）获取Configuration对象"></a>1）获取Configuration对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Configuration conf;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="comment">//使用HBaseConfiguration的单例方法实例化</span></span><br><span class="line">    conf = HBaseConfiguration.create();</span><br><span class="line">conf.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="string">&quot;192.168.9.102&quot;</span>);</span><br><span class="line">conf.set(<span class="string">&quot;hbase.zookeeper.property.clientPort&quot;</span>, <span class="string">&quot;2181&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）判断表是否存在"><a href="#2）判断表是否存在" class="headerlink" title="2）判断表是否存在"></a>2）判断表是否存在</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isTableExist</span><span class="params">(String tableName)</span> <span class="keyword">throws</span> MasterNotRunningException,</span><br><span class="line"> ZooKeeperConnectionException, IOException&#123;</span><br><span class="line">    <span class="comment">//在HBase中管理、访问表需要先创建HBaseAdmin对象</span></span><br><span class="line"><span class="comment">//Connection connection = ConnectionFactory.createConnection(conf);</span></span><br><span class="line"><span class="comment">//HBaseAdmin admin = (HBaseAdmin) connection.getAdmin();</span></span><br><span class="line">    <span class="type">HBaseAdmin</span> <span class="variable">admin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBaseAdmin</span>(conf);</span><br><span class="line">    <span class="keyword">return</span> admin.tableExists(tableName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3）创建表"><a href="#3）创建表" class="headerlink" title="3）创建表"></a>3）创建表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createTable</span><span class="params">(String tableName, String... columnFamily)</span> <span class="keyword">throws</span></span><br><span class="line"> MasterNotRunningException, ZooKeeperConnectionException, IOException&#123;</span><br><span class="line">    <span class="type">HBaseAdmin</span> <span class="variable">admin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBaseAdmin</span>(conf);</span><br><span class="line">    <span class="comment">//判断表是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(isTableExist(tableName))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;表&quot;</span> + tableName + <span class="string">&quot;已存在&quot;</span>);</span><br><span class="line">        <span class="comment">//System.exit(0);</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//创建表属性对象,表名需要转字节</span></span><br><span class="line">        <span class="type">HTableDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTableDescriptor</span>(TableName.valueOf(tableName));</span><br><span class="line">        <span class="comment">//创建多个列族</span></span><br><span class="line">        <span class="keyword">for</span>(String cf : columnFamily)&#123;</span><br><span class="line">            descriptor.addFamily(<span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(cf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据对表的配置，创建表</span></span><br><span class="line">        admin.createTable(descriptor);</span><br><span class="line">        System.out.println(<span class="string">&quot;表&quot;</span> + tableName + <span class="string">&quot;创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4）删除表"><a href="#4）删除表" class="headerlink" title="4）删除表"></a>4）删除表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void dropTable(String tableName) throws MasterNotRunningException,</span><br><span class="line"> ZooKeeperConnectionException, IOException&#123;</span><br><span class="line">    HBaseAdmin admin = new HBaseAdmin(conf);</span><br><span class="line">    if(isTableExist(tableName))&#123;</span><br><span class="line">        admin.disableTable(tableName);</span><br><span class="line">        admin.deleteTable(tableName);</span><br><span class="line">        System.out.println(&quot;表&quot; + tableName + &quot;删除成功！&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        System.out.println(&quot;表&quot; + tableName + &quot;不存在！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5）向表中插入数据向表中插入数据"><a href="#5）向表中插入数据向表中插入数据" class="headerlink" title="5）向表中插入数据向表中插入数据"></a>5）向表中插入数据向表中插入数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addRowData</span><span class="params">(String tableName, String rowKey, String columnFamily, String</span></span><br><span class="line"><span class="params"> column, String value)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="comment">//创建HTable对象</span></span><br><span class="line">    <span class="type">HTable</span> <span class="variable">hTable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTable</span>(conf, tableName);</span><br><span class="line">    <span class="comment">//向表中插入数据</span></span><br><span class="line">    <span class="type">Put</span> <span class="variable">put</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Put</span>(Bytes.toBytes(rowKey));</span><br><span class="line">    <span class="comment">//向Put对象中组装数据</span></span><br><span class="line">    put.add(Bytes.toBytes(columnFamily), Bytes.toBytes(column), Bytes.toBytes(value));</span><br><span class="line">    hTable.put(put);</span><br><span class="line">    hTable.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;插入数据成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6）删除多行数据"><a href="#6）删除多行数据" class="headerlink" title="6）删除多行数据"></a>6）删除多行数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteMultiRow</span><span class="params">(String tableName, String... rows)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">HTable</span> <span class="variable">hTable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTable</span>(conf, tableName);</span><br><span class="line">    List&lt;Delete&gt; deleteList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Delete&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String row : rows)&#123;</span><br><span class="line">        <span class="type">Delete</span> <span class="variable">delete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Delete</span>(Bytes.toBytes(row));</span><br><span class="line">        deleteList.add(delete);</span><br><span class="line">    &#125;</span><br><span class="line">    hTable.delete(deleteList);</span><br><span class="line">    hTable.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7）获取所有数据"><a href="#7）获取所有数据" class="headerlink" title="7）获取所有数据"></a>7）获取所有数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getAllRows</span><span class="params">(String tableName)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">HTable</span> <span class="variable">hTable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTable</span>(conf, tableName);</span><br><span class="line">    <span class="comment">//得到用于扫描region的对象</span></span><br><span class="line">    <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">    <span class="comment">//使用HTable得到resultcanner实现类的对象</span></span><br><span class="line">    <span class="type">ResultScanner</span> <span class="variable">resultScanner</span> <span class="operator">=</span> hTable.getScanner(scan);</span><br><span class="line">    <span class="keyword">for</span>(Result result : resultScanner)&#123;</span><br><span class="line">        Cell[] cells = result.rawCells();</span><br><span class="line">        <span class="keyword">for</span>(Cell cell : cells)&#123;</span><br><span class="line">            <span class="comment">//得到rowkey</span></span><br><span class="line">            System.out.println(<span class="string">&quot;行键:&quot;</span> + Bytes.toString(CellUtil.cloneRow(cell)));</span><br><span class="line">            <span class="comment">//得到列族</span></span><br><span class="line">            System.out.println(<span class="string">&quot;列族&quot;</span> + Bytes.toString(CellUtil.cloneFamily(cell)));</span><br><span class="line">            System.out.println(<span class="string">&quot;列:&quot;</span> + Bytes.toString(CellUtil.cloneQualifier(cell)));</span><br><span class="line">            System.out.println(<span class="string">&quot;值:&quot;</span> + Bytes.toString(CellUtil.cloneValue(cell)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8）获取某一行数据"><a href="#8）获取某一行数据" class="headerlink" title="8）获取某一行数据"></a>8）获取某一行数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void getRow(String tableName, String rowKey) throws IOException&#123;</span><br><span class="line">    HTable table = new HTable(conf, tableName);</span><br><span class="line">    Get get = new Get(Bytes.toBytes(rowKey));</span><br><span class="line">    //get.setMaxVersions();显示所有版本</span><br><span class="line">    //get.setTimeStamp();显示指定时间戳的版本</span><br><span class="line">    Result result = table.get(get);</span><br><span class="line">    for(Cell cell : result.rawCells())&#123;</span><br><span class="line">        System.out.println(&quot;行键:&quot; + Bytes.toString(result.getRow()));</span><br><span class="line">        System.out.println(&quot;列族&quot; + Bytes.toString(CellUtil.cloneFamily(cell)));</span><br><span class="line">        System.out.println(&quot;列:&quot; + Bytes.toString(CellUtil.cloneQualifier(cell)));</span><br><span class="line">        System.out.println(&quot;值:&quot; + Bytes.toString(CellUtil.cloneValue(cell)));</span><br><span class="line">        System.out.println(&quot;时间戳:&quot; + cell.getTimestamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9）获取某一行指定“列族-列”的数据"><a href="#9）获取某一行指定“列族-列”的数据" class="headerlink" title="9）获取某一行指定“列族:列”的数据"></a>9）获取某一行指定“列族:列”的数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getRowQualifier</span><span class="params">(String tableName, String rowKey, String family, String qualifier)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">HTable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTable</span>(conf, tableName);</span><br><span class="line">    <span class="type">Get</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Get</span>(Bytes.toBytes(rowKey));</span><br><span class="line">    get.addColumn(Bytes.toBytes(family), Bytes.toBytes(qualifier));</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> table.get(get);</span><br><span class="line">    <span class="keyword">for</span>(Cell cell : result.rawCells())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;行键:&quot;</span> + Bytes.toString(result.getRow()));</span><br><span class="line">        System.out.println(<span class="string">&quot;列族&quot;</span> + Bytes.toString(CellUtil.cloneFamily(cell)));</span><br><span class="line">        System.out.println(<span class="string">&quot;列:&quot;</span> + Bytes.toString(CellUtil.cloneQualifier(cell)));</span><br><span class="line">        System.out.println(<span class="string">&quot;值:&quot;</span> + Bytes.toString(CellUtil.cloneValue(cell)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase 概述</title>
    <url>/2023/12/22/HBase-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="一、HBase-简介"><a href="#一、HBase-简介" class="headerlink" title="一、HBase 简介"></a>一、HBase 简介</h1><p>HBase是一个<strong>高可靠性、高性能、面向列、可伸缩的分布式存储系统</strong>。</p>
<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>HBase的原型是Google的BigTable论文，受到了该论文思想的启发，目前作为Hadoop的子项目来开发维护，用于支持结构化的数据存储。</p>
<p>HBase的目标是存储并处理大型的数据，更具体来说是仅需使用普通的硬件配置，就能够处理由成千上万的行和列所组成的大型数据。</p>
<p>HBase是Google Bigtable的开源实现，但是也有很多不同之处。比如：Google Bigtable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MAPREDUCE来处理Bigtable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据；Google Bigtable利用Chubby作为协同服务，HBase利用Zookeeper作为对应。</p>
<span id="more"></span>
<h2 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h2><p>1）<strong>海量存储</strong></p>
<p>Hbase适合<strong>存储PB级别的海量数据</strong>，在PB级别的数据以及采用廉价PC存储的情况下，能在几十到百毫秒内返回数据。这与Hbase的极易扩展性息息相关。正式因为Hbase良好的扩展性，才为海量数据的存储提供了便利。</p>
<p>2）<strong>列式存储</strong><br>这里的列式存储其实说的是<strong>列族（Column Family）存储</strong>，<strong>Hbase是根据列族来存储数据的</strong>。列族下面可以有非常多的列，列族在创建表的时候就必须指定。</p>
<p>3）<strong>极易扩展</strong><br>Hbase的扩展性主要体现在两个方面，一个是<strong>基于上层处理能力（RegionServer）的扩展</strong>，一个是<strong>基于存储的扩展（HDFS）</strong>。</p>
<p>通过横向添加RegionSever的机器，进行水平扩展，提升Hbase上层的处理能力，提升Hbsae服务更多Region的能力。</p>
<p>备注：RegionServer的作用是管理region、承接业务的访问，这个后面会详细的介绍通过横向添加Datanode的机器，进行存储层扩容，提升Hbase的数据存储能力和提升后端存储的读写能力。</p>
<p>4）<strong>高并发（多核）</strong><br>由于目前大部分使用Hbase的架构，都是采用的廉价PC，因此单个IO的延迟其实并不小，一般在几十到上百ms之间。这里说的高并发，主要是在并发的情况下，Hbase的单个IO延迟下降并不多。能获得高并发、低延迟的服务。</p>
<p>5）<strong>稀疏</strong><br>稀疏主要是针对Hbase列的灵活性，在列族中，你可以指定任意多的列，在列数据为空的情况下，是不会占用存储空间的。</p>
<h2 id="HBase-架构"><a href="#HBase-架构" class="headerlink" title="HBase 架构"></a>HBase 架构</h2><p><img src="/2023/12/22/HBase-%E6%A6%82%E8%BF%B0/1.png" alt></p>
<p>从图中可以看出Hbase是由<strong>Client、Zookeeper、Master、HRegionServer、HDFS</strong>等几个组件组成，下面来介绍一下几个组件的相关功能：</p>
<p>1）<strong>Client</strong></p>
<p>Client包含了访问Hbase的接口，另外Client还维护了对应的cache来加速Hbase的访问，比如cache的.META.元数据的信息。</p>
<p>2）<strong>Zookeeper</strong></p>
<p>HBase通过<a href="https://zookeeper.readthedocs.io/zh/latest/intro.html">Zookeeper</a>来做master的高可用、RegionServer的监控、元数据的入口以及集群配置的维护等工作。具体工作如下：</p>
<p>通过Zoopkeeper来保证集群中只有1个master在运行，如果master异常，会通过竞争机制产生新的master提供服务、通过Zoopkeeper来监控RegionServer的状态，当RegionSevrer有异常的时候，通过回调的形式通知Master RegionServer上下线的信息、通过Zoopkeeper存储元数据的统一入口地址。</p>
<p>3）<strong>HMaster（NameNode）</strong></p>
<p>master节点的主要职责如下：</p>
<p>为RegionServer分配Region、维护整个集群的负载均衡、维护集群的元数据信息、发现失效的Region，并将失效的Region分配到正常的RegionServer上、当RegionSever失效的时候，协调对应Hlog的拆分。</p>
<p>4）<strong>HRegionServer(DataNode)</strong></p>
<p>HregionServer直接对接用户的读写请求，是真正的“干活”的节点。它的功能概括如下：<br>管理master为其分配的Region、处理来自客户端的读写请求、负责和底层HDFS的交互，存储数据到HDFS、负责Region变大以后的拆分、负责Storefile的合并工作。</p>
<p>5）<strong>HDFS</strong></p>
<p>HDFS为Hbase提供最终的底层数据存储服务，同时为HBase提供高可用（Hlog存储在HDFS）的支持，具体功能概括如下：<br><strong>提供元数据和表数据的底层分布式存储服务、数据多副本，保证的高可靠和高可用性</strong>。</p>
<h1 id="4、HBase中的角色及功能"><a href="#4、HBase中的角色及功能" class="headerlink" title="4、HBase中的角色及功能"></a>4、HBase中的角色及功能</h1><p>1）<strong>HMaster</strong></p>
<p>功能：</p>
<ol>
<li>监控RegionServer</li>
<li>处理RegionServer故障转移</li>
<li>处理元数据的变更</li>
<li>处理region的分配或转移</li>
<li>在空闲时间进行数据的负载均衡</li>
<li>通过Zookeeper发布自己的位置给客户端</li>
</ol>
<p>2）<strong>RegionServer</strong></p>
<p>功能：</p>
<ol>
<li>负责存储HBase的实际数据</li>
<li>处理分配给它的Region</li>
<li>刷新缓存到HDFS</li>
<li>维护Hlog</li>
<li>执行压缩</li>
<li>负责处理Region分片</li>
</ol>
<p>3）其他组件</p>
<p><strong>1．Write-Ahead logs</strong></p>
<p>HBase的修改记录，当对HBase读写数据的时候，数据不是直接写进磁盘，它会在内存中保留一段时间（时间以及数据量阈值可以设定）。但把数据保存在内存中可能有更高的概率引起数据丢失，为了解决这个问题，数据会先写在一个叫做Write-Ahead logfile的文件中，然后再写入内存中。所以在系统出现故障的时候，数据可以通过这个日志文件重建。</p>
<p><strong>2．Region</strong></p>
<p>Hbase表的分片，HBase表会根据RowKey值被切分成不同的region存储在RegionServer中，在一个RegionServer中可以有多个不同的region。</p>
<p><strong>3．Store</strong></p>
<p>HFile存储在Store中，一个Store对应HBase表中的一个列族(列簇， Column Family)。</p>
<p><strong>4．MemStore</strong></p>
<p>顾名思义，就是内存存储，位于内存中，用来保存当前的数据操作，所以当数据保存在WAL中之后，RegsionServer会在内存中存储键值对。</p>
<p><strong>5．HFile</strong></p>
<p>这是在磁盘上保存原始数据的实际的物理文件，是实际的存储文件。StoreFile是以HFile的形式存储在HDFS的。</p>
<h1 id="二、HBase原理"><a href="#二、HBase原理" class="headerlink" title="二、HBase原理"></a>二、HBase原理</h1><h2 id="1、HBase读流程"><a href="#1、HBase读流程" class="headerlink" title="1、HBase读流程"></a>1、HBase读流程</h2><p><img src="/2023/12/22/HBase-%E6%A6%82%E8%BF%B0/2.png" alt></p>
<p>1）Client先访问zookeeper，从meta表读取region的位置，然后读取meta表中的数据。meta中又存储了用户表的region信息；</p>
<p>2）根据namespace、表名和rowkey在meta表中找到对应的region信息；</p>
<p>3）找到这个region对应的regionserver；</p>
<p>4）查找对应的region；</p>
<p>5）先从MemStore找数据，如果没有，再到BlockCache里面读；</p>
<p>6）BlockCache还没有，再到StoreFile上读(为了读取的效率)；</p>
<p>7）如果是从StoreFile里面读取的数据，不是直接返回给客户端，而是先写入BlockCache，再返回给客户端。</p>
<h2 id="2、HBase写流程"><a href="#2、HBase写流程" class="headerlink" title="2、HBase写流程"></a>2、HBase写流程</h2><p><img src="/2023/12/22/HBase-%E6%A6%82%E8%BF%B0/3.png" alt></p>
<p>1）Client向HregionServer发送写请求；</p>
<p>2）HregionServer将数据写到HLog（write ahead log），为了数据的持久化和恢复；</p>
<p>3）HregionServer将数据写到内存（MemStore）；</p>
<p>4）反馈Client写成功。</p>
<h2 id="3、数据flush过程"><a href="#3、数据flush过程" class="headerlink" title="3、数据flush过程"></a>3、数据flush过程</h2><p>1）当MemStore数据达到阈值（默认是128M，老版本是64M），将数据刷到硬盘，将内存中的数据删除，同时删除HLog中的历史数据；</p>
<p>2）并将数据存储到HDFS中；</p>
<p>3）在HLog中做标记点。</p>
<h2 id="4、数据合并过程"><a href="#4、数据合并过程" class="headerlink" title="4、数据合并过程"></a>4、数据合并过程</h2><p>1）当数据块达到3块，Hmaster触发合并操作，Region将数据块加载到本地，进行合并；</p>
<p>2）当合并的数据超过256M，进行拆分，将拆分后的Region分配给不同的HregionServer管理；</p>
<p>3）当HregionServer宕机后，将HregionServer上的hlog拆分，然后分配给不同的HregionServer加载，修改.META.；</p>
<p>4）注意：HLog会同步到HDFS。</p>
]]></content>
      <categories>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase 数据结构</title>
    <url>/2023/12/22/HBase-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="HBase数据结构"><a href="#HBase数据结构" class="headerlink" title="HBase数据结构"></a>HBase数据结构</h1><h2 id="1、RowKey"><a href="#1、RowKey" class="headerlink" title="1、RowKey"></a>1、RowKey</h2><p>与nosql数据库们一样,RowKey是用来检索记录的主键。访问HBASE table中的行，只有三种方式：</p>
<p>1）通过单个RowKey访问(get)</p>
<p>2）通过RowKey的range（正则）(like)</p>
<p>3）全表扫描(scan)</p>
<p>RowKey行键 (RowKey)可以是任意字符串(最大长度是64KB，实际应用中长度一般为 10-100bytes)，在HBASE内部，RowKey保存为字节数组。存储时，数据按照RowKey的字典序(byte order)排序存储。设计RowKey时，要充分排序存储这个特性，将经常一起读取的行存储放到一起。(位置相关性)</p>
<span id="more"></span>
<h2 id="2、Column-Family"><a href="#2、Column-Family" class="headerlink" title="2、Column Family"></a>2、Column Family</h2><p>列族：HBASE表中的每个列，都归属于某个列族。列族是表的schema的一部 分(而列不是)，必须在使用表之前定义。列名都以列族作为前缀。例如 courses:history，courses:math都属于courses 这个列族。</p>
<h2 id="3、Cell"><a href="#3、Cell" class="headerlink" title="3、Cell"></a>3、Cell</h2><p>由{rowkey, column Family:columu, version} 唯一确定的单元。cell中的数据是没有类型的，全部是字节码形式存储。</p>
<p>关键字：无类型、字节码</p>
<h2 id="4、Timestamp"><a href="#4、Timestamp" class="headerlink" title="4、Timestamp"></a>4、Timestamp</h2><p>HBASE 中通过rowkey和columns确定的为一个存贮单元称为cell。每个 cell都保存 着同一份数据的多个版本。版本通过时间戳来索引。时间戳的类型是 64位整型。时间戳可以由HBASE(在数据写入时自动 )赋值，此时时间戳是精确到毫秒 的当前系统时间。时间戳也可以由客户显式赋值。如果应用程序要避免数据版 本冲突，就必须自己生成具有唯一性的时间戳。每个 cell中，不同版本的数据按照时间倒序排序，即最新的数据排在最前面。<br>为了避免数据存在过多版本造成的的管理 (包括存贮和索引)负担，HBASE提供 了两种数据版本回收方式。一是保存数据的最后n个版本，二是保存最近一段 时间内的版本（比如最近七天）。用户可以针对每个列族进行设置。</p>
<h2 id="5、命名空间"><a href="#5、命名空间" class="headerlink" title="5、命名空间"></a>5、命名空间</h2><p>命名空间结构如下：<br><img src="/2023/12/22/HBase-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png" alt></p>
<p>1) Table：表，所有的表都是命名空间的成员，即表必属于某个命名空间，如果没有指定，则在default默认的命名空间中。</p>
<p>2) RegionServer group：一个命名空间包含了默认的RegionServer Group。</p>
<p>3) Permission：权限，命名空间能够让我们来定义访问控制列表ACL（Access Control List）。例如，创建表，读取表，删除，更新等等操作。</p>
<p>4) Quota：限额，可以强制一个命名空间可包含的region的数量。</p>
]]></content>
      <categories>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP请求与响应全过程</title>
    <url>/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>在浏览器的地址栏输入一个URL，然后回车，回车这一瞬间到看到页面到底发生了什么呢？</p>
<p>主要是进行了一下几个步骤：</p>
<p>1.DNS域名解析；</p>
<p>2.建立TCP连接；</p>
<p>3.发送http请求；</p>
<p>4.服务器处理请求；</p>
<p>5.返回响应结果；</p>
<p>6.关闭TCP连接；</p>
<p>7.浏览器解析HTML；</p>
<p>8.浏览器布局渲染；</p>
<span id="more"></span>
<h3 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h3><p>我们在浏览器输入网址，其实就是要向服务器请求我们想要的页面内容，所有浏览器首先要确认的是域名所对应的服务器在哪里。将域名解析成对应的服务器IP地址这项工作，是由DNS服务器来完成的。</p>
<p>客户端收到你输入的域名地址后，一般会经历以下几个步骤：</p>
<ol>
<li><p>Chrome浏览器会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有www.baidu.com对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</p>
<pre><code> 注：我们怎么查看Chrome自身的缓存？可以使用 
 chrome://net-internals/#dns 来进行查看
</code></pre></li>
<li><p>如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</p>
<pre><code> 注：怎么查看操作系统自身的DNS缓存，以Windows系统为
 例，可以在命令行下使用 ipconfig /displaydns 来进行查看
</code></pre></li>
<li><p>如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p>
</li>
<li><p>如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问www.baidu.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.baidu.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.baidu.com  对应的IP地址，该进行一步的动作了。</p>
</li>
</ol>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/1.png" alt></p>
<h3 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h3><p>费了一顿周折终于拿到服务器IP了，下一步自然就是链接到该服务器。对于客户端与服务器的TCP链接，必然要说的就是『三次握手』。</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/2.png" alt></p>
<p><strong>为什么HTTP协议要基于TCP来实现？</strong></p>
<p>目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</p>
<h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><p>与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）：</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/3.png" alt></p>
<p>请求报文<br>在浏览器中查看报文首部（以google浏览器为例）：</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/4.png" alt></p>
<p>请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。具体每个首部字段的作用，这里不做过多阐述。</p>
<h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><p>服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/5.png" alt></p>
<h3 id="返回响应结果"><a href="#返回响应结果" class="headerlink" title="返回响应结果"></a>返回响应结果</h3><p>在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构：</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/6.png" alt></p>
<p>响应报文</p>
<p>在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。</p>
<p>状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类：</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/7.png" alt></p>
<h3 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h3><p>为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/8.png" alt></p>
<h3 id="浏览器解析HTML"><a href="#浏览器解析HTML" class="headerlink" title="浏览器解析HTML"></a>浏览器解析HTML</h3><p>准确地说，浏览器需要加载解析的不仅仅是HTML，还包括CSS、JS。以及还要加载图片、视频等其他媒体资源。</p>
<p>浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。</p>
<p>要注意的是，浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题</p>
<h3 id="浏览器布局渲染"><a href="#浏览器布局渲染" class="headerlink" title="浏览器布局渲染"></a>浏览器布局渲染</h3><p>根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。</p>
<p>replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。</p>
<p>reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。<br>所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。</p>
<p>最后浏览器绘制各个节点，将页面展示给用户。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop Pipes编程</title>
    <url>/2023/12/10/Hadoop-Pipes%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1、Hadoop-Pipes简介"><a href="#1、Hadoop-Pipes简介" class="headerlink" title="1、Hadoop Pipes简介"></a>1、Hadoop Pipes简介</h1><p>Hadoop Pipes是Hadoop MapReduce的C++接口代称。不同于使用标准输入和输出来实现的map代码和reduce代码之间的Streaming编程，Pipes使用Socket作为TaskTracker与C++进程之间数据传输的通道，数据传输为字节流。</p>
<h1 id="2、Hadoop-Pipes编程初探"><a href="#2、Hadoop-Pipes编程初探" class="headerlink" title="2、Hadoop Pipes编程初探"></a>2、Hadoop Pipes编程初探</h1><p>Hadoop Pipes可供开发者编写RecordReader、Mapper、Partitioner、Reducer、RecordWriter五个组件，当然，也可以自定义Combiner。</p>
<p>WordCount.cc 示例，也可以参考该git项目<a href="https://github.com/alexanderkoumis/hadoop-wordcount-cpp/tree/master：">https://github.com/alexanderkoumis/hadoop-wordcount-cpp/tree/master：</a></p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/usr/local/hadoop/include/Pipes.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/usr/local/hadoop/include/TemplateFactory.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/usr/local/hadoop/include/StringUtils.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::string WORDCOUNT = <span class="string">&quot;WORDCOUNT&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string INPUT_WORDS = <span class="string">&quot;INPUT_WORDS&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string OUTPUT_WORDS = <span class="string">&quot;OUTPUT_WORDS&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordCountMap</span>: <span class="keyword">public</span> HadoopPipes::Mapper &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  HadoopPipes::TaskContext::Counter* inputWords;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">WordCountMap</span>(HadoopPipes::TaskContext&amp; context) &#123;</span><br><span class="line">    inputWords = context.<span class="built_in">getCounter</span>(WORDCOUNT, INPUT_WORDS);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">map</span><span class="params">(HadoopPipes::MapContext&amp; context)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; words = </span><br><span class="line">      HadoopUtils::<span class="built_in">splitString</span>(context.<span class="built_in">getInputValue</span>(), <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      context.<span class="built_in">emit</span>(words[i], <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context.<span class="built_in">incrementCounter</span>(inputWords, words.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordCountReduce</span>: <span class="keyword">public</span> HadoopPipes::Reducer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  HadoopPipes::TaskContext::Counter* outputWords;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WordCountReduce</span>(HadoopPipes::TaskContext&amp; context) &#123;</span><br><span class="line">    outputWords = context.<span class="built_in">getCounter</span>(WORDCOUNT, OUTPUT_WORDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reduce</span><span class="params">(HadoopPipes::ReduceContext&amp; context)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (context.<span class="built_in">nextValue</span>()) &#123;</span><br><span class="line">      sum += HadoopUtils::<span class="built_in">toInt</span>(context.<span class="built_in">getInputValue</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    context.<span class="built_in">emit</span>(context.<span class="built_in">getInputKey</span>(), HadoopUtils::<span class="built_in">toString</span>(sum));</span><br><span class="line">    context.<span class="built_in">incrementCounter</span>(outputWords, <span class="number">1</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> HadoopPipes::<span class="built_in">runTask</span>(HadoopPipes::<span class="built_in">TemplateFactory</span>&lt;WordCountMap, WordCountReduce&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意与hadoop pipes 相关的文件放在了目录：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/hadoop/include/</span><br></pre></td></tr></table></figure></p>
<p>主要的文件为Pipes.hh，该头文件定义了一些抽象类，除去开发者需要编写的五大组件之外，还有JobConf、TaskContext、Closeable、Factory四个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Task context provides the information about the task and job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskContext</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Counter to keep track of a property and its value.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">int</span> counterId) : <span class="built_in">id</span>(counterId) &#123;&#125;</span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">const</span> Counter&amp; counter) : <span class="built_in">id</span>(counter.id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the JobConf for the current task.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> JobConf* <span class="title">getJobConf</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the current key.</span></span><br><span class="line"><span class="comment">   * @return the current key</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string&amp; <span class="title">getInputKey</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the current value.</span></span><br><span class="line"><span class="comment">   * @return the current value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string&amp; <span class="title">getInputValue</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Generate an output record</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">emit</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Mark your task as having made progress without changing the status</span></span><br><span class="line"><span class="comment">   * message.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">progress</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set the status message and call progress.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setStatus</span><span class="params">(<span class="type">const</span> std::string&amp; status)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Register a counter with the given group and name.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Counter*</span></span><br><span class="line"><span class="function">    <span class="title">getCounter</span><span class="params">(<span class="type">const</span> std::string&amp; group, <span class="type">const</span> std::string&amp; name)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Increment the value of the counter with the given amount.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">incrementCounter</span><span class="params">(<span class="type">const</span> Counter* counter, <span class="type">uint64_t</span> amount)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">TaskContext</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MapContext</span>: <span class="keyword">public</span> TaskContext &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Access the InputSplit of the mapper.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string&amp; <span class="title">getInputSplit</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the name of the key class of the input to this task.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string&amp; <span class="title">getInputKeyClass</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the name of the value class of the input to this task.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string&amp; <span class="title">getInputValueClass</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReduceContext</span>: <span class="keyword">public</span> TaskContext &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Advance to the next value.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">nextValue</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JobConf：开发者可以通过获得任务的属性<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JobConf</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasKey</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>= <span class="number">0</span>;  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string&amp; <span class="title">get</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>= <span class="number">0</span>;  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getInt</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>= <span class="number">0</span>;  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">getFloat</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>= <span class="number">0</span>;  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">getBoolean</span><span class="params">(<span class="type">const</span> std::string&amp;key)</span> <span class="type">const</span> </span>= <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">JobConf</span>() &#123;&#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Closeable：这个抽象类Mapper、Reducer、RecordReader、RecordWriter的基类，只有两个方法，一个close()，一个析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Closable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Closable</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The application&#x27;s mapper class to do map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mapper</span>: <span class="keyword">public</span> Closable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">map</span><span class="params">(MapContext&amp; context)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The application&#x27;s reducer class to do reduce.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reducer</span>: <span class="keyword">public</span> Closable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">reduce</span><span class="params">(ReduceContext&amp; context)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For applications that want to read the input directly for the map function</span></span><br><span class="line"><span class="comment"> * they can define RecordReaders in C++.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RecordReader</span>: <span class="keyword">public</span> Closable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">next</span><span class="params">(std::string&amp; key, std::string&amp; value)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The progress of the record reader through the split as a value between</span></span><br><span class="line"><span class="comment">   * 0.0 and 1.0.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">getProgress</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An object to write key/value pairs as they are emited from the reduce.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RecordWriter</span>: <span class="keyword">public</span> Closable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">emit</span><span class="params">(<span class="type">const</span> std::string&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> std::string&amp; value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Factory：一个抽象工厂，用来创建各个组件，是模板工厂的基类，具体的可以参见TemplateFactory.hh。开发者在调用runTask时，创建相应的Factory传入即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A factory to create the necessary application objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Mapper* <span class="title">createMapper</span><span class="params">(MapContext&amp; context)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Reducer* <span class="title">createReducer</span><span class="params">(ReduceContext&amp; context)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create a combiner, if this application has one.</span></span><br><span class="line"><span class="comment">   * @return the new combiner or NULL, if one is not needed</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Reducer* <span class="title">createCombiner</span><span class="params">(MapContext&amp; context)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create an application partitioner object.</span></span><br><span class="line"><span class="comment">   * @return the new partitioner or NULL, if the default partitioner should be</span></span><br><span class="line"><span class="comment">   *     used.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Partitioner* <span class="title">createPartitioner</span><span class="params">(MapContext&amp; context)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create an application record reader.</span></span><br><span class="line"><span class="comment">   * @return the new RecordReader or NULL, if the Java RecordReader should be</span></span><br><span class="line"><span class="comment">   *    used.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> RecordReader* <span class="title">createRecordReader</span><span class="params">(MapContext&amp; context)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create an application record writer.</span></span><br><span class="line"><span class="comment">   * @return the new RecordWriter or NULL, if the Java RecordWriter should be</span></span><br><span class="line"><span class="comment">   *    used.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> RecordWriter* <span class="title">createRecordWriter</span><span class="params">(ReduceContext&amp; context)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the assigned task in the framework.</span></span><br><span class="line"><span class="comment"> * The user&#x27;s main function should set the various functions using the</span></span><br><span class="line"><span class="comment"> * set* functions above and then call this.</span></span><br><span class="line"><span class="comment"> * @return true, if the task succeeded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">runTask</span><span class="params">(<span class="type">const</span> Factory&amp; factory)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="3、Hadoop-Pipes编程"><a href="#3、Hadoop-Pipes编程" class="headerlink" title="3、Hadoop Pipes编程"></a>3、Hadoop Pipes编程</h1><p>有了以上的基础知识，就可以开始编写MapReduce任务了。我们可以直接从examples着手，先来看看wordcount.cc。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wordcount-simple.cc -&gt; Mapper &amp; Reducer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordCountMap</span>: <span class="keyword">public</span> HadoopPipes::Mapper &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  HadoopPipes::TaskContext::Counter* inputWords;  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">WordCountMap</span>(HadoopPipes::TaskContext&amp; context) &#123;  </span><br><span class="line">    inputWords = context.<span class="built_in">getCounter</span>(WORDCOUNT, INPUT_WORDS);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">map</span><span class="params">(HadoopPipes::MapContext&amp; context)</span> </span>&#123;  </span><br><span class="line">    std::vector&lt;std::string&gt; words =   </span><br><span class="line">      HadoopUtils::<span class="built_in">splitString</span>(context.<span class="built_in">getInputValue</span>(), <span class="string">&quot; &quot;</span>);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;  </span><br><span class="line">      context.<span class="built_in">emit</span>(words[i], <span class="string">&quot;1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    context.<span class="built_in">incrementCounter</span>(inputWords, words.<span class="built_in">size</span>());  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordCountReduce</span>: <span class="keyword">public</span> HadoopPipes::Reducer &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  HadoopPipes::TaskContext::Counter* outputWords;  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">WordCountReduce</span>(HadoopPipes::TaskContext&amp; context) &#123;  </span><br><span class="line">    outputWords = context.<span class="built_in">getCounter</span>(WORDCOUNT, OUTPUT_WORDS);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reduce</span><span class="params">(HadoopPipes::ReduceContext&amp; context)</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (context.<span class="built_in">nextValue</span>()) &#123;  </span><br><span class="line">      sum += HadoopUtils::<span class="built_in">toInt</span>(context.<span class="built_in">getInputValue</span>());  </span><br><span class="line">    &#125;  </span><br><span class="line">    context.<span class="built_in">emit</span>(context.<span class="built_in">getInputKey</span>(), HadoopUtils::<span class="built_in">toString</span>(sum));  </span><br><span class="line">    context.<span class="built_in">incrementCounter</span>(outputWords, <span class="number">1</span>);   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">该任务编写了两个主要组件，mapper与reducer。要实现这两个组件需要继承相应的基类。基类声明如下：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="comment">// wordcount-simple.cc -&gt; Mapper &amp; Reducer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordCountMap</span>: <span class="keyword">public</span> HadoopPipes::Mapper &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  HadoopPipes::TaskContext::Counter* inputWords;  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">WordCountMap</span>(HadoopPipes::TaskContext&amp; context) &#123;  </span><br><span class="line">    inputWords = context.<span class="built_in">getCounter</span>(WORDCOUNT, INPUT_WORDS);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">map</span><span class="params">(HadoopPipes::MapContext&amp; context)</span> </span>&#123;  </span><br><span class="line">    std::vector&lt;std::string&gt; words =   </span><br><span class="line">      HadoopUtils::<span class="built_in">splitString</span>(context.<span class="built_in">getInputValue</span>(), <span class="string">&quot; &quot;</span>);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;  </span><br><span class="line">      context.<span class="built_in">emit</span>(words[i], <span class="string">&quot;1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    context.<span class="built_in">incrementCounter</span>(inputWords, words.<span class="built_in">size</span>());  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordCountReduce</span>: <span class="keyword">public</span> HadoopPipes::Reducer &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  HadoopPipes::TaskContext::Counter* outputWords;  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">WordCountReduce</span>(HadoopPipes::TaskContext&amp; context) &#123;  </span><br><span class="line">    outputWords = context.<span class="built_in">getCounter</span>(WORDCOUNT, OUTPUT_WORDS);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reduce</span><span class="params">(HadoopPipes::ReduceContext&amp; context)</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (context.<span class="built_in">nextValue</span>()) &#123;  </span><br><span class="line">      sum += HadoopUtils::<span class="built_in">toInt</span>(context.<span class="built_in">getInputValue</span>());  </span><br><span class="line">    &#125;  </span><br><span class="line">    context.<span class="built_in">emit</span>(context.<span class="built_in">getInputKey</span>(), HadoopUtils::<span class="built_in">toString</span>(sum));  </span><br><span class="line">    context.<span class="built_in">incrementCounter</span>(outputWords, <span class="number">1</span>);   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">该任务编写了两个主要组件，mapper与reducer。要实现这两个组件需要继承相应的基类。基类声明如下：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="comment">// wordcount-simple.cc -&gt; Mapper &amp; Reducer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordCountMap</span>: <span class="keyword">public</span> HadoopPipes::Mapper &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  HadoopPipes::TaskContext::Counter* inputWords;  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">WordCountMap</span>(HadoopPipes::TaskContext&amp; context) &#123;  </span><br><span class="line">    inputWords = context.<span class="built_in">getCounter</span>(WORDCOUNT, INPUT_WORDS);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">map</span><span class="params">(HadoopPipes::MapContext&amp; context)</span> </span>&#123;  </span><br><span class="line">    std::vector&lt;std::string&gt; words =   </span><br><span class="line">      HadoopUtils::<span class="built_in">splitString</span>(context.<span class="built_in">getInputValue</span>(), <span class="string">&quot; &quot;</span>);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;  </span><br><span class="line">      context.<span class="built_in">emit</span>(words[i], <span class="string">&quot;1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    context.<span class="built_in">incrementCounter</span>(inputWords, words.<span class="built_in">size</span>());  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordCountReduce</span>: <span class="keyword">public</span> HadoopPipes::Reducer &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  HadoopPipes::TaskContext::Counter* outputWords;  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">WordCountReduce</span>(HadoopPipes::TaskContext&amp; context) &#123;  </span><br><span class="line">    outputWords = context.<span class="built_in">getCounter</span>(WORDCOUNT, OUTPUT_WORDS);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reduce</span><span class="params">(HadoopPipes::ReduceContext&amp; context)</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (context.<span class="built_in">nextValue</span>()) &#123;  </span><br><span class="line">      sum += HadoopUtils::<span class="built_in">toInt</span>(context.<span class="built_in">getInputValue</span>());  </span><br><span class="line">    &#125;  </span><br><span class="line">    context.<span class="built_in">emit</span>(context.<span class="built_in">getInputKey</span>(), HadoopUtils::<span class="built_in">toString</span>(sum));  </span><br><span class="line">    context.<span class="built_in">incrementCounter</span>(outputWords, <span class="number">1</span>);   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">该任务编写了两个主要组件，mapper与reducer。要实现这两个组件需要继承相应的基类。基类声明如下：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="comment">// wordcount-simple.cc -&gt; Mapper &amp; Reducer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordCountMap</span>: <span class="keyword">public</span> HadoopPipes::Mapper &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  HadoopPipes::TaskContext::Counter* inputWords;  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">WordCountMap</span>(HadoopPipes::TaskContext&amp; context) &#123;  </span><br><span class="line">    inputWords = context.<span class="built_in">getCounter</span>(WORDCOUNT, INPUT_WORDS);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">map</span><span class="params">(HadoopPipes::MapContext&amp; context)</span> </span>&#123;  </span><br><span class="line">    std::vector&lt;std::string&gt; words =   </span><br><span class="line">      HadoopUtils::<span class="built_in">splitString</span>(context.<span class="built_in">getInputValue</span>(), <span class="string">&quot; &quot;</span>);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;  </span><br><span class="line">      context.<span class="built_in">emit</span>(words[i], <span class="string">&quot;1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    context.<span class="built_in">incrementCounter</span>(inputWords, words.<span class="built_in">size</span>());  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordCountReduce</span>: <span class="keyword">public</span> HadoopPipes::Reducer &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  HadoopPipes::TaskContext::Counter* outputWords;  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">WordCountReduce</span>(HadoopPipes::TaskContext&amp; context) &#123;  </span><br><span class="line">    outputWords = context.<span class="built_in">getCounter</span>(WORDCOUNT, OUTPUT_WORDS);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reduce</span><span class="params">(HadoopPipes::ReduceContext&amp; context)</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (context.<span class="built_in">nextValue</span>()) &#123;  </span><br><span class="line">      sum += HadoopUtils::<span class="built_in">toInt</span>(context.<span class="built_in">getInputValue</span>());  </span><br><span class="line">    &#125;  </span><br><span class="line">    context.<span class="built_in">emit</span>(context.<span class="built_in">getInputKey</span>(), HadoopUtils::<span class="built_in">toString</span>(sum));  </span><br><span class="line">    context.<span class="built_in">incrementCounter</span>(outputWords, <span class="number">1</span>);   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">该任务编写了两个主要组件，mapper与reducer。要实现这两个组件需要继承相应的基类。基类声明如下：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordCountMap</span>: <span class="keyword">public</span> HadoopPipes::Mapper &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  HadoopPipes::TaskContext::Counter* inputWords;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">WordCountMap</span>(HadoopPipes::TaskContext&amp; context) &#123;</span><br><span class="line">    inputWords = context.<span class="built_in">getCounter</span>(WORDCOUNT, INPUT_WORDS);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">map</span><span class="params">(HadoopPipes::MapContext&amp; context)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; words = </span><br><span class="line">      HadoopUtils::<span class="built_in">splitString</span>(context.<span class="built_in">getInputValue</span>(), <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      context.<span class="built_in">emit</span>(words[i], <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context.<span class="built_in">incrementCounter</span>(inputWords, words.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordCountReduce</span>: <span class="keyword">public</span> HadoopPipes::Reducer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  HadoopPipes::TaskContext::Counter* outputWords;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WordCountReduce</span>(HadoopPipes::TaskContext&amp; context) &#123;</span><br><span class="line">    outputWords = context.<span class="built_in">getCounter</span>(WORDCOUNT, OUTPUT_WORDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reduce</span><span class="params">(HadoopPipes::ReduceContext&amp; context)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (context.<span class="built_in">nextValue</span>()) &#123;</span><br><span class="line">      sum += HadoopUtils::<span class="built_in">toInt</span>(context.<span class="built_in">getInputValue</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    context.<span class="built_in">emit</span>(context.<span class="built_in">getInputKey</span>(), HadoopUtils::<span class="built_in">toString</span>(sum));</span><br><span class="line">    context.<span class="built_in">incrementCounter</span>(outputWords, <span class="number">1</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该任务编写了两个主要组件，mapper与reducer。要实现这两个组件需要继承相应的基类，继承了相应的基类，就可以大胆的通过context获得key/value实现自己的逻辑了，结果处理完毕后，需要通过context.emit(key, value)将结果发送到下一阶段。</p>
<p>注：</p>
<ol>
<li><p>由于Factory创建对象需要传入Context对象，所以还需要实现一个构造函数，参数为TaskContext。</p>
</li>
<li><p>Hadoop Pipes内部规定，map与reduce的key/value均为Text类型，在C++中表现为string类型。不过，Hadoop还是做得比较贴心，有专门的方法负责处理string，具体可以参见StringUtils.hh。</p>
</li>
<li><p>Counter可以称之为统计器，可供开发者统计一些需要的数据，如读入行数、处理字节数等。任务完毕后，可以在web控制参看结果。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wordcount-part.cc -&gt; Partitioner</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordCountPartitioner</span>: <span class="keyword">public</span> HadoopPipes::Partitioner &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordCountPartitioner</span>(HadoopPipes::TaskContext&amp; context)&#123;&#125;</span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">int</span> numOfReduces)</span> </span>&#123;   </span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该实例在提供简单Mapper与Reducer方法的同时，还提供了Partitioner，实例实现较为简单，直接返回了第一个reduce位置。开发者自定义的Partitioner同mapper/reducer一致，需要继承其基类HadoopPipes:: Partitioner，也需要提供一个传入TaskContext的构造函数，它的声明如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Partitioner</span> &#123;   </span><br><span class="line">   <span class="keyword">public</span>:   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">int</span> numOfReduces)</span> </span>= <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Partitioner</span>() &#123;&#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>Partitioner编写方法与Java的一致，对于partition方法，框架会自动为它传入两个参数，分别为key值和reduce task的个数numOfReduces，用户只需返回一个0~ numOfReduces-1的值即可。</p>
<p>RecordReader/RecordWriter实现较长，这里就不贴了，贴一下这俩的基类：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecordReader</span>: <span class="keyword">public</span> Closable &#123;   </span><br><span class="line">   <span class="keyword">public</span>:   </span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">next</span><span class="params">(std::string&amp; key, std::string&amp; value)</span> </span>= <span class="number">0</span>;   <span class="number">4.</span>   <span class="comment">// 读进度   </span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">getProgress</span><span class="params">()</span> </span>= <span class="number">0</span>;   </span><br><span class="line">&#125;;   </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RecordWriter</span>: <span class="keyword">public</span> Closable &#123;   </span><br><span class="line">   <span class="keyword">public</span>:   </span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">emit</span><span class="params">(<span class="type">const</span> std::string&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> std::string&amp; value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>对于RecordReader，用户自定义的构造函数需携带类型为HadoopPipes::MapContext的参数（而不能是TaskContext），通过该参数的getInputSplit()的方法，用户可以获取经过序列化的InpuSplit对象，Java端采用不同的InputFormat可导致InputSplit对象格式不同，但对于大多数InpuSplit对象，它们可以提供至少三个信息：当前要处理的InputSplit所在的文件名，所在文件中的偏移量，它的长度。用户获取这三个信息后，可使用libhdfs库读取文件，以实现next方法。</p>
<p>用户自定的RecordWriter的构造函数需携带参数TaskContext，通过该参数的getJobConf()可获取一个HadoopPipes::JobConf的对象，用户可从该对象中获取该reduce task的各种参数，如：该reduce task的编号（这对于确定输出文件名有用），reduce task的输出目录等。同时实现emit方法，将数据写入文件。</p>
<h1 id="4、Hadoop-Pipes任务提交"><a href="#4、Hadoop-Pipes任务提交" class="headerlink" title="4、Hadoop Pipes任务提交"></a>4、Hadoop Pipes任务提交</h1><p>Hadoop Pipes任务提交命令根据Hadoop版本而不一，主体的命令有如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop pipes [-conf ] [-D , , …] [-input ] [-output ] [-jar ] [-inputformat ] [-map ] [-partitioner ] [-reduce ] [-writer ] [-program ]</span><br><span class="line"></span><br><span class="line">示例：hadoop pipes -conf word.xml -input input -output output</span><br></pre></td></tr></table></figure></p>
<p>具体可以参考<a href="https://developer.aliyun.com/article/174041">《Hadoop实战第2版》——3.5节Hadoop Pipes</a></p>
<h1 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a>5、小结</h1><p>本篇博文简要了说了一下Hadoop Pipes的使用方法。</p>
<p>在这里贴一下快手大佬董西成的优化意见：为了提高系能，RecordReader和RecordWriter最好采用Java代码实现（或者重用Hadoop中自带的），这是因为Hadoop自带的C++库libhdfs采用JNI实现，底层还是要调用Java相关接口，效率很低，此外，如果要处理的文件为二进制文件或者其他非文本文件，libhdfs可能不好处理。</p>
]]></content>
      <categories>
        <category>Hadoop Pipes</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + GitHub Pages 搭建个人博客</title>
    <url>/2020/03/19/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><h4 id="1、安装Node-js"><a href="#1、安装Node-js" class="headerlink" title="1、安装Node.js"></a>1、安装Node.js</h4><p>(1) 下载Node.js：<a href="https://nodejs.org/en/download/">官网下载地址</a> （这里以Windows 为例）;</p>
<p><img src="/images/node.png" alt><br><span id="more"></span><br>(2) 双击下载好的.msi文件，按下一步下一步，安装好就可以；</p>
<p>(3) 在cmd命令窗口，输入下面的这个命令，如果能够显示Node.js的版本，说明安装成功了。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><br><img src="/images/node_v.png" alt></p>
<h4 id="2、安装Git"><a href="#2、安装Git" class="headerlink" title="2、安装Git"></a>2、安装Git</h4><p>(1) 下载Git：<a href="https://git-scm.com/downloads">官网下载</a></p>
<p>(2) 双击下载好的Git安装包，按下一步下一步，进行安装即可；</p>
<p>(3) 在cmd命令窗口，输入下面的这个命令，如果能够显示Git的版本，说明安装成功了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p><img src="/images/git_v.png" alt></p>
<h3 id="二、Hexo搭建博客"><a href="#二、Hexo搭建博客" class="headerlink" title="二、Hexo搭建博客"></a>二、Hexo搭建博客</h3><h4 id="1、安装Hexo"><a href="#1、安装Hexo" class="headerlink" title="1、安装Hexo"></a>1、安装Hexo</h4><p>（1）在计算机中，新建一个Blog文件夹，用于存放自己的博客内容。</p>
<p>（2）在Blog文件夹内，鼠标右键，选择Git Bash,进入到命令窗口</p>
<p><img src="/images/blog.png" alt></p>
<p>（3）在命令窗口中，输入下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h4 id="2、初始化Hexo"><a href="#2、初始化Hexo" class="headerlink" title="2、初始化Hexo"></a>2、初始化Hexo</h4><p>在命令窗口中，输入下面代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<h4 id="3、配置Hexo"><a href="#3、配置Hexo" class="headerlink" title="3、配置Hexo"></a>3、配置Hexo</h4><p>(1) 安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>(2) 部署形成的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g //或者 hexo generate</span><br></pre></td></tr></table></figure>
<h4 id="4、启动服务器"><a href="#4、启动服务器" class="headerlink" title="4、启动服务器"></a>4、启动服务器</h4><p>(1) 在命令窗口执行下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s  //或者 hexo server</span><br></pre></td></tr></table></figure>
<p>(2) 在浏览器地址栏中输入<a href="http://localhost:4000/">http://localhost:4000/</a> （默认端口是4000），如果能够看到如图所示的效果，说明初始化的Hexo博客搭建成功了。<br>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-blog.png" alt></p>
<h4 id="三、将本地的-Hexo-博客部署到-GitHub-Pages上"><a href="#三、将本地的-Hexo-博客部署到-GitHub-Pages上" class="headerlink" title="三、将本地的 Hexo 博客部署到 GitHub Pages上"></a>三、将本地的 Hexo 博客部署到 GitHub Pages上</h4><p>（1）新建一个仓库，仓库名为bryceustc.github.io（这个仓库的名称必须严格按照 username.github.io 的格式来命名）【前提是你要有一个Github账号】<br>如图所示：（因为我已经创建过这个库了，所以会显示红色警告，只是后来为了截图，重新写一个同名的）</p>
<p><img src="/images/github.png" alt></p>
<p>（2）进入已经创建好的仓库（点击自己的头像，选择Your profile，点击刚创建好的那个仓库进去仓库里面），点击settings，找到GitHub Pages 选项，点击 Choose a theme 选择一个主题（可以选择也可以不选择，根据自己的需求决定是否操作这一步）<br>如图所示：</p>
<p><img src="/images/gitpages.png" alt></p>
<p>（3）配置Git个人信息，在winneyBlog目录下，鼠标右键，选择Git Bash，进入命令窗口，输入下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Github用户名&quot;       //自己Github的账号名</span><br><span class="line">git config --global user.email &quot;Github邮箱&quot;        //自己注册Github的邮箱地址</span><br></pre></td></tr></table></figure>
<p>（4）生成SSH KEY,意思是生成一个公钥和密钥，因为Github需要一个密钥才能与本地相连接。在命令窗口输入下面的命令，然后需要连续按3次回车生成密钥（每按一次回车你可以看到对应的信息） 【你也可以先查看是否已经有了ssh密钥：cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C  &quot;Github邮箱&quot;        //自己注册Github的邮箱地址</span><br></pre></td></tr></table></figure>
<p>如图所示：<br><img src="https://raw.githubusercontent.com/winney07/Images/main/winney07.github.io/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh-key.png" alt></p>
<p>（5）生成的SSH KEY会保存到 C:/Users/电脑名用户名/.ssh 目录中（根据你自己电脑用户名，打开对应的目录）</p>
<ul>
<li>打开.ssh 这个目录，打开 id_rsa.pub 文件，复制里面的全部内容（这些内容就是密钥）<br><img src="https://raw.githubusercontent.com/winney07/Images/main/winney07.github.io/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/add-key.png" alt></li>
</ul>
<p>（6）在GitHub中添加SSH keys</p>
<ul>
<li><p>打开Github，点击头像，选择Settings；</p>
</li>
<li><p>选择SSH and GPG keys项,点击右上角New SSH key按钮，将刚刚复制到的密钥粘贴到key输入框中，title自己给它命一个名就好<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/add-key.png" alt></p>
</li>
<li><p>最后点击Add Key，如果显示这样的界面，说明SSH KEY 配置成功：<br><img src="https://raw.githubusercontent.com/winney07/Images/main/winney07.github.io/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh-keys.png" alt></p>
</li>
</ul>
<p>（7）修改全局配置文件</p>
<ul>
<li><p>在blog文件夹下，找到_config.yml文件；如图所示：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy.png" alt></p>
</li>
<li><p>修改_config.yml文件里的deploy属性(目的是将本地hexo项目放到Github上)如图所示：<br><img src="https://raw.githubusercontent.com/winney07/Images/main/winney07.github.io/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy.png" alt></p>
</li>
</ul>
<p><strong>注：</strong>【如果repository中填写的是https协议的，hexo d上传代码到Github时有下面类似错误，可以将repository改为ssh的链接】<br>如图所示：</p>
<p><img src="https://raw.githubusercontent.com/winney07/Images/main/winney07.github.io/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy-error.png" alt></p>
<p><img src="https://raw.githubusercontent.com/winney07/Images/main/winney07.github.io/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/git-href.png" alt></p>
<p>（8）安装hexo-deployer-git 插件，目的是将代码快速托管到Github上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>（9）将hexo项目托管到GitHub上（命令可以分开写也可以一起写）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>备注:<br>hexo clean // 清除缓存文件 (db.json) 和已生成的静态文件 (public)</p>
<p>hexo generate // 部署之前预先生成静态文件，简写为hexo g</p>
<p>hexo deploy // 文件生成后立即部署网站，简写为hexo d</p>
<p>（10）在浏览器地址栏输入 <a href="https://username.github.io/">https://username.github.io/</a> 即可访问，（username也就是你的Github账户名），如果能够正常访问，并且跟本地hexo项目显示的内容是一样的，那么说明你已经把本地hexo项目部署到Github上了。</p>
<h4 id="四、配置博客的个人信息"><a href="#四、配置博客的个人信息" class="headerlink" title="四、配置博客的个人信息"></a>四、配置博客的个人信息</h4><p>（1）在hexo目录中，找到全局配置文件_config.yml</p>
<p>（2）配置信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: Bryce&#x27;s Blog</span><br><span class="line">subtitle: Learn Everything.</span><br><span class="line">description: A Student From USTC.</span><br><span class="line">author: Bryce</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone: Asia/Shanghai</span><br><span class="line"></span><br><span class="line"># URL 博客地址</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">url: https://bryceustc.github.io/</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br><span class="line"></span><br><span class="line"># Directory 目录设置</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link:</span><br><span class="line">  enable: true # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: &#x27;&#x27;</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: true</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace: &#x27;&#x27;</span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br><span class="line"></span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 5 #每页文章数量</span><br><span class="line">  order_by: -date</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Metadata elements</span><br><span class="line">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span><br><span class="line">meta_generator: true</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">## Use post&#x27;s date for updated date unless set in front-matter</span><br><span class="line">use_date_for_updated: false</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Include / Exclude file(s)</span><br><span class="line">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class="line">include:</span><br><span class="line">exclude:</span><br><span class="line">ignore:</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br><span class="line">plugins: hexo-generate-feed</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/bryceustc/bryceustc.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>注意：.yml 文件有严格的格式要求，文件里所有的配置都是：冒号 空格 值，并且冒号是英文状态下的输入。想了解更多的可以前往官网。</p>
<p>（3）在博客目录下，右键点击Git Bash，进去命令窗口，输入下面的命令，即可在浏览器中看到刚刚设置的内容显示在页面中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server    //简写为hexo s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP字符串</title>
    <url>/2020/09/03/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="KMP是什么，做什么用的"><a href="#KMP是什么，做什么用的" class="headerlink" title="KMP是什么，做什么用的"></a>KMP是什么，做什么用的</h3><p>KMP全称为Knuth Morris Pratt算法，三个单词分别是三个作者的名字。KMP是一种高效的字符串匹配算法，用来在主字符串中查找模式字符串的位置(比如在“hello,world”主串中查找“world”模式串的位置)。</p>
<h3 id="KMP算法的高效体现在哪"><a href="#KMP算法的高效体现在哪" class="headerlink" title="KMP算法的高效体现在哪"></a>KMP算法的高效体现在哪</h3><p>高效性是通过和其他字符串搜索算法对比得到的，在这里拿BF(Brute Force)算法做一下对比。BF算法是一种最朴素的暴力搜索算法。它的思想是在主串的[0, n-m]区间内依次截取长度为m的子串，看子串是否和模式串一样(n是主串的长度，m是子串的长度)。代码是这样:<br><span id="more"></span><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bf</span><span class="params">(string main, string pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (main.<span class="built_in">size</span>() == <span class="number">0</span> || pattern.<span class="built_in">size</span>() == <span class="number">0</span> || main.<span class="built_in">size</span>() &lt; pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 异常判断，若不存在返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = main.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n-m; i++) &#123;</span><br><span class="line">        string s = main.<span class="built_in">substr</span>(i, m)  <span class="comment">// s = main[i : i+m] 截出主串中的对比串</span></span><br><span class="line">        <span class="keyword">if</span> (s == pattern) &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">//返回索引值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 主串中不存在模式串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BF的时间复杂度是O(N*N)，存在很大优化空间。当模式串和主串匹配时，遇到模式串中某个字符不能匹配的情况，对于模式串中已经匹配过的那些字符，如果我们能找到一些规律，将模式串多往后移动几位，而不是像BF算法一样，每次把模式串移动一位，就可以提高算法的效率。比如说在“ababaababacd”中查找“ababac”，可以避免一些字符之间的比较。</p>
<p>下面通过一个具体的例子来看看可以跳过的情况。比如主模式串是”ababaeaba”,模式串是”ababacd”,在BF算法中，遇到不匹配的情况是这样处理的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:    &quot;ababaeaba&quot; // 例如这两个串，当sub为&quot;ababaea&quot;时和&quot;ababacd&quot;进行对比</span><br><span class="line">pattern: &quot;ababacd&quot;   // ，当main[i]为e时，发现和pattern[j]的值e不一致</span><br><span class="line">//BF的做法是去下一个sub,即用&quot;babaeab&quot;和pattern进行比较。</span><br></pre></td></tr></table></figure>
<p>我们希望找到一些规律，遇到两个字符不匹配的情况时，希望可以多跳几个字符，减少比较次数。KMP算法的思想是：在模式串和主串匹配过程中，当遇到不匹配的字符时，对于主串和模式串中已对比过相同的前缀字符串，找到长度最长的相等前缀串，从而将模式串一次性滑动多位，并省略一些比较过程。在上个例子，KMP算法中，是这样处理的：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:    &quot;ababaeaba&quot; // 比如main中的&quot;ababa&quot;子串，对标为[2~4]的&quot;aba&quot;和pattern中下</span><br><span class="line">pattern: &quot;ababacd&quot;   // 标为[0~2]的&quot;aba&quot;相同,此时可以滑动j-k位,即j=j-k。(其中j是</span><br><span class="line">                                         // pattern中&quot;c&quot;的下标,k是&quot;aba&quot;的长度)。</span><br><span class="line">            &quot;ababaeaba&quot;      // 比较过程中，main[5]为&quot;e&quot;和pattern[5]为&quot;c&quot;不匹配，但是两个</span><br><span class="line">            &quot;ababacd&quot;            // 串中都有相同的&quot;aba&quot;前缀,所以可以滑动j-k位</span><br><span class="line">                    |           </span><br><span class="line">                    ∨</span><br><span class="line">            &quot;ababaeaba&quot;   </span><br><span class="line">                &quot;ababacd&quot;</span><br><span class="line">                    |               // 滑动j-k位后发现main[5]和patterb[3]不相同，需要再次滑动</span><br><span class="line">                    ∨</span><br><span class="line">            &quot;ababaeaba&quot;   </span><br><span class="line">                    &quot;ababacd&quot; // 滑动过程和上次类似。</span><br></pre></td></tr></table></figure></p>
<h3 id="如何KMP算法的next数组"><a href="#如何KMP算法的next数组" class="headerlink" title="如何KMP算法的next数组"></a>如何KMP算法的next数组</h3><p>再次明确next数组的含义 : <strong>next数组用来存模式串中每个前缀最长的能匹配前缀子串的结尾字符的下标</strong>。 next[i] = j 表示下标以i-j为起点，i为终点的后缀和下标以0为起点，j为终点的前缀相等，且此字符串的长度最长。用符号表示为p[0~j] == p[i-j~i]。下面以”ababacd”模式串为例，给出这个串的next数组</p>
<p><img src="/2020/09/03/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2/1.png" alt></p>
<h3 id="KMP的代码"><a href="#KMP的代码" class="headerlink" title="KMP的代码"></a>KMP的代码</h3><p>下面给出KMP算法的完整代码，里面有详细的注释。代码从下标1开始。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(string s, string pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把next数组中全部初始化为-1</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//求next数组中的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++ ) &#123;<span class="comment">// i从1开始,因为第一个字符如果比较失败了,需重新开始匹配 // i取不到m-1的值, 因为取到m-1意味着整个字符串都相等</span></span><br><span class="line">        j = next[i<span class="number">-1</span>];  <span class="comment">// 前i-1的值是之前循环中比较过的,这里j初始化为next[i-1]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[i] != pattern[j+<span class="number">1</span>]) &#123; <span class="comment">// 因为这里是pattern[i]和pattern[j+1]进行比较</span></span><br><span class="line">            j = next[j]; <span class="comment">// 所以这里j是退回到next[j]的位置再进行循环比较</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern[j+<span class="number">1</span>] == pattern[i]) &#123;  <span class="comment">//因为每次循环只会新增一个字符,所以这里用if判断一个新字母即可.</span></span><br><span class="line">            j++;   <span class="comment">// 如果相等则j++</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next[i] = j; <span class="comment">// 当前的取值</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 匹配的过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//模式串从0下标开始匹配</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != pattern[j]) &#123;</span><br><span class="line">            j = next[j<span class="number">-1</span>] + <span class="number">1</span>; <span class="comment">// pattern[j]和s[i]不一致,说明前next[j-1]是匹配的,所以移动next[j-1]位;因为s[i]要继续和pattern[j]进行比较,所以j还需加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == pattern[j]) j++;</span><br><span class="line">        <span class="keyword">if</span> ( j == m<span class="number">-1</span>) <span class="keyword">return</span> i - m + <span class="number">1</span>;  <span class="comment">//因为j从下标0开始,所以m需减1,两者相等说明循环了len(m)次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + NexT主题博客相关设置</title>
    <url>/2020/03/21/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="一、添加文章版权声明功能"><a href="#一、添加文章版权声明功能" class="headerlink" title="一、添加文章版权声明功能"></a>一、添加文章版权声明功能</h4><p>打开博客目录下的主题配置文件（/themes/next/_config.yml），找到Declare license on posts 标签，进行配置：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Declare license on posts</span><br><span class="line">post_copyright:</span><br><span class="line">  enable: true    #激活版权声明模块</span><br><span class="line">  license: CC BY-NC-SA 3.0     #版权许可协议</span><br><span class="line">  license_url: https://winney07.github.io/      #声明的文章的可点击链接（域名）</span><br></pre></td></tr></table></figure><br><span id="more"></span><br>配置完后，执行以下命令，在浏览器中访问，效果如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/next-set1.png" alt></p>
<h4 id="二、设置favicon图标"><a href="#二、设置favicon图标" class="headerlink" title="二、设置favicon图标"></a>二、设置favicon图标</h4><p>1、选择一个favicon制作网站完成制作，例如：比特虫 ，制作一个16*16，一个32*32的；</p>
<p>2、两个不同尺寸大小的文件，重名为favicon-16x16-next.png和favicon-32x32-next.png；</p>
<p>3、将重命名的两个图片文件放到博客目录下的themes/next/source/images中（覆盖原来的两个默认的）<br>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/favicon.png" alt></p>
<h3 id="三、添加友情链接"><a href="#三、添加友情链接" class="headerlink" title="三、添加友情链接"></a>三、添加友情链接</h3><p>打开主题配置文件（/themes/next/_config.yml），找到以下内容进行修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: 友情链接 </span><br><span class="line"># links_layout: block   //块状显示（选择了行内显示，这个要注释掉，不然会报错）</span><br><span class="line">links_layout: inline    //行内显示</span><br><span class="line">links:</span><br><span class="line">  小超: https://www.xiaochao.me/</span><br><span class="line">  Github: https://www.github.com</span><br></pre></td></tr></table></figure>
<p>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/friend-link.png" alt></p>
<h4 id="四、调整hexo页面宽度"><a href="#四、调整hexo页面宽度" class="headerlink" title="四、调整hexo页面宽度"></a>四、调整hexo页面宽度</h4><p>博客在浏览器上的留白太多，因此想增加文章的宽度。</p>
<p>打开/themes/next/source/css/_variables/custom.styl 添加两行代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$main-desktop = 1200px </span><br><span class="line">$content-desktop = 900px</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令总结</title>
    <url>/2020/07/05/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>整理一下自己在实习工作期间，常用的Linux操作命令，加深印象，熟悉一下。</p>
<h3 id="查看日志相关："><a href="#查看日志相关：" class="headerlink" title="查看日志相关："></a>查看日志相关：</h3><h4 id="tail"><a href="#tail" class="headerlink" title="tail:"></a>tail:</h4><p>-n  是显示行号；相当于nl命令；用例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -100f test.log      实时监控100行日志</span><br><span class="line"></span><br><span class="line">tail  -n  10  test.log   查询日志尾部最后10行的日志;</span><br><span class="line"></span><br><span class="line">tail -n +10 test.log    查询10行之后的所有日志;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="head"><a href="#head" class="headerlink" title="head:"></a>head:</h4><p>跟tail是相反的，tail是看后多少行日志；例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head -n 10  test.log   查询日志文件中的头10行日志;</span><br><span class="line"></span><br><span class="line">head -n -10  test.log   查询日志文件除了最后10行的其他所有日志;</span><br></pre></td></tr></table></figure>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat -n test.log |grep &quot;debug&quot;   查询关键字的日志</span><br></pre></td></tr></table></figure>
<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>直接用vim查看，用 / 搜索，gg 快速跳转行首、G 快速跳转到末尾、Ctrl + F 想下翻页、Ctrl + B 向上翻页</p>
<h3 id="less-more-命令"><a href="#less-more-命令" class="headerlink" title="less / more 命令"></a>less / more 命令</h3><p>空格翻页</p>
<h4 id="列出几种常见的应用场景："><a href="#列出几种常见的应用场景：" class="headerlink" title="列出几种常见的应用场景："></a>列出几种常见的应用场景：</h4><p>应用场景一：按行号查看—-过滤出关键字附近的日志<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     1）cat -n test.log |grep &quot;debug&quot;  得到关键日志的行号</span><br><span class="line"></span><br><span class="line">     2）cat -n test.log |tail -n +92|head -n 20  选择关键字所在的中间一行. 然后查看这个关键字前10行和后10行的日志:</span><br><span class="line"></span><br><span class="line">       tail -n +92表示查询92行之后的日志</span><br><span class="line"></span><br><span class="line">       head -n 20 则表示在前面的查询结果里再查前20条记录</span><br></pre></td></tr></table></figure></p>
<p>查看日志应用场景二：根据日期查询日志<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) sed -n &#x27;/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p&#x27;  test.log</span><br><span class="line"></span><br><span class="line">特别说明:</span><br><span class="line"></span><br><span class="line">上面的两个日期必须是日志中打印出来的日志,否则无效</span><br><span class="line"></span><br><span class="line">先 grep &#x27;2014-12-17 16:17:20&#x27; test.log 来确定日志中是否有该时间点</span><br></pre></td></tr></table></figure></p>
<p>查看日志应用场景三：日志内容特别多，打印在屏幕上不方便查看，分页/保存文件查看<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)使用more和less命令,</span><br><span class="line"></span><br><span class="line">如： cat -n test.log |grep &quot;debug&quot; |more     这样就分页打印了,通过点击空格键翻页</span><br><span class="line"></span><br><span class="line">(2)使用 &gt;xxx.txt 将其保存到文件中,到时可以拉下这个文件分析</span><br><span class="line"></span><br><span class="line">如：cat -n test.log |grep &quot;debug&quot;  &gt;debug.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="统计某一类文件的大小"><a href="#统计某一类文件的大小" class="headerlink" title="统计某一类文件的大小"></a>统计某一类文件的大小</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -name &quot;solar.hit.*&quot; | xargs du -cm</span><br><span class="line"></span><br><span class="line">du -sh solar.hit.* | awk &#x27;&#123;sum += $1&#125;; END&#123;print sum&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="hadoop-Debug字段名是否正确"><a href="#hadoop-Debug字段名是否正确" class="headerlink" title="hadoop Debug字段名是否正确"></a>hadoop Debug字段名是否正确</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop fs -cat  /home/mmu/txt2vid_se/index_goods/solar/raw_data/20200619/ks_mmu.video_online_all_data_daily_with_goods/000000_0 | head -n 1 | awk -F&#x27;\t&#x27; &#x27;&#123;print $11&#125;&#x27;</span><br><span class="line"></span><br><span class="line">-F 是分隔符 print $11打印11列</span><br></pre></td></tr></table></figure>
<h3 id="解压缩命令"><a href="#解压缩命令" class="headerlink" title="解压缩命令"></a>解压缩命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建压缩</span><br><span class="line">tar zcvf bin.tar.gz mr_*</span><br><span class="line"></span><br><span class="line">解压</span><br><span class="line">tar zxvf bin.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file test.txt</span><br></pre></td></tr></table></figure>
<h3 id="查看文件大小"><a href="#查看文件大小" class="headerlink" title="查看文件大小"></a>查看文件大小</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du -sh .  查看当前文件</span><br><span class="line"></span><br><span class="line">df -h  查看本机使用情况</span><br></pre></td></tr></table></figure>
<h3 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -lrth</span><br></pre></td></tr></table></figure>
<h3 id="gdb-调试"><a href="#gdb-调试" class="headerlink" title="gdb 调试"></a>gdb 调试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb ./p4_test /data/coredump/core-1593519258-1001-1001-11-10600-p4_test</span><br><span class="line"></span><br><span class="line">gdb bt</span><br><span class="line"></span><br><span class="line">gdb where</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="查找某个字符"><a href="#查找某个字符" class="headerlink" title="查找某个字符"></a>查找某个字符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">grep -r &quot;_mm512_loadu_epi8&quot; .  包含这个字符就显示</span><br><span class="line"></span><br><span class="line">fgrep &quot;_mm512_loadu_epi8&quot; *.h  正则表达式匹配更快</span><br></pre></td></tr></table></figure>
<h3 id="cut-相关"><a href="#cut-相关" class="headerlink" title="cut 相关"></a>cut 相关</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc -l query.random.1k.diff | cut -d&#x27; &#x27; -f 1  统计行数并打印 -d分隔符 -f 第一行</span><br></pre></td></tr></table></figure>
<h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup bash start.sh &gt; stdout.log 2&gt;stderr.log &amp;  不挂断地运行命令。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Vim批量注释与反注释</title>
    <url>/2020/05/20/Linux-Vim%E6%89%B9%E9%87%8F%E6%B3%A8%E9%87%8A%E4%B8%8E%E5%8F%8D%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<p>在使用vim编写代码的时候，经常需要用到批量注释与反注释一段代码。在此做一下记录</p>
<p>多行注释：</p>
<ol>
<li>进入命令行模式，按ctrl + v进入 visual block模式</li>
</ol>
<p><img src="/2020/05/20/Linux-Vim%E6%89%B9%E9%87%8F%E6%B3%A8%E9%87%8A%E4%B8%8E%E5%8F%8D%E6%B3%A8%E9%87%8A/1.png" alt></p>
<ol>
<li><p>然后按j, 或者k选中多行，把需要注释的行标记起来</p>
<span id="more"></span>
<p><img src="/2020/05/20/Linux-Vim%E6%89%B9%E9%87%8F%E6%B3%A8%E9%87%8A%E4%B8%8E%E5%8F%8D%E6%B3%A8%E9%87%8A/2.png" alt></p>
</li>
<li><p>按大写字母I，再插入注释符，例如//,按两下esc键就会全部注释了</p>
</li>
</ol>
<p><img src="/2020/05/20/Linux-Vim%E6%89%B9%E9%87%8F%E6%B3%A8%E9%87%8A%E4%B8%8E%E5%8F%8D%E6%B3%A8%E9%87%8A/3.png" alt></p>
<p>取消多行注释：</p>
<ol>
<li><p>进入命令行模式，按ctrl + v进入 visual block模式</p>
</li>
<li><p>按字母j，或者k选中注释符号</p>
</li>
<li><p>按d键就可全部取消注释</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL容器整理</title>
    <url>/2020/04/18/STL%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>容器是储存其他对象的对象。被储存的对象必须是同一类型。</p>
<p>分类：</p>
<p>与java的集合不同!STL容器主要被分为两个部分：</p>
<p>一是序列容器（是一种各元素之间有顺序关系的线性表，是一种线性结构的可序群集。顺序性容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定）（<code>forword_list,list,queue,priority_queue,stack,deque,vector,array</code>）。<br><span id="more"></span><br>另一个是关联容器（关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。但是关联式容器提供了另一种根据元素特点排序的功能，这样迭代器就能根据元素的特点“顺序地”获取元素。元素是有序的集合，默认在插入的时候按升序排列（<code>set,multiset,map,multimap</code>）！</p>
<p>C++11之后还有一种无序关联容器！(<code>unordered_map, unordered_set, unordered_multiset, unordered_multimap</code>)</p>
<h3 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h3><p>序列的要求：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">X <span class="title">a</span><span class="params">(n,t)</span>  <span class="comment">//声明一个名为a的有n个t组成的序列</span></span></span><br><span class="line"><span class="function"><span class="title">X</span><span class="params">(n,t)</span>     <span class="comment">//匿名序列（这里不做过多的解释）</span></span></span><br><span class="line"><span class="function">X <span class="title">a</span><span class="params">(i,j)</span>   <span class="comment">//声明一个名为a的序列，并且初始化[i,j）的内容</span></span></span><br><span class="line"><span class="function"><span class="title">X</span><span class="params">(i,j)</span>      <span class="comment">//匿名序列</span></span></span><br><span class="line"><span class="function">v.<span class="title">insert</span><span class="params">()</span>   <span class="comment">//由于insert重载方法比较多</span></span></span><br><span class="line"><span class="function">    v.<span class="title">insert</span><span class="params">(p,t)</span><span class="comment">//将t插到p的前面</span></span></span><br><span class="line"><span class="function">    v.<span class="title">insert</span><span class="params">(p,n,t)</span><span class="comment">//将n个t插入p之前</span></span></span><br><span class="line"><span class="function">    v.<span class="title">insert</span><span class="params">(p,i.j)</span><span class="comment">//将区间[i,j)的元素插入到p之前</span></span></span><br><span class="line"><span class="function">v.<span class="title">erase</span><span class="params">(t,k)</span></span></span><br><span class="line"><span class="function">    v.<span class="title">erase</span><span class="params">(t,k)</span><span class="comment">//删除他们之间的元素</span></span></span><br><span class="line"><span class="function">    v.<span class="title">erase</span><span class="params">(p)</span><span class="comment">//删除p指向的元素</span></span></span><br><span class="line"><span class="function">v.clear</span>===v.<span class="built_in">erase</span>(<span class="built_in">begin</span>(),<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>下面我们来看一下这些容器的特点！</p>
<h4 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. vector</h4><p>vector是数组的一种类表示，vector表示一段连续的内存，基于数组实现，他有自动的内存管理功能!可以动态的改变vector的长度，并随着元素的增加与减小来自动改变数组大小，它提供了直接添加尾部元素或者删除元素的方法！所以它的时间是固定的！然而他要在头部与中间插入或者删除元素是线性的时间复杂度！</p>
<p>特点：<br>他可以反转序列，所以它可以反向遍历可反转序列！（基于他的rbegin,rend）</p>
<p>调用头文件：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>定义与初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;<span class="comment">//默认初始化</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(v1)</span></span>;<span class="comment">//用v1初始化v</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">v</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>());<span class="comment">//用v1初始化v</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//定义一个大小为10的数组！</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span><span class="comment">//定义个全为1而且长度为10的数组</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b.begin(),b.begin+<span class="number">3</span>)</span></span>; <span class="comment">//定义了a值为b中第0个到第2个（共3个）元素</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>)</span></span>; <span class="comment">//从数组中获得初值</span></span><br></pre></td></tr></table></figure>
<p>方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//b为向量，将b的0~2个元素构成的向量赋给a</span></span><br><span class="line">a.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">2</span>); <span class="comment">//是a只含4个元素，且每个元素为2</span></span><br><span class="line">a.<span class="built_in">back</span>(); <span class="comment">//返回a的最后一个元素</span></span><br><span class="line">a.<span class="built_in">front</span>(); <span class="comment">//返回a的第一个元素</span></span><br><span class="line">a[i]; <span class="comment">//返回a的第i个元素，当且仅当a[i]存在2013-12-07</span></span><br><span class="line">a.<span class="built_in">clear</span>(); <span class="comment">//清空a中的元素</span></span><br><span class="line">a.<span class="built_in">empty</span>(); <span class="comment">//判断a是否为空，空则返回ture,不空则返回false</span></span><br><span class="line">a.<span class="built_in">pop_back</span>(); <span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">5</span>); <span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>); <span class="comment">//b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8 ，插入元素后为1,4,5,9,2,3,4,5,9,8</span></span><br><span class="line">a.<span class="built_in">size</span>(); <span class="comment">//返回a中元素的个数；</span></span><br><span class="line">a.<span class="built_in">capacity</span>(); <span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值随机</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值为2</span></span><br><span class="line">a.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">//将a的容量（capacity）扩充至100，也就是说现在测试a.capacity();的时候返回值是100.这种操作只有在需要给a添加大量数据的时候才  显得有意义，因为这将避免内存多次容量扩充操作（当a的容量不足时电脑会自动扩容，当然这必然降低性能） </span></span><br><span class="line">a.<span class="built_in">swap</span>(b); <span class="comment">//b为向量，将a中的元素和b中的元素进行整体性交换</span></span><br><span class="line">a==b; <span class="comment">//b为向量，向量的比较操作还有!=,&gt;=,&lt;=,&gt;,&lt;</span></span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下标法</span></span><br><span class="line"><span class="type">int</span> length = v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;v[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="comment">//迭代器法</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator iterator = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(;iterator != v.<span class="built_in">end</span>();iterator++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*iterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几种常用重要的算法，使用时需要包含头文件：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span></span><br><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span></span><br><span class="line"><span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),b.<span class="built_in">begin</span>()+<span class="number">1</span>); <span class="comment">//把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素</span></span><br><span class="line"><span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>); <span class="comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2-deque"><a href="#2-deque" class="headerlink" title="2. deque"></a>2. deque</h4><p>双端队列，他的实现类似与vector,支持随机访问，但是它访问首元素的插入（push_front()）与删除（pop_front()）的时间是固定的！而且他的执行速度要比vector快很多！所以需要有大量的操作发生在序列的起始位置与结尾处，我们就要考虑用deque!</p>
<p>调用头文件：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br></pre></td></tr></table></figure><br>初始化与定义已经在序列要求里面，而且方法与vector类似，只是多了push_front(),pop_front(),不做过多的阐述</p>
<h4 id="3-list"><a href="#3-list" class="headerlink" title="3. list"></a>3. list</h4><p>双向链表，list在链表中的任意一个位置插入与删除一个元素时间是固定的！但是他不能随机访问，优点是元素的快速插入与删除！从容器中插入与删除元素之后i，迭代器指向元素将不变，不会移动已有元素，只是修改链表信息。</p>
<p>调用头文件：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>链表独有成员函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span>   <span class="comment">//使用&lt;运算符对链表进行排序，时间复杂度O（NlogN）</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(list&lt;T,Alloc&gt;&amp;x)</span>  <span class="comment">//将x与调用链表合并，要求：两个链表必须要已经排好序！元素将保存在调用链表中，x为空，这个时间复杂度为线性！</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T &amp;val)</span><span class="comment">//删除val的所有实例</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator pos,list&lt;T,Alloc&gt;x)</span><span class="comment">//将链表x的内容加到pos的前面，时间复杂度为固定时间</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> unique（） <span class="comment">//去重，线性时间</span></span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>algorithm头文件中有sort函数，这个list也有自己的sort函数，排序时都可以用，不过使用自带的效率会更高一点。</p>
<h4 id="4-forword-list"><a href="#4-forword-list" class="headerlink" title="4. forword_list"></a>4. forword_list</h4><p>主要实现单向链表，与list类似，只需要正向迭代器，他是不可逆转容器，他功能比较少，比较简单</p>
<h4 id="5-queue"><a href="#5-queue" class="headerlink" title="5. queue"></a>5. queue</h4><p>他是一个适配器类，可以用数组也可以用链表实现队列，它不允许随机访问元素，而且不能遍历队列！元素只能先进先出（FIFO）.</p>
<p>调用头文件：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>queue的定义，queue<typename> q;其中typename可以为任何类型或容器。</typename></p>
<p>queue的访问，由于队列是一种先进先出的限制性数据结构，因此在STL中只能通过front()来访问队首元素，或是通过back()来访问队尾元素。</p>
<p>方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="comment">//判断是否为空</span></span></span><br><span class="line"><span class="function"><span class="title">front</span><span class="params">()</span><span class="comment">//队首元素的访问</span></span></span><br><span class="line"><span class="function"><span class="title">back</span><span class="params">()</span><span class="comment">//队尾元素的访问</span></span></span><br><span class="line"><span class="function"><span class="title">push</span><span class="params">(x)</span><span class="comment">//队尾插入x</span></span></span><br><span class="line"><span class="function"><span class="title">pop</span><span class="params">()</span><span class="comment">//删除队首元素</span></span></span><br></pre></td></tr></table></figure>
<h4 id="6-priority-queue"><a href="#6-priority-queue" class="headerlink" title="6. priority_queue"></a>6. priority_queue</h4><p>优先队列，其底层是用堆来进行实现的。在优先队列中，队首的元素一定是当前队列中优先级最高的那一个。C++中的堆默认是大顶堆。</p>
<p>调用头文件：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>priority_queue的定义，priority_queue<typename> q,typename可以为任意类型的元素。</typename></p>
<p>priority_queue只能通过top()函数来访问队首元素(堆顶元素)，也就是优先级最高的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; X <span class="comment">//大根堆,默认初始化</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; x  <span class="comment">//小根堆,运用了预定义函数greater&lt;int&gt;！</span></span><br></pre></td></tr></table></figure>
<p>以下内容摘自C++API：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">包含priority_queue 的头文件是 &lt;queue&gt;</span><br><span class="line">priority_queue类的主要成员：</span><br><span class="line"><span class="built_in">priority_queue</span>();    <span class="comment">//默认构造函数，生成一个空的排序队列</span></span><br><span class="line"><span class="built_in">priority_queue</span>(<span class="type">const</span> queue&amp;);    <span class="comment">//拷贝构造函数</span></span><br><span class="line">priority_queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> priority_queue &amp;);    <span class="comment">//赋值运算符重载</span></span><br><span class="line">priority_queue 的私有成员：</span><br><span class="line">value_type;   <span class="comment">//priority_queue中存放的对象类型，它和priority_queue中的T类型相同</span></span><br><span class="line"><span class="built_in">priority_queue</span>(<span class="type">const</span> Compare&amp; comp);    <span class="comment">//构造生成一个空的priority_queue对象，使用comp作为priority_queue的comparison</span></span><br><span class="line"><span class="built_in">priority_queue</span>(<span class="type">const</span> value_type* first, <span class="type">const</span> value_type* last);    <span class="comment">//带有两个参数的构造 函数，使用默认的Comparison作为第三个参数</span></span><br><span class="line">size_type;    <span class="comment">//正整数类型，和Sequence::size_type类型一样。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">//判断优先级队列是否为空，为空返回true，否则返回false</span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">//返回优先级队列中的元素个数</span></span><br><span class="line"><span class="function"><span class="type">const</span> value_type&amp; <span class="title">top</span><span class="params">()</span> <span class="title">const</span><span class="params">()</span></span>;    <span class="comment">//返回优先级队列中第一个元素的参考值。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;    <span class="comment">//把元素x插入到优先级队列的尾部，队列的长度加1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;    <span class="comment">//删除优先级队列的第一个值，前提是队列非空，删除后队列长度减1</span></span><br></pre></td></tr></table></figure></p>
<h4 id="7-stack"><a href="#7-stack" class="headerlink" title="7. stack"></a>7. stack</h4><p>栈，是STL中实现一个后进先出的容器.</p>
<p>调用头文件：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>stack的定义，stack<typename> name要使用stack需要加上头文件#include<stack>。</stack></typename></p>
<p>stack容器内元素的访问，由于栈本身就是一种后进先出的数据结构，在STL的stack中只能通过top()来访问栈顶元素</p>
<p>方法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push</span>(x)<span class="comment">//将x压入栈中，时间复杂度O(1)</span></span><br><span class="line"><span class="built_in">top</span>()<span class="comment">//获得栈顶元素，时间复杂度O(1)</span></span><br><span class="line"><span class="built_in">pop</span>()<span class="comment">//将栈顶元素弹出，时间复杂度O(1)</span></span><br><span class="line"><span class="built_in">empty</span>()<span class="comment">//判断栈是否为空，若为空，返回true，否则返回false，时间复杂度O(1)</span></span><br><span class="line"><span class="built_in">size</span>()<span class="comment">//返回栈中元素的个数，时间复杂度O(1)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>它运用了键值对（value-key），与java类似的map,例如hashmap，有点在于他提供了利用key快速访问功能，它的底层结构应该是一种树来实现的，所以他才有如此快的查找速度，最简单的set，他的键值对类型是一致的，而且唯一，元素默认按升序排列。map他的键值对类型不同，键是唯一的,元素默认按键的升序排列。！而muilti_sset/map 键可以不唯一。</p>
<p>迭代器在关联容器中对操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">lower_bound</span>(k)<span class="comment">//返回一个迭代器，指向键不小于 k 的第一个元素</span></span><br><span class="line">m.<span class="built_in">upper_bound</span>(k)<span class="comment">//返回一个迭代器，指向键大于 k 的第一个元素</span></span><br><span class="line">m.<span class="built_in">equal_range</span>(k)<span class="comment">//返回一个迭代器的 pair 对象。它的 first 成员等价于 m.lower_bound(k)。而 second 成员则等价于 m.upper_bound(k)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="1-map"><a href="#1-map" class="headerlink" title="1. map"></a>1. map</h4><p>map 是键－值对的集合。map 类型通常可理解为关联数组：可使用键作为下标来获取一个值，正如内置数组类型一样。而关联的本质在于元素的值与某个特定的键相关联，而并非通过元素在数组中的位置来获取。</p>
<p>调用头文件：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>定义与初始化:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,string&gt; m;    <span class="comment">//默认为空</span></span><br></pre></td></tr></table></figure></p>
<p>具体操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>()</span><br><span class="line">m.<span class="built_in">insert</span>(e)<span class="comment">//e是一个用在m上的value_key 类型的值。如果键（e.first不在m中，则插入一个值为e.second 的新元素；如果该键在m中已存在，则保持m不变。该函数返回一个pair类型对象，包含指向键为e.first的元素的map迭代器，以及一个 bool 类型的对象，表示是否插入了该元素</span></span><br><span class="line">m.<span class="built_in">insert</span>(begin,end)<span class="comment">//begin和end是标记元素范围的迭代器，其中的元素必须为m.value_key 类型的键－值对。对于该范围内的所有元素，如果它的键在 m 中不存在，则将该键及其关联的值插入到 m。返回 void 类型</span></span><br><span class="line">m.<span class="built_in">insert</span>(iter,e)<span class="comment">//e是一个用在m上的 value_key 类型的值。如果键（e.first）不在m中，则创建新元素，并以迭代器iter为起点搜索新元素存储的位置。返回一个迭代器，指向m中具有给定键的元素</span></span><br><span class="line">m.<span class="built_in">count</span>(k) <span class="comment">//返回m中k的出现次数</span></span><br><span class="line">m.<span class="built_in">find</span>()   <span class="comment">//如果m容器中存在按k索引的元素，则返回指向该元素的迭代器。如果不存在，则返回超出末端迭代器.</span></span><br><span class="line">m.<span class="built_in">erase</span>()  <span class="comment">//具体与序列该方法一致！</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2-set"><a href="#2-set" class="headerlink" title="2. set"></a>2. set</h4><p>支持插入，删除，查找等操作，就像一个集合一样。所有的操作的都是严格在logn时间之内完成，效率非常高。set和multiset的区别是：set插入的元素不能相同，但是multiset可以相同。Set默认自动排序。使用方法类似list。</p>
<p>调用头文件：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>set容器的定义和使用，set 容器的每个键都只能对应一个元素。元素本身就是它的key。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) </span><br><span class="line">&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(v.begin(), v.end())</span></span>;</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl  <span class="comment">//20个</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 10个</span></span><br></pre></td></tr></table></figure>
<p>添加<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;string&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="string">&quot;the&quot;</span>); <span class="comment">//第一种方法：直接添加</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">s2.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//第二中方法：通过指针迭代器</span></span><br></pre></td></tr></table></figure></p>
<p>获取<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">v.<span class="built_in">insert</span>(i);</span><br><span class="line">v.<span class="built_in">find</span>(<span class="number">1</span>)<span class="comment">// 返回指向元素内容为1的指针</span></span><br><span class="line">v.<span class="built_in">find</span>(<span class="number">11</span>)<span class="comment">// 返回指针v.end()</span></span><br><span class="line">v.<span class="built_in">count</span>(<span class="number">1</span>)<span class="comment">// 存在，返回1</span></span><br><span class="line">v.<span class="built_in">count</span>(<span class="number">11</span>)<span class="comment">// 不存在，返回0</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-无序关联容器"><a href="#3-无序关联容器" class="headerlink" title="3. 无序关联容器"></a>3. 无序关联容器</h4><p>底层结构基于哈希表，主要主要与提高添加与删除元素得速度与提高查找算法得效率！无序关联容器（unordered_set、unordered_multiset、unordered_map和 unordered_multimap）使用键和哈希表，以便能够快速存取数据。下面简要地介绍这些概念。哈希函数（hash function）将键转换为索引值。例如，如果键为string对象，哈希函数可能将其中每个字符的数字编码相加，再计算结果除以13的余数，从而得到 一个0～12的索引。而无序容器将使用13个桶（bucket）来存储string，所有索引为4的string都将存储在第4个桶中。如果您要在容器中搜索键，将对键执行哈希函数，进而只在索引对应的桶中搜索。理想情况下，应有足够多的桶，每个桶只包含为数不多的string。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">X</span>(n, hf, eq)<span class="comment">//创建一个至少包含n个桶的空容器，并将hf用作哈希函数，将eq用作键值相等谓词。如果省略了eq，则将ke</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">y_equal</span>( )用作键值相等谓词；如果也省略了hf，则将<span class="built_in">hasher</span>( )用作哈希函数</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">a</span><span class="params">(n, hf, eq)</span><span class="comment">//创建一个名为a的空容器，它至少包含n个桶，并将hf用作哈希函数，将eq用作键值相等谓词。如果省略eq，则将key_equal( )用作键值相等谓词；如果也省略了hf，则将hasher( )用作哈希函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">X</span><span class="params">(i, j, n, hf, eq)</span><span class="comment">//创建一个至少包含n个桶的空容器，将hf用作哈希函数，将eq用作键值相等谓词，并插入区间[i, j]中的元素。如果省略了eq，将key_equal( )用作键值相等谓词；如果省略了hf，将hasher( )用作哈希函数；如果省略了n，则包含桶数不确定</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">X <span class="title">a</span><span class="params">(i, j, n, hf, eq)</span><span class="comment">//创建一个名为a的的空容器，它至少包含n个桶，将hf用作哈希函数，将eq用作键值相等谓词，并插入区间[i, j]中的元素。如果省略了eq，将key_equal( )用作键值相等谓词；如果省略了hf，</span></span></span><br><span class="line"><span class="function">将<span class="title">hasher</span><span class="params">( )</span>用作哈希函数；如果省略了n，则包含桶数不确定</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b.<span class="title">hash_function</span><span class="params">( )</span><span class="comment">//返回b使用的哈希函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b.<span class="title">key_eq</span><span class="params">( )</span><span class="comment">//返回创建b时使用的键值相等谓词</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b.<span class="title">bucket_count</span><span class="params">( )</span><span class="comment">//返回b包含的桶数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b.<span class="title">max_bucket_count</span> <span class="params">( )</span><span class="comment">//返回一个上限数，它指定了b最多可包含多少个桶</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b.<span class="title">bucket</span><span class="params">(k)</span><span class="comment">//返回键值为k的元素所属桶的索引</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b.<span class="title">bucket_size</span><span class="params">(n)</span><span class="comment">//返回索引为n的桶可包含的元素数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b.<span class="title">begin</span><span class="params">(n)</span><span class="comment">//返回一个迭代器，它指向索引为n的桶中的第一个元素</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b.<span class="title">end</span><span class="params">(n)</span><span class="comment">//返回一个迭代器，它指向索引为n的桶中的最后一个元素</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b.<span class="title">cbegin</span><span class="params">(n)</span><span class="comment">//返回一个常量迭代器，它指向索引为n的桶中的第一个元素</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b.<span class="title">cend</span><span class="params">(n)</span><span class="comment">//返回一个常量迭代器，它指向索引为n的桶中的最后一个元素</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b.<span class="title">load_factor</span><span class="params">()</span><span class="comment">//返回每个桶包含的平均元素数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b.<span class="title">max_load_factor</span><span class="params">()</span><span class="comment">//返回负载系数的最大可能取值；超过这个值后，容器将增加桶</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b.<span class="title">max_load_factor</span><span class="params">(z)</span><span class="comment">//可能修改最大负载系统，建议将它设置为1</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">a.<span class="title">rehash</span><span class="params">(n)</span><span class="comment">//将桶数调整为不小于n，并确保a.bucket_count( )&gt; a.size( ) / a.max_load_factor( )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">a.<span class="title">reserve</span><span class="params">(n)</span><span class="comment">//等价于a.rehash(ceil(n/a.max_load_factor( )))，</span></span></span><br><span class="line"><span class="function">其中<span class="title">ceil</span><span class="params">(x)</span>返回不小于x的最小整数</span></span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.有序容器（除了list）：存储底层vector,只是添加了不同的接口！</p>
<p>2.deque（队列）：它不像vector 把所有的对象保存在一块连续的内存块，而是采用多个连续的存储块，并且在一个映射结构中保存对这些块及其顺序的跟踪。向deque 两端添加或删除元素的开销很小，它不需要重新分配空间。</p>
<p>3、list（列表）：是一个线性链表结构，它的数据由若干个节点构成，每一个节点都包括一个信息块（即实际存储的数据）、一个前驱指针和一个后驱指针。它无需分配指定的内存大小且可以任意伸缩，这是因为它存储在非连续的内存空间中，并且由指针将有序的元素链接起来。</p>
<p>4.后面的关联与无序关联都是用的一种树状结构！</p>
<p>用法与选择：</p>
<p>1.当数组大小未知时，和需要高效的查询功能，用vector!高效地随机存储。</p>
<p>2.不使用连续的内存空间,而且可以随意地进行动态操作，有大量的插入、删除操作，用list！</p>
<p>3.需要在两端进行push 、pop用daque！它兼顾了数组和链表的优点，它是分块的链表和多个数组的联合。所以它有被list 好的查询性能，有被vector 好的插入、删除性能。 如果你需要随即存取又关心两端数据的插入和删除，那么deque 是最佳之选。</p>
<p>4.需要查找或者打表可以选择map与set,当然一定条件下我们可以优先考虑用无序关联容器！</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络命令总结</title>
    <url>/2020/08/22/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>整理一下Linux常用的网络命令相关总结</p>
<p><img src="/2020/08/22/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/1.png" alt><br><span id="more"></span></p>
<h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>ping命令用来测试主机之间网络的连通性。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>（1）命令格式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping ( 选项）目的地址</span><br></pre></td></tr></table></figure></p>
<p>目的地址指的是被测计算机的IP 地址、主机名或者是域名。ping 命令包含12 个参数，所有参数都可以通过执行ping来查看</p>
<p><img src="/2020/08/22/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/2.png" alt></p>
<p>（2）实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/22/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/3.png" alt></p>
<p>（3）选项<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d：使用Socket的SO_DEBUG功能；</span><br><span class="line"></span><br><span class="line">-c&lt;完成次数&gt;：设置完成要求回应的次数；</span><br><span class="line"></span><br><span class="line">-f：极限检测；</span><br><span class="line"></span><br><span class="line">-i&lt;间隔秒数&gt;：指定收发信息的间隔时间；</span><br><span class="line"></span><br><span class="line">-L&lt;网络界面&gt;：使用指定的网络界面送出数据包；</span><br><span class="line"></span><br><span class="line">-l&lt;前置载入&gt;：设置在送出要求信息之前，先行发出的数据包；</span><br><span class="line"></span><br><span class="line">-n：只输出数值；</span><br><span class="line"></span><br><span class="line">-p&lt;范本样式&gt;：设置填满数据包的范本样式；</span><br><span class="line"></span><br><span class="line">-q：不显示指令执行过程，开头和结尾的相关信息除外；</span><br><span class="line"></span><br><span class="line">-r：忽略普通的Routing Table，直接将数据包送到远端主机上；</span><br><span class="line"></span><br><span class="line">-R：记录路由过程；</span><br><span class="line"></span><br><span class="line">-s&lt;数据包大小&gt;：设置数据包的大小；</span><br><span class="line"></span><br><span class="line">-v：详细显示指令的执行过程。</span><br><span class="line"></span><br><span class="line">-t&lt;存活数值&gt;：设置存活数值TTL的大小</span><br></pre></td></tr></table></figure></p>
<p>说一下其中的-c、 -i参数</p>
<p>其中 –c count 次数，也就是ping的次数；-i interval 间隔 ，每次ping之间的时间空格</p>
<p><img src="/2020/08/22/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/4.png" alt></p>
<h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>telnet命令用于登录远程主机，对远程主机进行管理。telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。</p>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。</p>
<h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法:"></a>用法:</h4><p>（1）命令格式：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat（选项）</span><br></pre></td></tr></table></figure></p>
<p>（2）选项<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a或–all：显示所有连线中的Socket；</span><br><span class="line"></span><br><span class="line">-A&lt;网络类型&gt;或–&lt;网络类型&gt;：列出该网络类型连线中的相关地址；</span><br><span class="line"></span><br><span class="line">-c或–continuous：持续列出网络状态；</span><br><span class="line"></span><br><span class="line">-C或–cache：显示路由器配置的快取信息；</span><br><span class="line"></span><br><span class="line">-e或–extend：显示网络其他相关信息；</span><br><span class="line"></span><br><span class="line">-F或–fib：显示FIB；</span><br><span class="line"></span><br><span class="line">-g或–groups：显示多重广播功能群组组员名单；</span><br><span class="line"></span><br><span class="line">-h或–help：在线帮助；</span><br><span class="line"></span><br><span class="line">-i或–interfaces：显示网络界面信息表单；</span><br><span class="line"></span><br><span class="line">-l或–listening：显示监控中的服务器的Socket；</span><br><span class="line"></span><br><span class="line">-M或–masquerade：显示伪装的网络连线；</span><br><span class="line"></span><br><span class="line">-n或–numeric：直接使用ip地址，而不通过域名服务器；</span><br><span class="line"></span><br><span class="line">-N或–netlink或–symbolic：显示网络硬件外围设备的符号连接名称；</span><br><span class="line"></span><br><span class="line">-o或–timers：显示计时器；</span><br><span class="line"></span><br><span class="line">-p或–programs：显示正在使用Socket的程序识别码和程序名称；</span><br><span class="line"></span><br><span class="line">-r或–route：显示Routing Table；</span><br><span class="line"></span><br><span class="line">-s或–statistice：显示网络工作信息统计表；</span><br><span class="line"></span><br><span class="line">-t或–tcp：显示TCP传输协议的连线状况；</span><br><span class="line"></span><br><span class="line">-u或–udp：显示UDP传输协议的连线状况；</span><br><span class="line"></span><br><span class="line">-v或–verbose：显示指令执行过程；</span><br><span class="line"></span><br><span class="line">-V或–version：显示版本信息；</span><br><span class="line"></span><br><span class="line">-w或–raw：显示RAW传输协议的连线状况；</span><br><span class="line"></span><br><span class="line">-x或–unix：此参数的效果和指定”-A unix”参数相同；</span><br><span class="line"></span><br><span class="line">–ip或–inet：此参数的效果和指定”-A inet”参数相同</span><br></pre></td></tr></table></figure></p>
<p>（3）实例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -a     //列出所有端口</span><br><span class="line">netstat -at //列出所有tcp端口</span><br><span class="line">netstat -au //列出所有udp端口</span><br></pre></td></tr></table></figure></p>
<p>在这里显示所有的TCP端口</p>
<p><img src="/2020/08/22/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/5.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -l //只显示监听端口</span><br><span class="line">netstat -lt //只列出所有监听 tcp 端口</span><br><span class="line">netstat -lu //只列出所有监听 udp 端口</span><br></pre></td></tr></table></figure>
<p>和上面的图相比，可以看到只显示出了监听状态的TCP端口</p>
<p><img src="/2020/08/22/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/6.png" alt></p>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>ifconfig命令被用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p>
<h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法:"></a>用法:</h4><p>（1）命令格式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig（参数）</span><br></pre></td></tr></table></figure></p>
<p>（2）实例</p>
<p><img src="/2020/08/22/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/7.png" alt></p>
<ul>
<li><p>inet 用来表示网卡的IP地址，此网卡的IP地址是：192.168.0.103</p>
</li>
<li><p>广播地址Bcast：192.168.0.255</p>
</li>
<li><p>掩码地址Mask：255.255.255.0</p>
</li>
</ul>
<p>lo是表示主机的回环地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。</p>
<p>（3）参数<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add&lt;地址&gt;：设置网络设备IPv6的ip地址</span><br><span class="line"></span><br><span class="line">del&lt;地址&gt;：删除网络设备IPv6的IP地址</span><br><span class="line"></span><br><span class="line">down：关闭指定的网络设备</span><br><span class="line"></span><br><span class="line">io_addr&lt; I/O地址&gt;：设置网络设备的I/O地址</span><br><span class="line"></span><br><span class="line">irq&lt; IRQ地址&gt;：设置网络设备的IRQ；</span><br><span class="line"></span><br><span class="line">media&lt;网络媒介类型&gt;：设置网络设备的媒介类型；</span><br><span class="line"></span><br><span class="line">mem_start&lt;内存地址&gt;：设置网络设备在主内存所占用的起始地址；</span><br><span class="line"></span><br><span class="line">metric&lt;数目&gt;：指定在计算数据包的转送次数时，所要加上的数目；</span><br><span class="line"></span><br><span class="line">mtu&lt;字节&gt;：设置网络设备的MTU；</span><br><span class="line"></span><br><span class="line">netmask&lt;子网掩码&gt;：设置网络设备的子网掩码；</span><br><span class="line"></span><br><span class="line">tunnel&lt;地址&gt;：建立IPv4与IPv6之间的隧道通信地址；</span><br><span class="line"></span><br><span class="line">up：启动指定的网络设备；</span><br><span class="line"></span><br><span class="line">-broadcast&lt;地址&gt;：将要送往指定地址的数据包当成广播数据包来处理；</span><br><span class="line"></span><br><span class="line">-pointopoint&lt;地址&gt;：与指定地址的网络设备建立直接连线，此模式具有保密功能；</span><br><span class="line"></span><br><span class="line">-promisc：关闭或启动指定网络设备的promiscuous模式；</span><br><span class="line"></span><br><span class="line">IP地址：指定网络设备的IP地址；</span><br><span class="line"></span><br><span class="line">网络设备：指定网络设备的名称。</span><br></pre></td></tr></table></figure></p>
<h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p>route命令用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在*/etc/rc.local中添加route命令来保证该路由设置永久有效。</p>
<h4 id="用法-3"><a href="#用法-3" class="headerlink" title="用法:"></a>用法:</h4><p>（1）命令格式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route（选项）（参数）</span><br></pre></td></tr></table></figure><br>（2）选项<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-A：设置地址类型；</span><br><span class="line"></span><br><span class="line">-C：打印将Linux核心的路由缓存；</span><br><span class="line"></span><br><span class="line">-v：详细信息模式；</span><br><span class="line"></span><br><span class="line">-n：不执行DNS反向查找，直接显示数字形式的IP地址；</span><br><span class="line"></span><br><span class="line">-e：netstat格式显示路由表；</span><br><span class="line"></span><br><span class="line">-net：到一个网络的路由表；</span><br><span class="line"></span><br><span class="line">-host：到一个主机的路由表。</span><br></pre></td></tr></table></figure></p>
<p>（3）参数<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Add：增加指定的路由记录</span><br><span class="line"></span><br><span class="line">Del：删除指定的路由记录</span><br><span class="line"></span><br><span class="line">Target：目的网络或目的主机</span><br><span class="line"></span><br><span class="line">gw：设置默认网关</span><br><span class="line"></span><br><span class="line">mss：设置TCP的最大区块长度(MSS)，单位为MB</span><br><span class="line"></span><br><span class="line">window：指定通过路由表的TCP连接的TCP窗口大小</span><br><span class="line"></span><br><span class="line">dev：路由记录所表示的网络接口</span><br></pre></td></tr></table></figure></p>
<p>（4）实例</p>
<p>显示当前路由</p>
<p><img src="/2020/08/22/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/8.png" alt></p>
<h3 id="arp"><a href="#arp" class="headerlink" title="arp"></a>arp</h3><p>arp命令用于操作主机arp缓冲区，可以显示arp缓冲区的所有条目、删除指定条目或增加静态IP地址与MAC地址的对应关系</p>
<h4 id="用法-4"><a href="#用法-4" class="headerlink" title="用法:"></a>用法:</h4><p>（1）命令格式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arp（选项）（参数）</span><br></pre></td></tr></table></figure></p>
<p>（2）选项<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a&lt;主机&gt;：显示arp缓冲区的所有条目</span><br><span class="line"></span><br><span class="line">-H&lt;地址类型&gt;：指定arp指令使用的地址类型</span><br><span class="line"></span><br><span class="line">-d&lt;主机&gt;：从arp缓冲区中删除指定主机的arp条目</span><br><span class="line"></span><br><span class="line">-D：使用指定接口的硬件地址</span><br><span class="line"></span><br><span class="line">-e：以Linux的显示风格显示arp缓冲区中的条目</span><br><span class="line"></span><br><span class="line">-i&lt;接口&gt;：指定要操作arp缓冲区的网络接口</span><br><span class="line"></span><br><span class="line">-s&lt;主机&gt;&lt;硬件地址&gt;：设置指定主机的IP地址与MAC地址的静态映射</span><br><span class="line"></span><br><span class="line">-n：以数字方式显示arp缓冲区中的条目</span><br><span class="line"></span><br><span class="line">-v：显示详细的arp缓冲区条目，包括缓冲区条目的统计信息</span><br><span class="line"></span><br><span class="line">-f&lt;文件&gt;：设置主机的IP地址与MAC地址的静态映射</span><br></pre></td></tr></table></figure></p>
<p>（4）实例</p>
<p><img src="/2020/08/22/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/9.png" alt></p>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>traceroute命令用于追踪数据包在网络上传输时的全部路径，它默认发送的数据包大小是40字节通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其ip地址</p>
<h4 id="用法-5"><a href="#用法-5" class="headerlink" title="用法:"></a>用法:</h4><p>（1）命令格式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">traceroute（选项）（参数）</span><br></pre></td></tr></table></figure></p>
<p>（2）选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d：使用Socket层级的排错功能</span><br><span class="line"></span><br><span class="line">-f&lt;存活时间&gt;：设置第一个检测数据包的存活数值TTL的大小</span><br><span class="line"></span><br><span class="line">-F：设置勿离断位</span><br><span class="line"></span><br><span class="line">-g&lt;网关&gt;：设置来源路由网关，最多可设置8个</span><br><span class="line"></span><br><span class="line">-i&lt;网络界面&gt;：使用指定的网络界面送出数据包</span><br><span class="line"></span><br><span class="line">-l：使用ICMP回应取代UDP资料信息</span><br><span class="line"></span><br><span class="line">-m&lt;存活数值&gt;：设置检测数据包的最大存活数值TTL的大小</span><br><span class="line"></span><br><span class="line">-n：直接使用IP地址而非主机名</span><br><span class="line"></span><br><span class="line">-p&lt;通信端口&gt;：设置UDP传输协议的通信端口</span><br><span class="line"></span><br><span class="line">-r：忽略普通的Routing Table，直接将数据包送到远端主机上</span><br><span class="line"></span><br><span class="line">-s&lt;来源地址&gt;：设置本地主机送出数据包的TOS数值</span><br><span class="line"></span><br><span class="line">-v：详细显示指令的执行过程</span><br><span class="line"></span><br><span class="line">-w&lt;超时秒数&gt;：设置等待远端主机回报的时间</span><br><span class="line"></span><br><span class="line">-x：开启或关闭数据包的正确性检验</span><br></pre></td></tr></table></figure>
<p>（3）实例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">traceroute www.baidu.com</span><br></pre></td></tr></table></figure><br><img src="/2020/08/22/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/10.png" alt></p>
<p>从图中可以看出记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间.</p>
<h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>host命令是常用的分析域名查询工具，可以检测域名系统工作是否正常</p>
<h3 id="用法-6"><a href="#用法-6" class="headerlink" title="用法:"></a>用法:</h3><p>（1）命令格式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">host（选项）（参数）</span><br></pre></td></tr></table></figure><br>（2）选项<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a：显示详细的DNS信息</span><br><span class="line"></span><br><span class="line">-c&lt;类型&gt;：指定查询类型，默认值为“IN”</span><br><span class="line"></span><br><span class="line">-C：查询指定主机的完整SOA记录</span><br><span class="line"></span><br><span class="line">-r：在查询域名时，不使用递归的查询方式</span><br><span class="line"></span><br><span class="line">-t&lt;类型&gt;：指定查询第域名信息类型</span><br><span class="line"></span><br><span class="line">-v：显示指令执行的详细信息</span><br><span class="line"></span><br><span class="line">-a：显示详细的DNS信息；</span><br><span class="line"></span><br><span class="line">-w：如果域名服务器没有给出应答信息，则一直等待，直到域名服务器给出应答</span><br><span class="line"></span><br><span class="line">-W&lt;时间&gt;：指定域名查询的最长时间，如果在指定时间内域名服务器没有给出应答信息，则退出指令</span><br><span class="line"></span><br><span class="line">-4：使用IPv4</span><br><span class="line"></span><br><span class="line">-6：使用IPv6</span><br></pre></td></tr></table></figure></p>
<h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><p>tcpdump命令是一款抓取数据包的工具，它可以打印所有经过网络接口的数据包的头信息，也可以使用-w选项将数据包保存到文件中，方便以后分析。</p>
<h3 id="用法-7"><a href="#用法-7" class="headerlink" title="用法:"></a>用法:</h3><p>（1）命令格式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump（选项）</span><br></pre></td></tr></table></figure></p>
<p>（2）选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a：尝试将网络和广播地址转换成名称；</span><br><span class="line"></span><br><span class="line">-c&lt;数据包数目&gt;：收到指定的数据包数目后，就停止进行倾倒操作；</span><br><span class="line"></span><br><span class="line">-d：把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出；</span><br><span class="line"></span><br><span class="line">-dd：把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出；</span><br><span class="line"></span><br><span class="line">-ddd：把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出；</span><br><span class="line"></span><br><span class="line">-e：在每列倾倒资料上显示连接层级的文件头；</span><br><span class="line"></span><br><span class="line">-f：用数字显示网际网络地址；</span><br><span class="line"></span><br><span class="line">-F&lt;表达文件&gt;：指定内含表达方式的文件；</span><br><span class="line"></span><br><span class="line">-i&lt;网络界面&gt;：使用指定的网络截面送出数据包；</span><br><span class="line"></span><br><span class="line">-l：使用标准输出列的缓冲区；</span><br><span class="line"></span><br><span class="line">-n：不把主机的网络地址转换成名字；</span><br><span class="line"></span><br><span class="line">-N：不列出域名；</span><br><span class="line"></span><br><span class="line">-O：不将数据包编码最佳化；</span><br><span class="line"></span><br><span class="line">-p：不让网络界面进入混杂模式；</span><br><span class="line"></span><br><span class="line">-q ：快速输出，仅列出少数的传输协议信息；</span><br><span class="line"></span><br><span class="line">-r&lt;数据包文件&gt;：从指定的文件读取数据包数据；</span><br><span class="line"></span><br><span class="line">-s&lt;数据包大小&gt;：设置每个数据包的大小；</span><br><span class="line"></span><br><span class="line">-S：用绝对而非相对数值列出TCP关联数；</span><br><span class="line"></span><br><span class="line">-t：在每列倾倒资料上不显示时间戳记；</span><br><span class="line"></span><br><span class="line">-tt：在每列倾倒资料上显示未经格式化的时间戳记；</span><br><span class="line"></span><br><span class="line">-T&lt;数据包类型&gt;：强制将表达方式所指定的数据包转译成设置的数据包类型；</span><br><span class="line"></span><br><span class="line">-v：详细显示指令执行过程；</span><br><span class="line"></span><br><span class="line">-vv：更详细显示指令执行过程；</span><br><span class="line"></span><br><span class="line">-x：用十六进制字码列出数据包资料；</span><br><span class="line"></span><br><span class="line">-w&lt;数据包文件&gt;：把数据包数据写入指定的文件。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP和TCP/IP的区别</title>
    <url>/2020/04/06/TCP%E5%92%8CTCP-IP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>TCP/IP是Transmission Control Protocol/Internet Protocol的简写，译名为传输控制协议/因特网协议，是Internet最基本的协议。TCP/IP是这个协议族的统称，它采用了4层的层级结构，而不是指TCP + IP两个协议的总和。</p>
<p>主要包括TCP、IP、UDP、ICMP、RIP、TELNET、FTP、SMTP、ARP、TFTP等许多协议<br><span id="more"></span></p>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP协议包含源主机地址、目标主机地址，还有TCP数据信息。但IP协议没有做任何事情来确认数据包是否按顺序发送或者包是否被破坏，所以IP数据包是不可靠的。</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>面向连接的通信协议，通过三次握手建立连接（socket通过TCP/IP连接时就是经过3次握手），通信完成后要关闭连接，它只用于端对端的通讯</p>
<p>TCP协议通过3次握手建立起一个可靠的连接，通过将数据包进行排序以及检验的方式，可以提供一种可靠的数据流服务</p>
<p>TCP可以限制数据的发送速度，间接地控制流量</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>面向无连接的通讯协议，UDP数据包括原端口号信息以及目标端口号信息，它可以实现广播发送</p>
<p>由于UDP通讯不需要接收方确认，所以属于不可靠的传输，可能会出现丢包现象。</p>
<p>七层网络模型示意图</p>
<p><img src="/2020/04/06/TCP%E5%92%8CTCP-IP%E7%9A%84%E5%8C%BA%E5%88%AB/1.jpg" alt></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的流量控制和拥塞控制</title>
    <url>/2020/04/07/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="TCP的流量控制和拥塞控制"><a href="#TCP的流量控制和拥塞控制" class="headerlink" title="TCP的流量控制和拥塞控制"></a>TCP的流量控制和拥塞控制</h2><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><ol>
<li><p>利用滑动窗口实现流量控制</p>
<p> 如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓<strong>流量控制</strong>就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p> 利用<strong>滑动窗口机制</strong>可以很方便地在TCP连接上实现对发送方的流量控制。</p>
 <span id="more"></span>
<p> 设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p>
<p> <img src="/2020/04/07/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/1.jfif" alt></p>
<p> 从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p>
<p> TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p>
</li>
<li><p>必须考虑传输速率</p>
<p> 可以用不同的机制来控制TCP报文段的发送时机。如：</p>
<p> <1>. TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。</1></p>
<p> <2>. 由发送方的应用进程指明要求发送报文段，即TCP支持的推送( push )操作。</2></p>
<p> <3>. 发送方的一个计时器期限到了，这时就把已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。</3></p>
<p> Nagle算法：若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方接收对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段再发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。Nagle算法还规定：当到达的数据已达到 发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。</p>
<p> 另，糊涂窗口综合征：TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1字节（这样就使接收缓存空间仅腾出1字节），然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报为40字节的的话）。接收，发送方又发来1个字节的数据（发送方的IP数据报是41字节）。接收方发回确认，仍然将窗口设置为1个字节。这样，网络的效率很低。要解决这个问题，可让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收方缓存已有一半空闲的空间。只要出现这两种情况，接收方就发回确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据报积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p>
</li>
</ol>
<h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><h4 id="1-拥塞："><a href="#1-拥塞：" class="headerlink" title="1.  拥塞："></a>1.  拥塞：</h4><p>即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。</p>
<pre><code>拥塞控制：**防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载**。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。

流量控制：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。
</code></pre><h4 id="2-几种拥塞控制方法"><a href="#2-几种拥塞控制方法" class="headerlink" title="2. 几种拥塞控制方法"></a>2. 几种拥塞控制方法</h4><pre><code>慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。
</code></pre><h5 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h5><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。</p>
<p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<p><strong>慢开始算法：</strong> 当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p>
<p><img src="/2020/04/07/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2.jfif" alt></p>
<p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p>
<p>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p>
<p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：</p>
<p>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</p>
<p>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>
<p>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>
<p><strong>拥塞避免算法：</strong>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p>
<p><img src="/2020/04/07/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/3.jfif" alt></p>
<p><1>. 当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。</1></p>
<p><2>. 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值+1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线性规律增长。</2></p>
<p><3>. 假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个MSS的大小。</3></p>
<p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，<strong>使网络比较不容易出现拥塞</strong>。</p>
<h4 id="2-2-快重传和快恢复"><a href="#2-2-快重传和快恢复" class="headerlink" title="2.2 快重传和快恢复"></a>2.2 快重传和快恢复</h4><p>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。</p>
<p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p>
<p><img src="/2020/04/07/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/4.jfif" alt></p>
<p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>
<p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p>
<p><1>. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</1></p>
<p><2>. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</2></p>
<p>下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。</p>
<p>区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p>
<p><img src="/2020/04/07/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/5.jfif" alt></p>
<p>也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。</p>
<p>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。</p>
<p>采用这样的拥塞控制方法使得TCP的性能有明显的改进。</p>
<p>接收方根据自己的接收能力设定了接收窗口rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，接收窗口又称为通知窗口。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口rwnd</p>
<p>发送方窗口的上限值 = Min [ rwnd, cwnd ]</p>
<p>当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。</p>
<p>当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP头部具体划分</title>
    <url>/2020/04/08/TCP%E5%9B%BA%E5%AE%9A%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>尽管TCP和UDP都使用相同的网络层（IP），TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。</p>
<p>使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上之后的数据的传输。TCP连接是全双工的，即双方的数据读写可以通过一个连接进行。完成数据交换后，通信双方都必须断开连接以释放系统资源。</p>
<p>TCP连接是一对一的，所以基于广播和多播应该使用UDP协议。<br><span id="more"></span></p>
<h3 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h3><p>TCP头部详解如下(两个图结合着理解)：</p>
<p><img src="/2020/04/08/TCP%E5%9B%BA%E5%AE%9A%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/1.webp" alt></p>
<p><img src="/2020/04/08/TCP%E5%9B%BA%E5%AE%9A%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/1.png" alt></p>
<p>对上图的部分说明:</p>
<h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>在进行TCP通信时，客户端使用系统自动选择的临时端口号，服务器采用知名服务端口号，如DNS协议端口号53，HTTP协议端口号80。知名服务使用的端口号定义在/etc/services。</p>
<p><img src="/2020/04/08/TCP%E5%9B%BA%E5%AE%9A%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/2.png" alt></p>
<h4 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h4><p>六位标志位包含以下几项：</p>
<ul>
<li><p>URG：表示紧急指针是否有效；</p>
</li>
<li><p>ACK：表示确认号是否有效，携带ACK标志的数据报文段为确认报文段；</p>
</li>
<li><p>PSH：提示接收端的应用程序应该立即从TCP接受缓冲区中读走数据，为接受后续数据腾出空间；</p>
</li>
<li><p>RST：表示要求对方重新建立连接，携带RST标志位的TCP报文段成为复位报文段；</p>
</li>
<li><p>SYN：表示请求建立一个连接，携带SYN标志的TCP报文段为同步报文段；</p>
</li>
<li><p>FIN：通知对方本端要关闭了，带FIN标志的TCP报文段为结束报文段。</p>
</li>
</ul>
<h4 id="确认序号"><a href="#确认序号" class="headerlink" title="确认序号"></a>确认序号</h4><p>Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p>
<h4 id="TCP头部选项"><a href="#TCP头部选项" class="headerlink" title="TCP头部选项"></a>TCP头部选项</h4><p>TCP头部选项是一个可变长的信息，这部分最多包含40字节，因为TCP头部最长60字节，（其中还包含前面20字节的固定部分）。</p>
<p><strong>为什么在TCP首部的开始便是首部长度字段而UDP首部却没有？</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为UDP提供无连接服务，它的数据包包头，是固定长度的8字节，不存在可选字</span><br><span class="line">段，可以减少很多传输开销，所以它无需使用首部字段长，因为它的首部就是固定的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而TCP提供连接服务，它的数据包包头，除了固定的20字节之外，还存在一个可</span><br><span class="line">选项，这个可选项字段，是根据TCP连接的要求而变动。这一字段最常见到的就</span><br><span class="line">是最大报文大小MSS，它指明发送端所能接收的最大长度的报文段。因为这个字</span><br><span class="line">段的存在，所以TCP包头使用了首部长字段。它占4位，以四字节为单位表示TCP</span><br><span class="line">包头长度，也就是说，TCP的首部最大长度可以是15x4=60字节，而可选项长可以为60-20=40字节</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/m0_37925202/article/details/80899012">TCP固定头部结构详解</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TPOT——一个自动化的Python机器学习工具</title>
    <url>/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="TPOT—一个自动化的Python机器学习工具"><a href="#TPOT—一个自动化的Python机器学习工具" class="headerlink" title="TPOT—一个自动化的Python机器学习工具"></a>TPOT—一个自动化的Python机器学习工具</h2><p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/1.png" alt></p>
<p>TPOT全称是基于树的pipeline优化工具(Tree-based Pipeline Optimization Tool)，这是一个非常棒Python自动机器学习工具，使用遗传编程优化机器学习pipeline。<br><span id="more"></span></p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/2.png" alt></p>
<p>TPOT可以自动化许多东西，包括生命特性选择、模型选择、特性构建等等。如果你是Python机器学习者，很幸运，TPOT是构建在Scikit-learn之上的，所以它生成的所有代码看起来应该很熟悉。</p>
<p>它的作用是通过智能地探索数千种可能的pipeline来自动化机器学习中最繁琐的部分，找到最适合你的数据的pipeline，然后为你提供最佳的 Python 代码。</p>
<p>它的工作原理如下：</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/3.png" alt></p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><p>安装TPOT，可参考以下文档：<br><a href="http://epistasislab.github.io/tpot/installing/">http://epistasislab.github.io/tpot/installing/</a></p>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h2><h3 id="2-1-TPOT代码"><a href="#2-1-TPOT代码" class="headerlink" title="2.1 TPOT代码"></a>2.1 TPOT代码</h3><p>TPOT的接口，与scikit-learn很类似。</p>
<p>TPOT可以像任何常规的Python模块一样导入：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br></pre></td></tr></table></figure><br>然后创建一个TPOT实例如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer = TPOTClassifier()</span><br></pre></td></tr></table></figure><br>当然，TPOTRegressor（）也可以。</p>
<p>一些带有定制TPOT参数的示例代码可能如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, cv=<span class="number">5</span>, random_state=<span class="number">42</span>, verbosity=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><br>现在，可以利用fit函数来寻找最优的管道：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>fit函数初始化了遗传算法，以找到基于平均k倍交叉验证的最高评分管道，然后对整个提供的样本进行训练，TPOT实例可以作为一个合适的模型使用。</p>
<p>然后，可以使用score函数来评估测试集中的最终管道：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(pipeline_optimizer.score(X_test, y_test))</span><br></pre></td></tr></table></figure><br>最后，可以把TPOT将相应的Python代码导出到文本文件中：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer.export(<span class="string">&#x27;tpot_exported_pipeline.py&#x27;</span>)</span><br></pre></td></tr></table></figure><br>下面是一个完整的示例脚本，使用TPOT优化管道，对其进行评分，并将最好的管道导出到文件中。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"> </span><br><span class="line">digits = load_digits()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"> </span><br><span class="line">pipeline_optimizer = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, cv=<span class="number">5</span>,random_state=<span class="number">42</span>, verbosity=<span class="number">2</span>)</span><br><span class="line">pipeline_optimizer.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(pipeline_optimizer.score(X_test, y_test))</span><br><span class="line">pipeline_optimizer.export(<span class="string">&#x27;tpot_exported_pipeline.py&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-TPOT命令行"><a href="#2-2-TPOT命令行" class="headerlink" title="2.2 TPOT命令行"></a>2.2 TPOT命令行</h3><p>TPOT可以通过命令行导入使用<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tpot /path_to/data_file.csv</span><br></pre></td></tr></table></figure><br>命令行导入使用TPOT的示例代码如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tpot data/mnist.csv -is , -target class -o tpot_exported_pipeline.py -g 5 -p 20 -cv 5 -s 42 -v 2</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-评估函数"><a href="#2-3-评估函数" class="headerlink" title="2.3 评估函数"></a>2.3 评估函数</h3><p>TPOT允许自定义评分函数，具体例子可以参考<a href="https://epistasislab.github.io/tpot/using/#scoring-functions">Scoring Functions</a></p>
<h2 id="2-4-内置TPOT配置"><a href="#2-4-内置TPOT配置" class="headerlink" title="2.4 内置TPOT配置"></a>2.4 内置TPOT配置</h2><p>TPOT提供了一些默认的操作符和参数配置，它可以很好地优化机器学习管道。下面是TPOT当前内置配置的<a href="https://epistasislab.github.io/tpot/using/#built-in-tpot-configurations">列表</a>。它有4种：</p>
<ul>
<li>Default TPOT：默认的参数，在一些大数据集上可能需要较长时间。</li>
<li>TPOT light：与Default TPOT相比，使用了更简单、快速运行的操作符，因此TPOT light对于查找用于分类或回归问题的快速简单的管道非常有用。</li>
<li>TPOT MDR：专门用于全基因组关联研究（GWAS）</li>
<li>TPOT sparse：带有one-hot编码，且支持稀疏矩阵。<br>如果要使用这些配置只需将配置的字符串名称传递给config_dict 参数。示例代码如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">digits = load_digits()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">tpot = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, verbosity=<span class="number">2</span>,config_dict=<span class="string">&#x27;TPOT light&#x27;</span>)</span><br><span class="line">tpot.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(tpot.score(X_test, y_test))</span><br><span class="line">tpot.export(<span class="string">&#x27;tpot_mnist_pipeline.py&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-5-定制TPOT的操作符和参数"><a href="#2-5-定制TPOT的操作符和参数" class="headerlink" title="2.5 定制TPOT的操作符和参数"></a>2.5 定制TPOT的操作符和参数</h3>除了TPOT所带来的默认配置之外，在某些情况下，限制TPOT所考虑的算法和参数是很有用的（用于减少寻优的时间等）。出于这个原因，TPOT允许用户为TPOT提供其操作符和参数的自定义配置。<br>自定义TPOT配置必须采用嵌套字典格式，举一个例子：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"> </span><br><span class="line">digits = load_digits()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"> </span><br><span class="line">tpot_config = &#123;</span><br><span class="line">    <span class="string">&#x27;sklearn.naive_bayes.GaussianNB&#x27;</span>: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;sklearn.naive_bayes.BernoulliNB&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;alpha&#x27;</span>: [<span class="number">1e-3</span>, <span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1.</span>, <span class="number">10.</span>, <span class="number">100.</span>],</span><br><span class="line">        <span class="string">&#x27;fit_prior&#x27;</span>: [<span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;sklearn.naive_bayes.MultinomialNB&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;alpha&#x27;</span>: [<span class="number">1e-3</span>, <span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1.</span>, <span class="number">10.</span>, <span class="number">100.</span>],</span><br><span class="line">        <span class="string">&#x27;fit_prior&#x27;</span>: [<span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">tpot = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, verbosity=<span class="number">2</span>,</span><br><span class="line">                      config_dict=tpot_config)</span><br><span class="line">tpot.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(tpot.score(X_test, y_test))</span><br><span class="line">tpot.export(<span class="string">&#x27;tpot_mnist_pipeline.py&#x27;</span>)</span><br></pre></td></tr></table></figure>
这样，TPOT寻找最优的pipeline，就只会在tpot_config中寻找了，无疑大大减少了时间复杂度，不过准确性可能会下降。<h3 id="2-6-Note"><a href="#2-6-Note" class="headerlink" title="2.6 Note"></a>2.6 Note</h3>搜索整个管道空间是特别耗时的。认识到原因是必要的，在默认的TPOT参数下（100 generations with 100 population size），TPOT将在完成前评估1万个管道配置。考虑一个网格搜索1万个超参数组合用于机器学习算法以及网格搜索需要多长时间。用10倍的交叉验证来评估这1万个模型，这意味着大约有10万个模型在一个网格搜索的训练数据中被匹配和评估。这是一个耗时的过程，即使对于像决策树这样的简单模型也是如此。</li>
</ul>
<p>典型的TPOT运行将需要数小时到数天才能完成（除非是一个小数据集），但是可以中断运行，并看到目前为止最好的结果。TPOT还提供warm_start参数，可以从中断的地方重新启动之前运行的TPOT。</p>
<h2 id="3-TPOT-API"><a href="#3-TPOT-API" class="headerlink" title="3. TPOT API"></a>3. TPOT API</h2><p>以TPOTRegressor为例，分类问题一样。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tpot</span>.TPOTRegressor(generations=<span class="number">100</span>, population_size=<span class="number">100</span>,</span><br><span class="line">offspring_size=<span class="literal">None</span>, mutation_rate=<span class="number">0.9</span>,</span><br><span class="line">crossover_rate=<span class="number">0.1</span>,</span><br><span class="line">scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>, cv=<span class="number">5</span>,</span><br><span class="line">subsample=<span class="number">1.0</span>, n_jobs=<span class="number">1</span>,</span><br><span class="line">max_time_mins=<span class="literal">None</span>, max_eval_time_mins=<span class="number">5</span>,</span><br><span class="line">random_state=<span class="literal">None</span>, config_dict=<span class="literal">None</span>,</span><br><span class="line">warm_start=<span class="literal">False</span>,</span><br><span class="line">memory=<span class="literal">None</span>,</span><br><span class="line">periodic_checkpoint_folder=<span class="literal">None</span>,</span><br><span class="line">early_stop=<span class="literal">None</span>,</span><br><span class="line">verbosity=<span class="number">0</span>,</span><br><span class="line">disable_update_check=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><br>在默认情况下，TPOTRegressor将搜索广泛的监督的回归模型，包括预处理，特征选择，学习器和它们的超参数。当然，TPOTRegressor可以完全自己定制。</p>
<p>参数，属性和方法的详情可以参考<a href="https://epistasislab.github.io/tpot/api/#regression">如下</a></p>
<p>下面列出主要的参数和方法：</p>
<p>参数：</p>
<ul>
<li>generations: int, optional (default=100)，运行管道优化过程的迭代次数。一定是正数,默认是100。一般来说，值越大，性能越好。</li>
</ul>
<p>TPOT将评估population_size+generations×offspring_size的规模。</p>
<ul>
<li><p>population_size: int, optional (default=100)，在每一代遗传中保留的个体数。一定是正数。一般来说，值越大，性能越好。</p>
</li>
<li><p>offspring_size: int, optional (default=100)，在每一次遗传过程中产生的后代数量。一定是正数。</p>
</li>
<li>mutation_rate: float, optional (default=0.9)，变异率，采用默认值即可。</li>
<li>crossover_rate: float, optional (default=0.1)，交叉率，采用默认值即可。</li>
<li>scoring: string or callable, optional (default=’neg_mean_squared_error’)，回归问题中用于评估给定管道的质量的函数。可以使用以下内置评分函数： ‘neg_median_absolute_error’, ‘neg_mean_absolute_error’, ‘neg_mean_squared_error’, ‘r2’</li>
<li>cv: int, cross-validation generator, or an iterable, optional (default=5)</li>
<li>subsample: float, optional (default=1.0)，在TPOT优化过程中使用的训练样本的比例。必须在0到1之间。</li>
<li>n_jobs: integer, optional (default=1)</li>
<li>max_time_mins: integer or None, optional (default=None)，TPOT需要多少分钟来优化管道。</li>
<li>max_eval_time_mins: integer, optional (default=5)，TPOT需要多少分钟来评估一个管道。</li>
<li>random_state: integer or None, optional (default=None)，使用这个参数来确保TPOT每次运行时都会有相同的结果。</li>
<li>config_dict: Python dictionary, string, or None, optional (default=None)，用于定制TPOT在优化过程中搜索的操作符和参数的配置字典。</li>
<li>warm_start: boolean, optional (default=False)，表明TPOT实例是否会重用以前调用fit（）的入口。</li>
<li>early_stop: integer, optional (default: None)</li>
<li>verbosity: integer, optional (default=0)，<br>0，TPOT将不会打印任何东西，<br>1，将打印很少的信息，<br>2，TPOT将会打印更多的信息并提供一个进度条<br>3，TPOT将打印所有内容，并提供一个进度条</li>
</ul>
<p>方法：</p>
<ul>
<li>fit(features, target, sample_weight=None, groups=None)，在给定的训练数据上运行TPOT优化过程。</li>
<li>predict(features)，使用优化的管道来预测测试集的目标值。</li>
<li>score(testing_features, testing_target)，使用用户指定的评分函数在给定的测试数据上返回优化的管道的得分。</li>
<li>export(output_file_name)，将优化的管道导出为Python代码。</li>
</ul>
<h2 id="4-实例"><a href="#4-实例" class="headerlink" title="4.实例"></a>4.实例</h2><h3 id="例4-1"><a href="#例4-1" class="headerlink" title="例4.1"></a>例4.1</h3><p>数据集地址：<a href="https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/">https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/</a></p>
<p>使用的数据集：breast-cancer-wisconsin.data<br>直接把数据全选复制到txt中，然后直接改文件后缀为csv，把文件转换为csv格式。并加上属性名</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/4.png" alt></p>
<p>程序：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">使用TPOT自动选择scikit-learn机器学习模型和参数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"> </span><br><span class="line">inputfile=<span class="string">&#x27;C:/Users/bryce/Desktop/breast-cancer-wisconsin.data.csv&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    df=pd.read_csv(inputfile)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    df.replace(<span class="string">&#x27;?&#x27;</span>,np.nan,inplace=<span class="literal">True</span>)</span><br><span class="line">    df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">    df.drop([<span class="string">&#x27;id&#x27;</span>],<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    df[<span class="string">&#x27;Bare Nuclei&#x27;</span>] = df[<span class="string">&#x27;Bare Nuclei&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line">    X=np.array(df.drop([<span class="string">&#x27;Class&#x27;</span>],<span class="number">1</span>))</span><br><span class="line">    Y=np.array(df[<span class="string">&#x27;Class&#x27;</span>])</span><br><span class="line">    x_train,x_test,y_train,y_test=model_selection.train_test_split(X,Y,test_size=<span class="number">0.2</span>)</span><br><span class="line">    tpot=TPOTClassifier(generations=<span class="number">6</span>,verbosity=<span class="number">2</span>)</span><br><span class="line">    tpot.fit(x_train,y_train)</span><br><span class="line">    tpot.score(x_test,y_test)</span><br><span class="line">    tpot.export(<span class="string">&#x27;pipeline.py&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><br>运行结果如下：</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/5.png" alt></p>
<p>可以看到运行的最优结果是随机森林算法,并给出具体的参数。<br>再运行一下随机森林算法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">使用TPOT自动选择scikit-learn机器学习模型和参数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"> </span><br><span class="line">inputfile=<span class="string">&#x27;C:/Users/bryce/Desktop/breast-cancer-wisconsin.data.csv&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    df=pd.read_csv(inputfile)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    df.replace(<span class="string">&#x27;?&#x27;</span>,np.nan,inplace=<span class="literal">True</span>)</span><br><span class="line">    df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">    df.drop([<span class="string">&#x27;id&#x27;</span>],<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">&#x27;Bare Nuclei&#x27;</span>] = df[<span class="string">&#x27;Bare Nuclei&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    X=np.array(df.drop([<span class="string">&#x27;Class&#x27;</span>],<span class="number">1</span>))</span><br><span class="line">    Y=np.array(df[<span class="string">&#x27;Class&#x27;</span>])</span><br><span class="line">    x_train,x_test,y_train,y_test=model_selection.train_test_split(X,Y,test_size=<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># tpot=TPOTClassifier(generations=6,verbosity=2)</span></span><br><span class="line">    <span class="comment"># tpot.fit(x_train,y_train)</span></span><br><span class="line">    <span class="comment"># tpot.score(x_test,y_test)</span></span><br><span class="line">    <span class="comment"># tpot.export(&#x27;pipeline.py&#x27;)</span></span><br><span class="line"> </span><br><span class="line">    rfc=RandomForestClassifier(bootstrap=<span class="literal">True</span>, criterion=<span class="string">&#x27;entropy&#x27;</span>, max_features=<span class="number">0.05</span>, min_samples_leaf=<span class="number">3</span>, min_samples_split=<span class="number">16</span>, n_estimators=<span class="number">100</span>)</span><br><span class="line">    rfc.fit(x_train,y_train)</span><br><span class="line">    accuracy=rfc.score(x_test,y_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;accuracy:%s&quot;</span>%accuracy)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><br>运行结果如下：</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/6.png" alt></p>
<h3 id="例4-2"><a href="#例4-2" class="headerlink" title="例4.2"></a>例4.2</h3><p>数据集：sklearn自带的波士顿房价数据集</p>
<h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h2><ol>
<li><a href="https://epistasislab.github.io/tpot/examples/">TPOT官方参考文档</a></li>
<li><a href="https://github.com/EpistasisLab/tpot">TPOTgithub</a></li>
<li><a href="https://blog.csdn.net/anshuai_aw1/article/details/82498947">利用TPOT完成自动化机器学习</a></li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TPOT优化原理部分源码解读</title>
    <url>/2020/03/28/TPOT%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>TPOT的涉及到的建模过程，以TPOT light为例主要有3块：Classifiers、Preprocesssors、Selectors，TPOT的遗传算法优化是以pipeline为基础的，也就是说pipeline就相当于基因序列。通过构建初始pipeline，再经过遗传算法中的交叉、变异最终生成符合条件的模型效果较好的pipeline。我们从最优的那一代中选取其中建模效果最好的pipeline即可，TPOT是基于scikit-learn框架的，它本身不去实现我们常用的分类回归等算法。而是通过遗传算法优化pipeline。也就是从中选出最优的数据处理、特征选择、分类算法的组合。<br><span id="more"></span><br>一个简单的TPOT的使用实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"> </span><br><span class="line">iris = load_digits()</span><br><span class="line">iris.data[<span class="number">0</span>:<span class="number">5</span>], iris.target</span><br><span class="line"><span class="built_in">print</span> iris</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line">X_train.shape, X_test.shape, y_train.shape, y_test.shape</span><br><span class="line"> </span><br><span class="line">tpot = TPOTClassifier(verbosity=<span class="number">2</span>, max_time_mins=<span class="number">2</span>,config_dict=<span class="string">&quot;TPOT light&quot;</span>,population_size=<span class="number">10</span>,mutation_rate=<span class="number">0.9</span>,crossover_rate=<span class="number">0.1</span>)</span><br><span class="line">tpot.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(tpot.score(X_test, y_test))</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2020/03/28/TPOT%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/1.png" alt></p>
<h3 id="部分核心源码解读"><a href="#部分核心源码解读" class="headerlink" title="部分核心源码解读"></a>部分核心源码解读</h3><h4 id="1、初始群体的生成"><a href="#1、初始群体的生成" class="headerlink" title="1、初始群体的生成"></a>1、初始群体的生成</h4><p>这段代码可以看出，pipeline的构建是通过生成不同深度的树类构建初始pipeline的，大致过程是先确定树的深度，从Classifiers中选择一个分类器放入树的顶端，接下来构建分类器的参数，以上均为随机选取。如果树的深度大于1，则还需要从Preprocesssors、Selectors中选择算子加入到pipeline中，还要进行参数初始化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@_pre_test</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_generate</span>(<span class="params">self, pset, min_, max_, condition, type_=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generate a Tree as a list of lists.</span></span><br><span class="line"><span class="string">    The tree is build from the root to the leaves, and it stop growing when</span></span><br><span class="line"><span class="string">    the condition is fulfilled.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    pset: PrimitiveSetTyped</span></span><br><span class="line"><span class="string">        Primitive set from which primitives are selected.</span></span><br><span class="line"><span class="string">    min_: int</span></span><br><span class="line"><span class="string">        Minimum height of the produced trees.</span></span><br><span class="line"><span class="string">    max_: int</span></span><br><span class="line"><span class="string">        Maximum Height of the produced trees.</span></span><br><span class="line"><span class="string">    condition: function</span></span><br><span class="line"><span class="string">        The condition is a function that takes two arguments,</span></span><br><span class="line"><span class="string">        the height of the tree to build and the current</span></span><br><span class="line"><span class="string">        depth in the tree.</span></span><br><span class="line"><span class="string">    type_: class</span></span><br><span class="line"><span class="string">        The type that should return the tree when called, when</span></span><br><span class="line"><span class="string">        :obj:None (default) no return type is enforced.</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    individual: list</span></span><br><span class="line"><span class="string">        A grown tree with leaves at possibly different depths</span></span><br><span class="line"><span class="string">        dependending on the condition function.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> type_ <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        type_ = pset.ret</span><br><span class="line">    expr = []</span><br><span class="line">    height = np.random.randint(min_, max_)</span><br><span class="line">    stack = [(<span class="number">0</span>, type_)]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">        depth, type_ = stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># We&#x27;ve added a type_ parameter to the condition function</span></span><br><span class="line">        <span class="keyword">if</span> condition(height, depth, type_):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                term = np.random.choice(pset.terminals[type_])</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                _, _, traceback = sys.exc_info()</span><br><span class="line">                <span class="keyword">raise</span> IndexError(</span><br><span class="line">                    <span class="string">&#x27;The gp.generate function tried to add &#x27;</span></span><br><span class="line">                    <span class="string">&#x27;a terminal of type &#123;&#125;, but there is&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;none available. &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(type_, traceback)</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">if</span> inspect.isclass(term):</span><br><span class="line">                term = term()</span><br><span class="line">            expr.append(term)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                prim = np.random.choice(pset.primitives[type_])</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                _, _, traceback = sys.exc_info()</span><br><span class="line">                <span class="keyword">raise</span> IndexError(</span><br><span class="line">                    <span class="string">&#x27;The gp.generate function tried to add &#x27;</span></span><br><span class="line">                    <span class="string">&#x27;a primitive of type &#123;&#125;, but there is&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;none available. &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(type_, traceback)</span><br><span class="line">                )</span><br><span class="line">            expr.append(prim)</span><br><span class="line">            <span class="keyword">for</span> arg <span class="keyword">in</span> <span class="built_in">reversed</span>(prim.args):</span><br><span class="line">                stack.append((depth + <span class="number">1</span>, arg))</span><br><span class="line">    <span class="keyword">return</span> expr</span><br></pre></td></tr></table></figure>
<h4 id="2、适应性值评估检测"><a href="#2、适应性值评估检测" class="headerlink" title="2、适应性值评估检测"></a>2、适应性值评估检测</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_evaluate_individuals</span>(<span class="params">self, individuals, features, target, sample_weight=<span class="literal">None</span>, groups=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Determine the fit of the provided individuals.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    individuals: a list of DEAP individual</span></span><br><span class="line"><span class="string">        One individual is a list of pipeline operators and model parameters that can be</span></span><br><span class="line"><span class="string">        compiled by DEAP into a callable function</span></span><br><span class="line"><span class="string">    features: numpy.ndarray &#123;n_samples, n_features&#125;</span></span><br><span class="line"><span class="string">        A numpy matrix containing the training and testing features for the individual&#x27;s evaluation</span></span><br><span class="line"><span class="string">    target: numpy.ndarray &#123;n_samples&#125;</span></span><br><span class="line"><span class="string">        A numpy matrix containing the training and testing target for the individual&#x27;s evaluation</span></span><br><span class="line"><span class="string">    sample_weight: array-like &#123;n_samples&#125;, optional</span></span><br><span class="line"><span class="string">        List of sample weights to balance (or un-balanace) the dataset target as needed</span></span><br><span class="line"><span class="string">    groups: array-like &#123;n_samples, &#125;, optional</span></span><br><span class="line"><span class="string">        Group labels for the samples used while splitting the dataset into train/test set</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    fitnesses_ordered: float</span></span><br><span class="line"><span class="string">        Returns a list of tuple value indicating the individual&#x27;s fitness</span></span><br><span class="line"><span class="string">        according to its performance on the provided data</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    operator_counts, eval_individuals_str, sklearn_pipeline_list, stats_dicts = self._preprocess_individuals(individuals)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Make the partial function that will be called below</span></span><br><span class="line">    partial_wrapped_cross_val_score = partial(</span><br><span class="line">        _wrapped_cross_val_score,</span><br><span class="line">        features=features,</span><br><span class="line">        target=target,</span><br><span class="line">        cv=self.cv,</span><br><span class="line">        scoring_function=self.scoring_function,</span><br><span class="line">        sample_weight=sample_weight,</span><br><span class="line">        groups=groups,</span><br><span class="line">        timeout=self.max_eval_time_seconds</span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line">    result_score_list = []</span><br><span class="line">    <span class="comment"># Don&#x27;t use parallelization if n_jobs==1</span></span><br><span class="line">    <span class="keyword">if</span> self.n_jobs == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> sklearn_pipeline <span class="keyword">in</span> sklearn_pipeline_list:</span><br><span class="line">            self._stop_by_max_time_mins()</span><br><span class="line">            val = partial_wrapped_cross_val_score(sklearn_pipeline=sklearn_pipeline)</span><br><span class="line">            result_score_list = self._update_val(val, result_score_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># chunk size for pbar update</span></span><br><span class="line">        <span class="comment"># chunk size is min of cpu_count * 2 and n_jobs * 4</span></span><br><span class="line">        chunk_size = <span class="built_in">min</span>(cpu_count()*<span class="number">2</span>, self.n_jobs*<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> chunk_idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(sklearn_pipeline_list), chunk_size):</span><br><span class="line">            self._stop_by_max_time_mins()</span><br><span class="line">            parallel = Parallel(n_jobs=self.n_jobs, verbose=<span class="number">0</span>, pre_dispatch=<span class="string">&#x27;2*n_jobs&#x27;</span>)</span><br><span class="line">            tmp_result_scores = parallel(delayed(partial_wrapped_cross_val_score)(sklearn_pipeline=sklearn_pipeline)</span><br><span class="line">                                         <span class="keyword">for</span> sklearn_pipeline <span class="keyword">in</span> sklearn_pipeline_list[chunk_idx:chunk_idx + chunk_size])</span><br><span class="line">            <span class="comment"># update pbar</span></span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> tmp_result_scores:</span><br><span class="line">                result_score_list = self._update_val(val, result_score_list)</span><br><span class="line"> </span><br><span class="line">    self._update_evaluated_individuals_(result_score_list, eval_individuals_str, operator_counts, stats_dicts)</span><br><span class="line"> </span><br><span class="line">    <span class="string">&quot;&quot;&quot;Look up the operator count and cross validation score to use in the optimization&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [(self.evaluated_individuals_[<span class="built_in">str</span>(individual)][<span class="string">&#x27;operator_count&#x27;</span>],</span><br><span class="line">             self.evaluated_individuals_[<span class="built_in">str</span>(individual)][<span class="string">&#x27;internal_cv_score&#x27;</span>])</span><br><span class="line">            <span class="keyword">for</span> individual <span class="keyword">in</span> individuals]</span><br></pre></td></tr></table></figure>
<h3 id="3、变异"><a href="#3、变异" class="headerlink" title="3、变异"></a>3、变异</h3><p>变异主要是增加pipeline的内容或更换其中的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_random_mutation_operator</span>(<span class="params">self, individual, allow_shrink=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Perform a replacement, insertion, or shrink mutation on an individual.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    individual: DEAP individual</span></span><br><span class="line"><span class="string">        A list of pipeline operators and model parameters that can be</span></span><br><span class="line"><span class="string">        compiled by DEAP into a callable function</span></span><br><span class="line"><span class="string">    allow_shrink: bool (True)</span></span><br><span class="line"><span class="string">        If True the `mutShrink` operator, which randomly shrinks the pipeline,</span></span><br><span class="line"><span class="string">        is allowed to be chosen as one of the random mutation operators.</span></span><br><span class="line"><span class="string">        If False, `mutShrink`  will never be chosen as a mutation operator.</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    mut_ind: DEAP individual</span></span><br><span class="line"><span class="string">        Returns the individual with one of the mutations applied to it</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    mutation_techniques = [</span><br><span class="line">        partial(gp.mutInsert, pset=self._pset),</span><br><span class="line">        partial(mutNodeReplacement, pset=self._pset)</span><br><span class="line">    ]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># We can&#x27;t shrink pipelines with only one primitive, so we only add it if we find more primitives.</span></span><br><span class="line">    number_of_primitives = <span class="built_in">sum</span>([<span class="built_in">isinstance</span>(node, deap.gp.Primitive) <span class="keyword">for</span> node <span class="keyword">in</span> individual])</span><br><span class="line">    <span class="keyword">if</span> number_of_primitives &gt; <span class="number">1</span> <span class="keyword">and</span> allow_shrink:</span><br><span class="line">        mutation_techniques.append(partial(gp.mutShrink))</span><br><span class="line"> </span><br><span class="line">    mutator = np.random.choice(mutation_techniques)</span><br><span class="line"> </span><br><span class="line">    unsuccesful_mutations = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self._max_mut_loops):</span><br><span class="line">        <span class="comment"># We have to clone the individual because mutator operators work in-place.</span></span><br><span class="line">        ind = self._toolbox.clone(individual)</span><br><span class="line">        offspring, = mutator(ind)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>(offspring) <span class="keyword">not</span> <span class="keyword">in</span> self.evaluated_individuals_:</span><br><span class="line">            <span class="comment"># Update statistics</span></span><br><span class="line">            <span class="comment"># crossover_count is kept the same as for the predecessor</span></span><br><span class="line">            <span class="comment"># mutation count is increased by 1</span></span><br><span class="line">            <span class="comment"># predecessor is set to the string representation of the individual before mutation</span></span><br><span class="line">            <span class="comment"># generation is set to &#x27;INVALID&#x27; such that we can recognize that it should be updated accordingly</span></span><br><span class="line">            offspring.statistics[<span class="string">&#x27;crossover_count&#x27;</span>] = individual.statistics[<span class="string">&#x27;crossover_count&#x27;</span>]</span><br><span class="line">            offspring.statistics[<span class="string">&#x27;mutation_count&#x27;</span>] = individual.statistics[<span class="string">&#x27;mutation_count&#x27;</span>] + <span class="number">1</span></span><br><span class="line">            offspring.statistics[<span class="string">&#x27;predecessor&#x27;</span>] = (<span class="built_in">str</span>(individual),)</span><br><span class="line">            offspring.statistics[<span class="string">&#x27;generation&#x27;</span>] = <span class="string">&#x27;INVALID&#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            unsuccesful_mutations += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Sometimes you have pipelines for which every shrunk version has already been explored too.</span></span><br><span class="line">    <span class="comment"># To still mutate the individual, one of the two other mutators should be applied instead.</span></span><br><span class="line">    <span class="keyword">if</span> ((unsuccesful_mutations == <span class="number">50</span>) <span class="keyword">and</span></span><br><span class="line">            (<span class="built_in">type</span>(mutator) <span class="keyword">is</span> partial <span class="keyword">and</span> mutator.func <span class="keyword">is</span> gp.mutShrink)):</span><br><span class="line">        offspring, = self._random_mutation_operator(individual, allow_shrink=<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> offspring,</span><br></pre></td></tr></table></figure>
<h3 id="4、交叉"><a href="#4、交叉" class="headerlink" title="4、交叉"></a>4、交叉</h3><p>选取两个pipeline，对里面的内容进行互换，但是两个pipeline的primitive要相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pick_two_individuals_eligible_for_crossover</span>(<span class="params">population</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Pick two individuals from the population which can do crossover, that is, they share a primitive.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    population: array of individuals</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    tuple: (individual, individual)</span></span><br><span class="line"><span class="string">        Two individuals which are not the same, but share at least one primitive.</span></span><br><span class="line"><span class="string">        Alternatively, if no such pair exists in the population, (None, None) is returned instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    primitives_by_ind = [<span class="built_in">set</span>([node.name <span class="keyword">for</span> node <span class="keyword">in</span> ind <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, gp.Primitive)])</span><br><span class="line">                         <span class="keyword">for</span> ind <span class="keyword">in</span> population]</span><br><span class="line">    pop_as_str = [<span class="built_in">str</span>(ind) <span class="keyword">for</span> ind <span class="keyword">in</span> population]</span><br><span class="line"> </span><br><span class="line">    eligible_pairs = [(i, i+<span class="number">1</span>+j) <span class="keyword">for</span> i, ind1_prims <span class="keyword">in</span> <span class="built_in">enumerate</span>(primitives_by_ind)</span><br><span class="line">                                 <span class="keyword">for</span> j, ind2_prims <span class="keyword">in</span> <span class="built_in">enumerate</span>(primitives_by_ind[i+<span class="number">1</span>:])</span><br><span class="line">                                 <span class="keyword">if</span> <span class="keyword">not</span> ind1_prims.isdisjoint(ind2_prims) <span class="keyword">and</span></span><br><span class="line">                                    pop_as_str[i] != pop_as_str[i+<span class="number">1</span>+j]]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Pairs are eligible in both orders, this ensures that both orders are considered</span></span><br><span class="line">    eligible_pairs += [(j, i) <span class="keyword">for</span> (i, j) <span class="keyword">in</span> eligible_pairs]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> eligible_pairs:</span><br><span class="line">        <span class="comment"># If there are no eligible pairs, the caller should decide what to do</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    pair = np.random.randint(<span class="number">0</span>, <span class="built_in">len</span>(eligible_pairs))</span><br><span class="line">    idx1, idx2 = eligible_pairs[pair]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> population[idx1], population[idx2]</span><br></pre></td></tr></table></figure>
<p>TPOT设置了一个阈值来决定是交叉还是变异，默认情况下变异的概率为0.9，交叉的概率为0.1.我们可以修改这个阈值。</p>
<p>具体的pipeline变换如下：</p>
<p>默认的种群数量为100，为了看源码方便，改为了5个种群数。交叉变异的概率各为0.5.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tpot = TPOTClassifier(verbosity=<span class="number">2</span>, max_time_mins=<span class="number">2</span>,config_dict=<span class="string">&quot;TPOT light&quot;</span>,population_size=<span class="number">5</span>,mutation_rate=<span class="number">0.5</span>,crossover_rate=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>初始种群为5个pipeline，分别为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> = &#123;Individual&#125; KNeighborsClassifier(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), KNeighborsClassifier__n_neighbors=<span class="number">79</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br><span class="line"><span class="number">1</span> = &#123;Individual&#125; KNeighborsClassifier(Binarizer(input_matrix, Binarizer__threshold=<span class="number">0.55</span>), KNeighborsClassifier__n_neighbors=<span class="number">84</span>, KNeighborsClassifier__p=<span class="number">2</span>, KNeighborsClassifier__weights=uniform)</span><br><span class="line"><span class="number">2</span> = &#123;Individual&#125; DecisionTreeClassifier(input_matrix, DecisionTreeClassifier__criterion=gini, DecisionTreeClassifier__max_depth=<span class="number">9</span>, DecisionTreeClassifier__min_samples_leaf=<span class="number">18</span>, DecisionTreeClassifier__min_samples_split=<span class="number">20</span>)</span><br><span class="line"><span class="number">3</span> = &#123;Individual&#125; LogisticRegression(StandardScaler(input_matrix), LogisticRegression__C=<span class="number">0.0001</span>, LogisticRegression__dual=<span class="literal">True</span>, LogisticRegression__penalty=l2)</span><br><span class="line"><span class="number">4</span> = &#123;Individual&#125; GaussianNB(input_matrix)</span><br></pre></td></tr></table></figure>
<p>经过第一轮交叉、变异，结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> = &#123;Individual&#125; LogisticRegression(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), LogisticRegression__C=<span class="number">0.1</span>, LogisticRegression__dual=<span class="literal">True</span>, LogisticRegression__penalty=l2)</span><br><span class="line"><span class="number">1</span> = &#123;Individual&#125; KNeighborsClassifier(input_matrix, KNeighborsClassifier__n_neighbors=<span class="number">79</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br><span class="line"><span class="number">2</span> = &#123;Individual&#125; KNeighborsClassifier(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), KNeighborsClassifier__n_neighbors=<span class="number">79</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br><span class="line"><span class="number">3</span> = &#123;Individual&#125; GaussianNB(input_matrix)</span><br><span class="line"><span class="number">4</span> = &#123;Individual&#125; KNeighborsClassifier(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), KNeighborsClassifier__n_neighbors=<span class="number">84</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br></pre></td></tr></table></figure>
<p>然后对这几个pipeline进行打分评估，和上一轮pipeline一起选出score最高的前5个。</p>
<p>进入下一轮迭代。最后产生5个pipeline，打分，从中选出最优的那个：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Best pipeline: KNeighborsClassifier(input_matrix, n_neighbors=<span class="number">10</span>, p=<span class="number">2</span>, weights=distance)</span><br><span class="line"><span class="number">0.977777777778</span></span><br></pre></td></tr></table></figure>
<p>流程举例如下（具体流程和TPOT代码本身略有区别，但是不影响对遗传算法自动化建模的理解）</p>
<p><img src="/2020/03/28/TPOT%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/2.png" alt></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://blog.csdn.net/hgy0403/article/details/81291307">TPOT遗传算法</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10安装WSL2的Linux子系统及环境配置</title>
    <url>/2020/12/09/Win10%E5%AE%89%E8%A3%85WSL2%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>当我们在 Windows 平台上进行程序开发的时候，会遇到各种各样让人讨厌的问题，有时候还必须转到 Linux 环境下进行开发。然而，通过本文你将可以解决你在 Windows 平台上开发遇到的所有问题。<br><span id="more"></span></p>
<h3 id="1、Chocolate-Package-Manager"><a href="#1、Chocolate-Package-Manager" class="headerlink" title="1、Chocolate Package Manager"></a>1、Chocolate Package Manager</h3><p>对于开发人员而言，搭建开发环境是所有开发环节中的第一步，然而在 Windows 环境下，各种安装工具，软件版本五花八门，而且容易下载到病毒软件，因此对于初学者来说，下载到正确的开发软件，搭建好开发环境还是有一定难度和技巧性的.</p>
<p>如果希望 windows 平台上能有像 linux，macos 上的那种包管理工具，能让我一个命令就下载相应的环境，并把环境的路径添加到环境变量中，无需自己手动操作，然而这样的包管理工具已经存在了，Chocolate Package Manager 恰好是在Windows环境下处理搭建开发环境最好、也是最简单的解决方式之一。</p>
<p><img src="http://freeshow.oss-cn-beijing.aliyuncs.com/blog/20200222/111526357.png" alt></p>
<ul>
<li>官网：<a href="https://chocolatey.org/">https://chocolatey.org/</a></li>
<li>安装文档：<a href="https://chocolatey.org/install">https://chocolatey.org/install</a></li>
<li>Chocolate Packages：<a href="https://chocolatey.org/packages">https://chocolatey.org/packages</a></li>
</ul>
<p>Chocolate安装与卸载可参考<a href="https://www.jianshu.com/p/b8b618484d0d">这里</a></p>
<p>安装好 Chocolate 后，Windows 下的所有环境，包括 node，npm，python，java，git，filezilla 等都是用这个工具安装的，所有包自此之后都不需手动管理，就算要卸载，也只是一个命令。</p>
<h3 id="2、Windows-Subsystem-for-Linux"><a href="#2、Windows-Subsystem-for-Linux" class="headerlink" title="2、Windows Subsystem for Linux"></a>2、Windows Subsystem for Linux</h3><p>如果我们希望能在 Windows 上舒舒服服地学习、使用 Linux，微软已经解决了这个问题，而且解决的很好。</p>
<p>适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生虚拟机开销。</p>
<p>硬性要求：</p>
<p>Requirements：</p>
<ul>
<li><p>For x64 systems: Version 1903 or higher, with Build 18362 or higher.</p>
</li>
<li><p>For ARM64 systems: Version 2004 or higher, with Build 19041 or higher.</p>
</li>
</ul>
<p>官方安装参考教程：<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a></p>
<h3 id="3、-zsh-oh-my-zsh-安装"><a href="#3、-zsh-oh-my-zsh-安装" class="headerlink" title="3、 zsh + oh-my-zsh 安装"></a>3、 zsh + oh-my-zsh 安装</h3><p>zsh 官网：<a href="https://github.com/zsh-users/zsh">https://github.com/zsh-users/zsh</a></p>
<p>oh-my-zsh 官网：<a href="https://ohmyz.sh/">https://ohmyz.sh/</a></p>
<p>首先，安装 zsh<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install zsh</span><br></pre></td></tr></table></figure><br>把默认的Shell改成 zsh<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></p>
<p>安装 oh-my-zsh:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><br>更改zsh主题：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi .zshrc</span><br><span class="line">ZSH_THEME=&quot;ys&quot;</span><br></pre></td></tr></table></figure><br><img src="/2020/12/09/Win10%E5%AE%89%E8%A3%85WSL2%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/1.png" alt></p>
<p><img src="/2020/12/09/Win10%E5%AE%89%E8%A3%85WSL2%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2.png" alt></p>
<h3 id="4、-Windows-Terminal-安装"><a href="#4、-Windows-Terminal-安装" class="headerlink" title="4、 Windows Terminal 安装"></a>4、 Windows Terminal 安装</h3><p>在Microsoft Store里边搜索 Windows Terminal 并安装</p>
<p>如果希望有好用的命令行工具，微软推出的 windows terminal，支持多标签页，自定义样式，GPU 文本渲染，各种快捷键，屏幕分裂，json自定义配置等。</p>
<p><img src="/2020/12/09/Win10%E5%AE%89%E8%A3%85WSL2%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/3.png" alt></p>
<p>官方网址：<a href="https://github.com/microsoft/terminal">https://github.com/microsoft/terminal</a></p>
<h3 id="5、VSCode-Remote"><a href="#5、VSCode-Remote" class="headerlink" title="5、VSCode Remote"></a>5、VSCode Remote</h3><p>配置WSL环境（以Ubuntu 为例）</p>
<ol>
<li>如果是国内的话最好首先更改镜像源，然后更新 Linux 分发版。某些 WSL Linux 发行版缺少 VS Code 服务器启动所需的库。 可以通过使用包管理器将其他库添加到 Linux 分发中。在Ubuntu环境下就是通过执行sudo apt-get update，更新一下包管理器。</li>
<li>在WSL中的命令行并输入以下命令：code .（中间有空格），此步会自动布置WSL中的VSCode环境，等待片刻之后会在Windows中弹出一个VS Code窗口。在此之后也可以通过VS Code左下角的连接选项直接连接WSL。<br><img src="/2020/12/09/Win10%E5%AE%89%E8%A3%85WSL2%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/4.png" alt></li>
</ol>
<p>在WSL中安装C++环境<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc</span><br><span class="line">sudo apt-get install gdb</span><br><span class="line">sudo apt-get install g++</span><br></pre></td></tr></table></figure><br>在VS Code中</p>
<ul>
<li>安装C/C++插件<br><img src="/2020/12/09/Win10%E5%AE%89%E8%A3%85WSL2%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/5.png" alt></li>
</ul>
<p>配置C/C++编译</p>
<ul>
<li>创建一个C/CPP文件，按F5运行，会弹出配置C/C++，选择g++ - Build and debug active file<br><img src="https://img-blog.csdnimg.cn/20200809193504244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70" alt><br><img src="https://img-blog.csdnimg.cn/20200809193852769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=,size_16,color_FFFFFF,t_70" alt></li>
</ul>
<p>点击运行，在TERMINAL中查看<br><img src="/2020/12/09/Win10%E5%AE%89%E8%A3%85WSL2%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/6.png" alt></p>
<p>至此，Win10 开发环境搭建完成！！！</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><a href="https://blog.csdn.net/w851685279/article/details/108904106">win10 wsl2修改默认安装目录到其他盘</a></li>
<li><a href="https://my.oschina.net/u/4338498/blog/4440758">WSL2的安装详细过程</a></li>
<li><a href="https://segmentfault.com/a/1190000021742880">Windows下搭建最接近Linux体验的开发环境——使用WSL(Linux子系统)</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux, 工具</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下查看和添加PATH环境变量</title>
    <url>/2020/05/23/linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%B7%BB%E5%8A%A0PATH%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>$PATH：决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当您运行一个程序时，Linux在这些目录下进行搜寻编译链接。</p>
<p>编辑你的 PATH 声明，其格式为：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt;</span><br></pre></td></tr></table></figure><br>你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效，如果想立刻生效，则可执行下面的语句：$ source .bash_profile<br><span id="more"></span></p>
<h4 id="可用-export-命令查看PATH值"><a href="#可用-export-命令查看PATH值" class="headerlink" title="可用 export 命令查看PATH值"></a>可用 export 命令查看PATH值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) bryce@ubuntu:~$ export </span><br><span class="line"></span><br><span class="line">declare -x CFLAGS=&quot;-I/usr/local/cuda-10.0/include &quot;</span><br><span class="line">declare -x CLUTTER_IM_MODULE=&quot;xim&quot;</span><br><span class="line">declare -x COLORTERM=&quot;truecolor&quot;</span><br><span class="line">declare -x CONDA_DEFAULT_ENV=&quot;base&quot;</span><br><span class="line">declare -x CONDA_EXE=&quot;/home/bryce/anaconda3/bin/conda&quot;</span><br><span class="line">declare -x CONDA_PREFIX=&quot;/home/bryce/anaconda3&quot;</span><br><span class="line">declare -x CONDA_PROMPT_MODIFIER=&quot;(base) &quot;</span><br><span class="line">declare -x CONDA_PYTHON_EXE=&quot;/home/bryce/anaconda3/bin/python&quot;</span><br><span class="line">declare -x CONDA_SHLVL=&quot;1&quot;</span><br><span class="line">declare -x CPATH=&quot;/var/nccl-repo-2.5.6-ga-cuda10.0/include:&quot;</span><br><span class="line">declare -x CUDA_HOME=&quot;/usr/local/cuda-10.0&quot;</span><br><span class="line">declare -x CUDA_PATH=&quot;/usr/local/cuda-10.0&quot;</span><br><span class="line">declare -x DBUS_SESSION_BUS_ADDRESS=&quot;unix:path=/run/user/1000/bus&quot;</span><br><span class="line">declare -x DEFAULTS_PATH=&quot;/usr/share/gconf/ubuntu.default.path&quot;</span><br></pre></td></tr></table></figure>
<h4 id="单独查看PATH环境变量"><a href="#单独查看PATH环境变量" class="headerlink" title="单独查看PATH环境变量"></a>单独查看PATH环境变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) bryce@ubuntu:~$ echo $PATH </span><br><span class="line"></span><br><span class="line">/home/bryce/anaconda3/bin:/home/bryce/anaconda3/bin:/home/bryce/.local/share/umake/bin:/home/bryce/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/cuda-10.0/bin:/opt/google/chrome</span><br></pre></td></tr></table></figure>
<h4 id="添加PATH环境变量"><a href="#添加PATH环境变量" class="headerlink" title="添加PATH环境变量"></a>添加PATH环境变量</h4><p>1.命令行<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost u-boot-sh4]$ echo $PATH</span><br><span class="line"></span><br><span class="line">/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure><br>添加PATH环境变量，可用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost u-boot-sh4]$ export PATH=/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>再次查看：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost u-boot-sh4]$ echo $PATH</span><br><span class="line">/opt/STM/STLinux-2.3/devkit/sh4/bin:/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure><br>说明添加PATH成功。</p>
<p>第二种方法：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim /etc/profile</span><br></pre></td></tr></table></figure><br>在文档最后，添加:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=&quot;/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH&quot;</span><br></pre></td></tr></table></figure><br>保存退出(:wq)，然后运行：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ source /etc/profile</span><br></pre></td></tr></table></figure><br>不报错则成功。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>iTerm2 快捷键</title>
    <url>/2020/05/24/iTerm2-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>总结了工作过程中常用到的iTerm的快捷键</p>
<h3 id="光标控制"><a href="#光标控制" class="headerlink" title="光标控制"></a>光标控制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + a: 到行首</span><br><span class="line">ctrl + e: 行末</span><br><span class="line">ctrl + f/b: 前进后退，相当于左右方向键，但是显然比移开手按方向键更快</span><br><span class="line">ctrl + p: 上一条命令，相当于方向键上</span><br><span class="line">ctrl + r: 搜索命令历史，这个大家都应该很熟悉了</span><br><span class="line">ctrl + d: 删除当前字符</span><br><span class="line">ctrl + h: 删除之前的字符</span><br><span class="line">ctrl + w: 删除光标前的单词</span><br><span class="line">ctrl + k: 删除到文本末尾</span><br><span class="line">ctrl + t: 交换光标处文本</span><br><span class="line">⌘ + —/+/0: 调整字体大小</span><br><span class="line">⌘ + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="标签页操作"><a href="#标签页操作" class="headerlink" title="标签页操作"></a>标签页操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">垂直分屏：command + d</span><br><span class="line"></span><br><span class="line">水平分屏：command + shift + d</span><br><span class="line"></span><br><span class="line">切换屏幕：command + option + 方向键 command + [ 或 command + ]</span><br><span class="line"></span><br><span class="line">查看历史命令：command + ;</span><br><span class="line"></span><br><span class="line">查看剪贴板历史：command + shift + h</span><br></pre></td></tr></table></figure>
<h3 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">垂直分屏：command + d</span><br><span class="line"></span><br><span class="line">水平分屏：command + shift + d</span><br><span class="line"></span><br><span class="line">切换屏幕：command + option + 方向键 command + [ 或 command + ]</span><br><span class="line"></span><br><span class="line">查看历史命令：command + ;</span><br><span class="line"></span><br><span class="line">查看剪贴板历史：command + shift + h</span><br></pre></td></tr></table></figure>
<h3 id="选中即复制"><a href="#选中即复制" class="headerlink" title="选中即复制"></a>选中即复制</h3><p>iTerm2 有 2 种好用的选中即复制模式。</p>
<ul>
<li>一种是用鼠标，在 iterm2 中，选中某个路径或者某个词汇，那么，iterm2 就自动复制了。 　　</li>
<li>另一种是无鼠标模式，command+f,弹出 iterm2 的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入 tab，查找窗口将自动变化内容，并将其复制。如果输入的是 shift+tab，则自动将查找内容的左边选中并复制。</li>
</ul>
<h3 id="自动完成"><a href="#自动完成" class="headerlink" title="自动完成"></a>自动完成</h3><ul>
<li>输入打头几个字母，然后输入 command+; iterm2 将自动列出之前输入过的类似命令。 </li>
</ul>
<h3 id="剪切历史"><a href="#剪切历史" class="headerlink" title="剪切历史"></a>剪切历史</h3><p>输入 command+shift+h，iterm2 将自动列出剪切板的历史记录。如果需要将剪切板的历史记录保存到磁盘，在 Preferences &gt; General &gt; Save copy/paste history to disk 中设置。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>extern关键字总结</title>
    <url>/2020/09/18/extern%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p><strong>extern</strong>是一种“<strong>外部声明</strong>”的关键字，字面意思就是<strong>在此处声明</strong>某种变量或函数，<strong>在外部定义</strong>。</p>
<p>extern关键字的主要作用是扩大变量/函数的作用域，使得其它源文件和头文件可以复用同样的变量/函数，也起到类似“分块储存”的作用，划分代码。如图所示，在一个头文件里做了外部声明，就能把变量的定义部分和函数体的实现部分转移到其它地方了，也就是extern可以实现多文件<strong>共享</strong>同一个变量、const常量、函数。<br><span id="more"></span><br>例子1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//file2.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>输出：将两个文件一起编译，则输出会是3</p>
<p>因为file1使用了在file2中定义的全局变量count，全局变量也叫外部变量，具有外部链接性，意思就是可以被外部文件引用。</p>
<p><strong>注意：</strong>当使用extern声明变量时，要求被声明的变量只能在一个文件中被定义，比如再有个file3里面也定义了一个名为count的全局变量，然后跟file1、file2一起编译，那编译器就会报错，因为不知道要引用哪个count，这也被称为单独定义规则。</p>
<p>总而言之，在多文件程序中，可以在一个文件（且只能在一个文件）中定义一个外部变量。使用该变量的其他文件必须使用extern来声明他。(摘自C++ Primer Plus)</p>
<p>例子2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line">	count++;</span><br><span class="line">	cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">f</span>(x+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">f</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//file2.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">输出：</span><br><span class="line">file1和file2一起编译，运行后的输出是：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>因为file1使用extern声明的count实际上就是file2中的count（同一个存储地址），file1只是声明要引用file2中的count，而不是重新定义一个count，所以即使递归调用函数也不会影响count保留上一次的值。这一点跟用static定义一个内部变量很像，不同的是static定义的内部变量只能初始化一次，而extern声明的变量不能初始化。</p>
<p>例子3：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//file2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> x=<span class="number">5</span>;</span><br><span class="line">...</span><br><span class="line">file1和file2一起编译，运行后的输出是<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>显然file1通过extern声明引用了在file2中的const常量x。</p>
<p><strong>注意：</strong>file1和file2都要加extern，才能实现多个文件共享一个const常量</p>
<p>因为const声明的常量它的链接性是内部的，默认是不能被其他文件用extern引用的。也就是说例1中说的单定义规则对它并不适用，所以即使在多个文件中定义同名的const常量，也不会有问题。</p>
<p>可以使用extern来覆盖其默认的内部链接性，就像file2中做得那样，并且只能在一个文件中被初始化。</p>
<h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>是用于C++链接在C语言模块中定义的函数。</p>
<h4 id="1-C-与C编译的区别"><a href="#1-C-与C编译的区别" class="headerlink" title="1. C++与C编译的区别"></a>1. C++与C编译的区别</h4><p>C++虽然兼容C，但C++文件中函数编译后生成的符号与C语言生成的不同。因为C++支持函数重载，C++函数编译后生成的符号带有函数参数类型的信息，而C则没有。</p>
<p>例如<code>int add(int a, int b)</code>函数经过C++编译器生成.o文件后，<code>add</code>会变成形如<code>add_int_int</code>之类的, 而C的话则会是形如<code>_add</code>, 就是说：相同的函数，在C和C++中，编译后生成的符号不同。</p>
<p>这就导致一个问题：如果C++中使用C语言实现的函数，在编译链接的时候，会出错，提示找不到对应的符号。此时<code>extern "C"</code>就起作用了：告诉链接器去寻找<code>_add</code>这类的C语言符号，而不是经过C++修饰的符号。</p>
<h3 id="2-C-调用C函数"><a href="#2-C-调用C函数" class="headerlink" title="2. C++调用C函数"></a>2. C++调用C函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_H</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"add.h"</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">"add.h"</span></span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="3-C调用C"><a href="#3-C调用C" class="headerlink" title="3. C调用C++"></a>3. C调用C++</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_H</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"add.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>综上，总结出使用方法，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。所以使用extern “C”全部都放在于cpp程序相关文件或其头文件中。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>#ifndef/#define/#endif的作用</title>
    <url>/2020/05/02/ifndef-define-endif%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>头文件中的 #ifndef/#define/#endif 作用主要是防止该头文件被重复引用。</p>
<p>假设一个工程里面有4个文件，分别是a.cpp,b.h,c.h,d.h。<br>a.cpp的头部是：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;b.h &quot;</span><br><span class="line">#include &quot;c.h &quot;</span><br></pre></td></tr></table></figure><br><span id="more"></span><br>b.h和c.h的头部都是:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;d.h &quot;</span><br></pre></td></tr></table></figure><br>而d.h里面有class D的定义。</p>
<p>这样一来，<br>编译器编译a.cpp的时候，先根据#include “b.h “去编译b.h这个问题，再根据b.h里面的#include “d.h “，去编译d.h的这个文件，这样就把d.h里面的class D编译了；<br>然后再根据a.cpp的第二句#include “c.h “，去编译c.h，最终还是会找到的d.h里面的class D，但是class D之前已经编译过了，所以就会报重定义错误。</p>
<p>加上#ifndef/#define/#endif，就可以防止这种重定义错误。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 命令行光标移动技巧</title>
    <url>/2020/05/11/linux-%E5%91%BD%E4%BB%A4%E8%A1%8C-%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>记录一下linux 命令行光标移动快捷键。</p>
<ul>
<li>ctrl+a:光标移到行首。</li>
<li>ctrl+b:光标左移一个字母</li>
<li>ctrl+c:杀死当前进程。</li>
<li>ctrl+d:退出当前 Shell。</li>
<li>ctrl+e:光标移到行尾。</li>
<li>ctrl+h:删除光标前一个字符，同 backspace 键相同。</li>
<li>ctrl+k:清除光标后至行尾的内容。</li>
<li>ctrl+l:清屏，相当于clear。<span id="more"></span></li>
<li>ctrl+r:搜索之前打过的命令。会有一个提示，根据你输入的关键字进行搜索bash的history</li>
<li>ctrl+u: 清除光标前至行首间的所有内容。</li>
<li>ctrl+w: 移除光标前的一个单词</li>
<li>ctrl+t: 交换光标位置前的两个字符</li>
<li>ctrl+y: 粘贴或者恢复上次的删除</li>
<li>ctrl+d: 删除光标所在字母;注意和backspace以及ctrl+h的区别，这2个是删除光标前的字符</li>
<li>ctrl+f: 光标右移</li>
<li>ctrl+z : 把当前进程转到后台运行，使用’ fg ‘命令恢复。比如top -d1 然后ctrl+z ，到后台，然后fg,重新恢复</li>
<li>esc组合</li>
<li>esc+d: 删除光标后的一个词</li>
<li>esc+f: 往右跳一个词</li>
<li>esc+b: 往左跳一个词</li>
<li>esc+t: 交换光标位置前的两个单词。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vim常用快捷键</title>
    <url>/2020/05/24/vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>vim包含三种模式，分别是一般模式、编辑模式和命令模式，一般模式可以用来移动光标、复制粘贴、删除等，编辑模式可以编辑文字，命令模式可以用来保存、退出、显示或隐藏行号等。</p>
<p>总结一下工作过程中常用到的快捷键<br><span id="more"></span></p>
<h3 id="一般模式下常用的快捷键"><a href="#一般模式下常用的快捷键" class="headerlink" title="一般模式下常用的快捷键"></a>一般模式下常用的快捷键</h3><h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + u: 向上翻半页</span><br><span class="line">ctrl + d: 向下翻半页</span><br><span class="line"></span><br><span class="line">输入:set nu显示行号</span><br><span class="line"></span><br><span class="line">G: 移动到最后一行</span><br><span class="line">g: 移动到首行</span><br><span class="line">nG: n为数字，移动到某行。如12G就是移动到第12行</span><br><span class="line"></span><br><span class="line">0: 移动到行首</span><br><span class="line">$: 移动到行尾</span><br></pre></td></tr></table></figure>
<h4 id="搜索关键字"><a href="#搜索关键字" class="headerlink" title="搜索关键字"></a>搜索关键字</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/keywords: 输入关键字并向下搜索</span><br><span class="line">?keywords: 输入关键字并向上搜索</span><br><span class="line">n: 显示下一个搜索结果</span><br><span class="line">N: 显示上一个搜索结果</span><br></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x: 向后删除，类似普通键盘的del键</span><br><span class="line">X: 向前删除，类似普通键盘的backspace键和mac的delete键</span><br><span class="line">nx: n为数字。向后删除n个字符</span><br><span class="line">nX: n为数字。向前删除n个字符</span><br><span class="line">d0: 删除从光标到行首的内容</span><br><span class="line">d$: 删除从光标到行尾的内容</span><br><span class="line">dd: 删除光标所在的一行</span><br><span class="line">ndd: n为数字。删除光标所在的向下n行。例如，5dd就是从光标所在行开始向下共删除5行</span><br></pre></td></tr></table></figure>
<h4 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yy: 复制光标所在行</span><br><span class="line">nyy: n为数字。从光标所在行开始，向下复制n行。</span><br><span class="line">y1G: 复制光标所在行（含）到第一行的所有内容</span><br><span class="line">yG: 复制光标所在行（含）到最后一行的所有内容</span><br><span class="line">y0: 复制光标所在位置到行首的内容</span><br><span class="line">y$: 复制光标所在位置到行尾的内容</span><br><span class="line">p: 如果复制的是整行，则在光标所在行的下方粘贴内容。如果是部分行，则在光标后方粘贴</span><br><span class="line">P: 如果复制的是整行，则在光标所在行的上方粘贴内容。如果是部分行，则在光标后方粘贴</span><br><span class="line"></span><br><span class="line">u: 撤销上一步的操作</span><br><span class="line">ctrl+r: 恢复上一步被撤销的操作</span><br></pre></td></tr></table></figure>
<h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i: 进入编辑模式，光标不变</span><br><span class="line">A: 进入编辑模式，光标定位到所在行的最后一个字符后面</span><br><span class="line">o: (小写字母o)进入编辑模式，在光标所在行下方新建一行并将光标移到此行</span><br><span class="line">O: (大写字母O)进入编辑模式，在光标所在行上方新建一行并将光标移到此行</span><br><span class="line">esc: 退出编辑模式</span><br></pre></td></tr></table></figure>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:w  : 将数据写入文件，或者理解为保存</span><br><span class="line">:q  : 退出vim</span><br><span class="line">:q! : 强制退出vim。如果文件内容已编辑却未保存，且用户想放弃保存并退出，则使用该快捷键</span><br><span class="line">:wq : 保存并退出</span><br><span class="line">:w filename : (中间有空格)另存为另一个文件</span><br><span class="line">:set nu	: 显示行号</span><br><span class="line">:set nonu	: 不显示行号</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vector扩容原理说明</title>
    <url>/2020/04/02/vector%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h3 id="扩容原理概述"><a href="#扩容原理概述" class="headerlink" title="扩容原理概述"></a>扩容原理概述</h3><ul>
<li>新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素</li>
<li>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了</li>
<li>初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1</li>
<li>不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。<span id="more"></span>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;capacity: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><ul>
<li>GCC输出</li>
</ul>
<p><img src="/2020/04/02/vector%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E/1.png" alt></p>
<ul>
<li>VS2015输出</li>
</ul>
<p><img src="/2020/04/02/vector%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E/2.png" alt></p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><ul>
<li><p>可以根据输出看到，vector是以2倍的方式扩容的。有两个疑问：</p>
<ul>
<li>为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？</li>
<li>为什么是以两倍的方式扩容而不是三倍四倍，或者其他方式呢？</li>
</ul>
</li>
<li><p>第一个问题：</p>
<ul>
<li><p>以成倍方式增长</p>
<ol>
<li>假定有 n 个元素,倍增因子为 m；</li>
<li>完成这 n 个元素往一个 vector 中的 push_back​操作，需要重新分配内存的次数大约为 logm(n)；</li>
<li>第 i 次重新分配将会导致复制 m^(i) (也就是当前的vector.size() 大小)个旧空间中元素;</li>
<li>n 次 push_back 操作所花费的时间复制度为O(n):<script type="math/tex; mode=display">
\sum_{i=1}^{\log _{m}^{n}} m^{i} \approx \frac{n m}{m-1}</script></li>
<li>m / (m - 1)，这是一个常量，均摊下来vector中push_back操作的时间复杂度为常量时间.​</li>
</ol>
</li>
<li><p>一次增加固定值大小</p>
<ol>
<li>假定有 n 个元素,每次增加k个；</li>
<li>第i次增加复制的数量为：k*i</li>
<li>n 次 push_back 操作所花费的时间复杂度为O(n^2):<script type="math/tex; mode=display">\sum_{i=1}^{n / k} k i</script></li>
<li>均摊下来每次push_back 操作的时间复杂度为O(n)；</li>
</ol>
</li>
</ul>
</li>
<li><p>总结：对比可以发现采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。</p>
</li>
<li><p>第二个问题：</p>
<ol>
<li>根据查阅的资料显示，考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2二倍的方式扩容，或者以1.5倍的方式扩容。</li>
<li><p>以2倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间:</p>
<script type="math/tex; mode=display">k \sum_{i=0}^{n} 2^{i}=k\left(2^{n+1}-1\right)<k 2^{n+1}</script></li>
</ol>
<ul>
<li><p>知乎上看到一个很好的解释：</p>
<p>  <a href="https://www.zhihu.com/question/36538542/answer/67929747">C++ STL中vector内存用尽后，为啥每次是两倍的增长，而不是3倍或其他数值</a></p>
</li>
<li><p>借用他的一张图来说明2倍与1.5倍的区别：</p>
<p><img src="/2020/04/02/vector%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E/3.png" alt></p>
</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。</p>
</li>
<li><p>为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，更好一点。</p>
</li>
</ol>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://blog.csdn.net/yangshiziping/article/details/52550291">vector扩容原理说明</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找算法总结</title>
    <url>/2020/04/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="二分查找算法总结"><a href="#二分查找算法总结" class="headerlink" title="二分查找算法总结"></a>二分查找算法总结</h1><p>二分查找法作为一种常见的查找方法，将原本是线性时间提升到了对数时间范围，大大缩短了搜索时间，具有很大的应用场景，而在 LeetCode 中，要运用二分搜索法来解的题目也有很多，但是实际上二分查找法的查找目标有很多种，而且在细节写法也有一些变化。我就对二分查找法的具体写法做个总结。<br><span id="more"></span></p>
<h2 id="基础-二分查找的框架"><a href="#基础-二分查找的框架" class="headerlink" title="基础: 二分查找的框架"></a>基础: 二分查找的框架</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>,end = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid =  start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) </span><br><span class="line">        &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) </span><br><span class="line">        &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析二分查找的一个技巧是：不要出现 <code>else</code>，而是把所有情况用 <code>else if</code> 写清楚，这样可以清楚地展现所有细节。本文都会使用 <code>else if</code>，旨在讲清楚，读者理解后可自行简化。</p>
<p>其中 … 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p>
<p>另外声明一下，计算 <code>mid</code> 时需要技巧防止溢出，在 <code>start</code> 和 <code>end</code> 都比较大的时候，<code>start + end</code> 很有可能超过 <code>int</code> 类型能表示的最大值，即整型溢出，为了避免这个问题，应该写成： <code>mid=start+(end-start)/2</code>。事实上，<code>int mid = start + (end - start) / 2</code> 在 <code>end</code> 很大、 <code>start</code> 是负数且很小的时候， <code>end - start</code> 也有可能超过 <code>int</code> 类型能表示的最大值，只不过一般情况下 <code>end</code> 和 <code>start</code> 表示的是数组索引值，<code>start</code> 是非负数，因此 <code>end - start</code> 溢出的可能性很小。更好的写法是：<code>int mid = (start + end) &gt;&gt;&gt; 1</code> .</p>
<h2 id="第一类：寻找一个数（基本的二分查找）"><a href="#第一类：寻找一个数（基本的二分查找）" class="headerlink" title="第一类：寻找一个数（基本的二分查找）"></a>第一类：寻找一个数（基本的二分查找）</h2><p>这是最简单的一类，也是我们最开始学二分查找法需要解决的问题,即搜索一个数，如果存在，返回其索引，否则返回 -1，比如我们有数组 <code>[2, 4, 5, 6, 9]</code>，<code>target = 6</code>，那么我们可以写出二分查找法的代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (end&gt;=start)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid]==target)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        start = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        end = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>Q&amp;A:</strong></p>
<p>1.为什么<code>while</code>循环的条件中是 &lt;=，而不是 &lt; ？</p>
<p>答：因为初始化 <code>end</code> 的赋值是 <code>n-1</code>，即最后一个元素的索引，而不是 <code>n</code>。<br>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[start, end]</code>，后者相当于左闭右开区间 <code>[start, end)</code>，因为索引大小为 <code>n</code> 是越界的。</p>
<p>我们这个算法中使用的是前者 <code>[start, end]</code> 两端都闭的区间。这个区间其实就是每次进行搜索的区间，我们称之为「搜索区间」。</p>
<p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">    <span class="keyword">return</span> mid; </span><br></pre></td></tr></table></figure><br>但如果没找到，就需要 <code>while</code> 循环终止，然后返回 <code>-1</code>。那 <code>while</code> 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到。</p>
<p><code>while(start &lt;= end)</code> 的终止条件是 <code>start == end + 1</code>，写成区间的形式就是 <code>[end + 1, end]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见这时候搜索区间为空，这时候 <code>while</code> 循环终止是正确的，直接返回 <code>-1</code> 即可。</p>
<p><code>while(start &lt; end)</code> 的终止条件是 <code>start == end</code>，写成区间的形式就是 <code>[start, end]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，这时候搜索区间非空，还有一个数<code>2</code>，但此时 <code>while</code> 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 <code>2</code>没有被搜索，如果这时候直接返回 <code>-1</code> 就是错误的。</p>
<p>2.为什么 <code>start = mid + 1</code>，<code>end = mid - 1</code>？我看有的代码是 <code>start = mid</code> 或者 <code>end = mid</code>，没有这些加1减1，如何判断？</p>
<p>答：这也是二分查找的一个难点，刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[start, end]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，如何确定下一步的搜索区间呢？</p>
<p>当然是 <code>[start, mid - 1]</code> 或者 <code>[mid + 1, end]</code> 对不对？因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除。</p>
<p>3.此算法有什么缺陷？</p>
<p>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</p>
<p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target = 2</code>，此算法返回的索引是 <code>2</code>，没错。但是如果我们想得到 <code>target</code> 的左侧边界，即索引 <code>1</code>，或者我想得到 <code>target</code> 的右侧边界，即索引 <code>3</code>，这样的话此算法是无法处理的。</p>
<p>这样的需求很常见。你也许会说，找到一个 <code>target</code>，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。</p>
<p>我们后续的算法就来讨论这两种二分查找的算法。</p>
<h2 id="第二类：寻找左侧边界的二分搜索"><a href="#第二类：寻找左侧边界的二分搜索" class="headerlink" title="第二类：寻找左侧边界的二分搜索"></a>第二类：寻找左侧边界的二分搜索</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end = n;</span><br><span class="line">    <span class="keyword">while</span> (end&gt;start)  <span class="comment">// 搜索区间左闭右开</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid]==target)</span><br><span class="line">      &#123;</span><br><span class="line">        end = mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        start = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        end = mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// start == n时说明target比所有数都大，不存在返回-1</span></span><br><span class="line">    <span class="comment">// if (nums[start]!=target || start == n) return -1;</span></span><br><span class="line">    <span class="comment">// 返回start是返回的数组中的坐标，就是小于某个数的坐标</span></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Q&amp;A:</strong></p>
<p>1.为什么 <code>while(start &lt; end)</code> 而不是 <code>&lt;=</code>?</p>
<p>答：用相同的方法分析，因为 <code>end = n</code> 而不是 <code>n - 1</code> 。因此每次循环的「搜索区间」是 <code>[start, end)</code> 左闭右开。<br><code>while(start &lt; end)</code> 终止的条件是 <code>start == end</code>，此时搜索区间 <code>[start, start)</code>或者写成<code>[end, end)</code>为空，所以可以正确终止。</p>
<p>2.如何理解左侧边界？</p>
<p>答：</p>
<p><img src="/2020/04/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1.png" alt="1"></p>
<p>对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：<code>nums</code> 中小于 2的元素有 1 个。</p>
<p>比如对于有序数组 <code>nums = [2,3,5,7]</code>, <code>target = 1</code>，算法会返回 <code>0</code>，含义是：<code>nums</code> 中小于 1 的元素有 0 个。</p>
<p>再比如说 <code>nums</code> 不变，<code>target = 8</code>，算法会返回 4，含义是：<code>nums</code> 中小于 8 的元素有 4 个。</p>
<p>综上可以看出，函数的返回值（即 <code>start</code> 变量的值）取值区间是闭区间 <code>[0, n]</code>，如果start的值为<code>n</code>或者<code>nums[start]!=target</code>说明数组中没有目标值，返回-1</p>
<p>3.为什么 <code>start = mid + 1</code>，<code>end = mid</code> ？和之前的算法不一样？</p>
<p>答：这个很好解释，因为我们的「搜索区间」是 <code>[start, end)</code> <strong>左闭右开</strong>，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 <code>[start, mid)</code> 或 <code>[mid + 1, end)</code>。</p>
<p>4.为什么该算法能够搜索左侧边界？</p>
<p>答:关键在于对于 nums[mid] == target 这种情况的处理：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">    end = mid;</span><br></pre></td></tr></table></figure><br>可见，找到 <code>target</code> 时不要立即返回，而是缩小「搜索区间」的上界 <code>end</code>，在区间 <code>[start, end)</code> 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p>
<p>5.为什么返回 <code>start</code> 而不是 <code>end</code>？</p>
<p>答：都是一样的，因为 <code>while</code> 终止的条件是 <code>start == end</code>。</p>
<h2 id="第三类：寻找右侧边界的二分查找"><a href="#第三类：寻找右侧边界的二分查找" class="headerlink" title="第三类：寻找右侧边界的二分查找"></a>第三类：寻找右侧边界的二分查找</h2><p>寻找右侧边界和寻找左侧边界的代码差不多，只有两处不同，已标注：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end = n;</span><br><span class="line">    <span class="keyword">while</span> (end&gt;start)  <span class="comment">// 搜索区间左开右闭</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid]==target)</span><br><span class="line">      &#123;</span><br><span class="line">        start = mid + <span class="number">1</span>;  <span class="comment">// 注意 增大左边界，向右收缩</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        start = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        end = mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end<span class="number">-1</span>;  <span class="comment">//注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>Q&amp;A:</strong></p>
<ol>
<li>为什么这个算法能够找到右侧边界？</li>
</ol>
<p>答：类似地，关键点还是这里：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid]==target)</span><br><span class="line">    start = mid + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>当 <code>nums[mid] == target</code> 时，不要立即返回，而是增大「搜索区间」的下界 <code>start</code>，使得区间不断向右收缩，达到锁定右侧边界的目的。</p>
<p>2.为什么最后返回 <code>end - 1</code> 而不像左侧边界的函数，返回 <code>start</code>？而且我觉得这里既然是搜索右侧边界，应该返回 <code>end</code> 才对。</p>
<p>答：首先，<code>while</code> 循环的终止条件是 <code>start == end</code>，所以 <code>start</code> 和 <code>end</code> 是一样的，要体现右侧的特点，返回 <code>end - 1</code> 好了。</p>
<p>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">    start = mid + <span class="number">1</span>;<span class="comment">//等价于：mid = start - 1</span></span><br></pre></td></tr></table></figure><br><img src="/2020/04/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/2.png" alt="2"></p>
<p>因为我们对 <code>start</code> 的更新必须是 <code>start = mid + 1</code>，就是说 <code>while</code> 循环结束时，<code>nums[start]</code> 一定不等于 <code>target</code> 了，而 <code>nums[start-1]</code> 可能是 <code>target</code>,也就是<code>return end-1</code>。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>来梳理一下这些细节差异的因果逻辑：</p>
<p>第一个，最基本的二分查找算法：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为我们初始化 end = nums.size() - 1</span><br><span class="line">所以决定了我们的「搜索区间」是 [start, end]</span><br><span class="line">所以决定了 while (start &lt;= end)</span><br><span class="line">同时也决定了 start = mid+1 和 end = mid-1</span><br><span class="line"></span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br></pre></td></tr></table></figure></p>
<p>第二个，寻找左侧边界的二分查找：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为我们初始化 end = nums.size()</span><br><span class="line">所以决定了我们的「搜索区间」是 [start, end)</span><br><span class="line">所以决定了 while (start &lt; end)</span><br><span class="line">同时也决定了 start = mid + 1 和 end = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br></pre></td></tr></table></figure></p>
<p>第三个，寻找右侧边界的二分查找：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为我们初始化 end = nums.size()</span><br><span class="line">所以决定了我们的「搜索区间」是 (start, end]</span><br><span class="line">所以决定了 while (start &lt; end)</span><br><span class="line">同时也决定了 start = mid + 1 和 end = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line"></span><br><span class="line">又因为收紧左侧边界时必须 start = mid + 1</span><br><span class="line">所以最后无论返回 start 还是 end，必须减一</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>两个线程交替打印0~100的奇偶数</title>
    <url>/2020/08/31/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B00-100%E7%9A%84%E5%A5%87%E5%81%B6%E6%95%B0/</url>
    <content><![CDATA[<p>有两个线程，一个名为偶数线程，一个名为奇数线程，偶数线程只打印偶数，奇数线程只打印奇数，两个线程按顺序交替打印<br><span id="more"></span><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mu;</span><br><span class="line">std::condition_variable cond;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintOdd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mu)</span></span>;</span><br><span class="line">        cond.<span class="built_in">wait</span>(locker,[]()&#123; <span class="built_in">return</span> (count%<span class="number">2</span> == <span class="number">1</span>); &#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;奇数线程: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">        count++;</span><br><span class="line">        locker.<span class="built_in">unlock</span>();</span><br><span class="line">        cond.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEven</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mu)</span></span>;</span><br><span class="line">        cond.<span class="built_in">wait</span>(locker,[]()&#123; <span class="built_in">return</span> (count%<span class="number">2</span> == <span class="number">0</span>); &#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;偶数线程: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">        count++;</span><br><span class="line">        locker.<span class="built_in">unlock</span>();</span><br><span class="line">        cond.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(PrintOdd)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(PrintEven)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>C++优先队列的使用方法（自定义排序）</title>
    <url>/2020/04/13/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
    <content><![CDATA[<p>priority_queue本质是一个堆。</p>
<p>1.头文件是<code>#include&lt;queue&gt;</code></p>
<p>2.关于priority_queue中元素的比较</p>
<p>模板申明带3个参数：priority_queue<Type, container, functional>，其中Type 为数据类型，Container为保存数据的容器，Functional 为元素比较方式。</Type,></p>
<p>Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector。<br><span id="more"></span><br>基本操作有：</p>
<p>empty( )  //判断一个队列是否为空</p>
<p>pop( )  //删除队顶元素</p>
<p>top( )  //返回优先队列的队顶元素</p>
<p>push( )  //加入一个元素</p>
<p>size( )  //返回优先队列中拥有的元素个数</p>
<p>优先队列的时间复杂度为O（logn），n为队列中元素的个数，其存取都需要时间。</p>
<p>在默认的优先队列中，优先级最高的先出队。默认的int类型的优先队列中先出队的为队列中较大的数。</p>
<p>2.1 第一种用法（默认从大到小排序）：</p>
<p>如果元素是pair的话，先按照pair的first元素降序，first元素相等时，再按照second元素降序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q1;<span class="comment">//默认从大到小排序，整数中元素大的优先级高 </span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q1;<span class="comment">//默认从大到小排序 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;t;</span><br><span class="line">		q1.<span class="built_in">push</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;q1.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		q1.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="/2020/04/13/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%EF%BC%89/1.png" alt></p>
<p>2.2 第二种用法（从小到大排序）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;q1;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;q1;<span class="comment">//从大到小排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;t;</span><br><span class="line">		q1.<span class="built_in">push</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;q1.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		q1.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2020/04/13/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%EF%BC%89/2.png" alt></p>
<p>2.3 第三种用法：自定义排序规则<br>对于自定义类型，则必须重载operator&lt;或者重写仿函数<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> tmp[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp1</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x&gt;y;<span class="comment">//小的优先级高 ,从小到大排 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x,<span class="type">const</span> <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> tmp[x]&gt;tmp[y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node a,node b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a.x&gt;b.x;<span class="comment">//按x从小到大排 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt;q1;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,cmp1&gt;q2;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,cmp2&gt;q3;</span><br><span class="line">priority_queue&lt;node&gt;q4;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,m,n;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	node a;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;a.y&gt;&gt;a.x;</span><br><span class="line">			q4.<span class="built_in">push</span>(a);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">while</span>(!q4.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;q4.<span class="built_in">top</span>().y&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q4.<span class="built_in">top</span>().x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endl;</span><br><span class="line">			q4.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;t;</span><br><span class="line">			q2.<span class="built_in">push</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!q2.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;q2.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">			q2.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果：</p>
<p><img src="/2020/04/13/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%EF%BC%89/3.png" alt></p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/ac_gibson/article/details/44200411">c++STL中优先队列的使用</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用gdb调试core文件</title>
    <url>/2020/08/10/%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95core%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="1-core文件"><a href="#1-core文件" class="headerlink" title="1.core文件"></a>1.core文件</h3><p>实习工作时经常听到一个概念是程序core掉了，需要定位解决，这里说的大部分是指对应程序由于各种异常或者bug导致在运行过程中异常退出或者中止，并且在满足一定条件下会产生一个叫做core的文件。</p>
<p>通常情况下，core文件会包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息还有各种函数调用堆栈信息等，我们可以理解为是程序工作当前状态存储生成第一个文件，许多的程序出错的时候都会产生一个core文件，通过工具分析这个文件，我们可以定位到程序异常退出的时候对应的堆栈调用等信息，找出问题所在并进行及时解决。</p>
<p>使用 gdb 调试 core 文件，可以帮助我们快速定位程序出现段错误的位置。当然，可执行程序编译时应加上 -g 编译选项，生成调试信息。</p>
<p>当程序访问非法内存会产生段错误，产生段错误的常见情况有：</p>
<p>（1）访问不存在的内存地址；</p>
<p>（2）访问系统保护的内存地址；</p>
<p>（3）数组访问越界等。<br><span id="more"></span></p>
<h3 id="2-配置操作系统使其产生core文件"><a href="#2-配置操作系统使其产生core文件" class="headerlink" title="2. 配置操作系统使其产生core文件"></a>2. 配置操作系统使其产生core文件</h3><p>首先通过ulimit命令查看一下系统是否配置支持了dump core的功能。通过ulimit -c或ulimit -a，可以查看core file大小的配置情况，如果为0，则表示系统关闭了dump core。可以通过ulimit -c unlimited来打开，或者 ulimit -c 1024 设置相应的core文件大小。<strong>若发生了段错误，但没有core dump，是由于系统禁止core文件的生成。</strong></p>
<p>注意：这样设置只对当前shell进程有效</p>
<h3 id="3-利用gdb进行coredump的定位分析"><a href="#3-利用gdb进行coredump的定位分析" class="headerlink" title="3. 利用gdb进行coredump的定位分析"></a>3. 利用gdb进行coredump的定位分析</h3><p><strong>test.cc的源码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">core_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, i) <span class="comment">/*should have used &amp; to get addr other than access directly*/</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d/n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">core_test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> *ptr = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  *prt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">core_test1</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>编译执行</strong><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ test.cc -g -o test</span><br></pre></td></tr></table></figure><br>-g 在编译的时候，产生调试信息</p>
<p>-o 制定目标名称,缺省的时候, gcc 编译出来的文件是a.out</p>
<p><strong>运行程序，自动生成core文件</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure><br>可以看到，当输入12的时候，系统提示段错误并且core dumped</p>
<p><img src="/2020/08/10/%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95core%E6%96%87%E4%BB%B6/1.jpg" alt></p>
<p><strong>gdb调试core文件</strong></p>
<p>使用flie 命令确认是否core文件格式</p>
<p><img src="/2020/08/10/%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95core%E6%96%87%E4%BB%B6/2.jpg" alt></p>
<p>使用gdb调试<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb test core</span><br></pre></td></tr></table></figure></p>
<p><img src="/2020/08/10/%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95core%E6%96%87%E4%BB%B6/3.jpg" alt></p>
<p>从红色方框截图可以看到，程序中止是因为信号11，且从bt(backtrace)命令（或者where）可以看到函数的调用栈，即程序执行到test.cc的第4行，且里面调用scanf 函数，而该函数其实内部会调用_IO_vfscanf_internal()函数。</p>
<p>注意记住几个常用的gdb命令：</p>
<p>l(list) ，显示源代码，并且可以看到对应的行号；</p>
<p>b(break)x, x是行号，表示在对应的行号位置设置断点；</p>
<p>p(print)x, x是变量名，表示打印变量x的值</p>
<p>r(run), 表示继续执行到断点的位置</p>
<p>n(next),表示执行下一步</p>
<p>c(continue),表示继续执行</p>
<p>q(quit)，表示退出gdb</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">i local</span><br><span class="line">p <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p *(string*)(*(GeneralSearchRequest*)search_req).raw_query_-&gt;tagged_ptr_-&gt;ptr_</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/10/%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95core%E6%96%87%E4%BB%B6/5.jpg" alt></p>
<h3 id="4-coredump的一些原因"><a href="#4-coredump的一些原因" class="headerlink" title="4. coredump的一些原因"></a>4. coredump的一些原因</h3><p>1、内存访问越界</p>
<p>a) 由于使用错误的下标，导致数组访问越界</p>
<p>b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符</p>
<p>c) 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。</p>
<p>2、多线程程序使用了线程不安全的函数。</p>
<p>3、多线程读写的数据未加锁保护。对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump</p>
<p>4、非法指针</p>
<p>a) 使用空指针</p>
<p>b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump.</p>
<p>5、堆栈溢出.不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。</p>
<h3 id="5-附注"><a href="#5-附注" class="headerlink" title="5. 附注"></a>5. 附注</h3><p><strong>一些常用signal的含义</strong></p>
<p>SIGABRT：调用abort函数时产生此信号。进程异常终止。</p>
<p>SIGBUS：指示一个实现定义的硬件故障。</p>
<p>SIGEMT：指示一个实现定义的硬件故障。EMT这一名字来自PDP-11的emulator trap 指令。</p>
<p>SIGFPE：此信号表示一个算术运算异常，例如除以0，浮点溢出等。</p>
<p>SIGILL：此信号指示进程已执行一条非法硬件指令。4.3BSD由abort函数产生此信号。SIGABRT现在被用于此。</p>
<p>SIGIOT：这指示一个实现定义的硬件故障。IOT这个名字来自于PDP-11对于输入／输出TRAP(input/outputTRAP)指令的缩写。系统V的早期版本，由abort函数产生此信号。SIGABRT现在被用于此。</p>
<p>SIGQUIT：当用户在终端上按退出键（一般采用Ctrl-/）时，产生此信号，并送至前台进</p>
<p>程组中的所有进程。此信号不仅终止前台进程组（如SIGINT所做的那样），同时产生一个core文件。</p>
<p>SIGSEGV：指示进程进行了一次无效的存储访问。名字SEGV表示“段违例（segmentationviolation）”。</p>
<p>SIGSYS：指示一个无效的系统调用。由于某种未知原因，进程执行了一条系统调用指令，但其指示系统调用类型的参数却是无效的。</p>
<p>SIGTRAP：指示一个实现定义的硬件故障。此信号名来自于PDP-11的TRAP指令。</p>
<p>SIGXCPUSVR4和4.3+BSD支持资源限制的概念。如果进程超过了其软C P U时间限制，则产生此信号。</p>
<p>SIGXFSZ：如果进程超过了其软文件长度限制，则SVR4和4.3+BSD产生此信号。</p>
<p><strong> Core_pattern的格式</strong></p>
<p>可以在core_pattern模板中使用变量还很多，见下面的列表：</p>
<p>%% 单个%字符</p>
<p>%p 所dump进程的进程ID</p>
<p>%u 所dump进程的实际用户ID</p>
<p>%g 所dump进程的实际组ID</p>
<p>%s 导致本次core dump的信号</p>
<p>%t core dump的时间 (由1970年1月1日计起的秒数)</p>
<p>%h 主机名</p>
<p>%e 程序文件名</p>
<h3 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h3><p><a href="https://zhuanlan.zhihu.com/p/46605905">gdb调试coredump（使用篇）</a></p>
<p><a href="https://blog.csdn.net/newnewman80/article/details/8173770">coredump简介与coredump原因总结</a></p>
<p><a href="https://blog.csdn.net/K346K346/article/details/48344263">Linux 下使用 gdb 调试 core 文件</a></p>
<p><a href="https://blog.csdn.net/bit_clearoff/article/details/53965514">Linux的gcc和g++的区别</a></p>
<p><a href="https://www.cnblogs.com/lidan/archive/2011/05/25/2239517.html">g++参数介绍</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>判断一个序列是否是堆</title>
    <url>/2020/05/12/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%BA%8F%E5%88%97%E6%98%AF%E5%90%A6%E6%98%AF%E5%A0%86/</url>
    <content><![CDATA[<p>已知一个序列，比如{100,6070,50,32,65}，怎么判断是不是堆？</p>
<p>答案：把这个序列看成数组型的二叉树，如果根结点是i，左子树是2*i，右子树是2*i+1。<br><span id="more"></span><br>堆分为最大堆与最小堆。</p>
<ol>
<li>最大堆中所有父节点都比左子树、右子树大，比如已知序列，画成堆就是：</li>
</ol>
<p><img src="/2020/05/12/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%BA%8F%E5%88%97%E6%98%AF%E5%90%A6%E6%98%AF%E5%A0%86/1.jpeg" alt></p>
<p>所以已知序列是个最大堆。</p>
<ol>
<li>最小堆中所有父节点都比左子树、右子树小，比如{32,50,60,70,100,65},画成堆：</li>
</ol>
<p><img src="/2020/05/12/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%BA%8F%E5%88%97%E6%98%AF%E5%90%A6%E6%98%AF%E5%A0%86/2.jpeg" alt></p>
<p>符合以上两种情况的序列就是堆</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Github分支备份Hexo博客源文件</title>
    <url>/2020/03/21/%E5%88%A9%E7%94%A8Github%E5%88%86%E6%94%AF%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>Hexo 部署博客很方便，我的这个博客也是用 Hexo 部署在 GitHub Pages 上的，有得人可能在多台电脑上写博客，这个时候需要把博客的源文件备份在一个地方，这样只需把博客源文件复制下来就可以在另一个地方写博客并部署到 GitHub Pages上了<br><span id="more"></span><br>本篇介绍的就是利用博客的 repo 分支（ master 分支的必须用来存放你博客网站文件）托管 Hexo 源文件和配置达到备份的目的，下面开始正题</p>
<h4 id="把博客目录的源文件push到repo分支上"><a href="#把博客目录的源文件push到repo分支上" class="headerlink" title="把博客目录的源文件push到repo分支上"></a>把博客目录的源文件push到repo分支上</h4><p>cd 进入博客目录，Git 初始化：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></p>
<p>完成之后，添加修改的文件，Hexo 就自带了 .gitignore 文件需要忽略的文件 都已经默认配置好了，add 全部文件：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><br>然后commit：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;commit first time&quot;</span><br></pre></td></tr></table></figure><br>提交成功之后，接下来就是 push 到github了，需要先把这 Hexo 源文件映射到远程 repo 上：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/your-name/your-name.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>接下来就是把Hexo源文件 push 上去，但是关键的地方到了，master上是 Hexo 生成博客网页的代码，而我们 Hexo 源文件是要 push 到一个分支上面的，所以接下来先要在 repo 上新建一个分支</p>
<p>新建一个叫做blogSource的分支(注意：分支名要和本地hexo项目名一致，不然push会出错)：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch blogSource</span><br></pre></td></tr></table></figure></p>
<p>查看本地分支，并且切换到 blogSource 分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git checkout blogSource</span><br></pre></td></tr></table></figure>
<p>然后拉取远程代码，再把刚才添加的 Hexo 源文件代码 push 到blogSource这个分支：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br><span class="line">git push -u origin blogSource</span><br></pre></td></tr></table></figure><br>然后就可以在 repo 上看到分支里面已经有博客的源文件了</p>
<h4 id="日常更新博客源文件"><a href="#日常更新博客源文件" class="headerlink" title="日常更新博客源文件"></a>日常更新博客源文件</h4><p>以后你本地的博客源文件的修改就可以直接用 git 命令 push 到 repo 的 blogSource 分支上了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .  //添加修改内容到本地仓储</span><br><span class="line">git commit -m &#x27;modify blog&#x27;  //提交修改内容到本地仓库</span><br><span class="line">git push --set-upstream origin blogSource  //配置push，以方便后期直接git push推送</span><br><span class="line">git push  //将本地分支和分支下的内容推送到远程</span><br></pre></td></tr></table></figure>
<p>注意：执行 git push —set-upstream origin blogSource 命令之后，以后修改博客源文件代码之后，直接使用 git push 不用再指定分支，就可以把代码 push 到 blogSource 分支上了</p>
<h4 id="更换地点使用-repo-分支上的博客源文件"><a href="#更换地点使用-repo-分支上的博客源文件" class="headerlink" title="更换地点使用 repo 分支上的博客源文件"></a>更换地点使用 repo 分支上的博客源文件</h4><p>换一台电脑，配置好 Hexo 的环境，<a href="https://xiaovv.me/2017/04/06/GitHub%E9%85%8D%E7%BD%AESSH-key/">配置 Git SSH key</a>，把博客源文件代码克隆下来:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone xxxxxxxxx.xx (你的 github page 的 repo 地址)</span><br></pre></td></tr></table></figure></p>
<p>博客源文件下载下来之后，默认的分支是 master，需要切换到 blogSource 分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout origin/blogSource</span><br></pre></td></tr></table></figure>
<p>然后cd到博客目录依次执行以下命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><br>接下来就可以开始愉快的写博客了，写完之后记得把源文件代码 push 到 Github 上，然后用 Hexo 部署到自己博客上面</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（一）：赋值运算符函数</title>
    <url>/2023/09/16/%E5%89%91%E6%8C%87offer%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p>如下为类型CMyString的声明。请为该类型添加赋值运算符函数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMyString</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">// 构造函数</span></span><br><span class="line">     <span class="built_in">CMyString</span>(<span class="type">char</span>*pData = <span class="literal">nullptr</span>);</span><br><span class="line">     <span class="comment">// 拷贝构造函数 (用来初始化对象)；</span></span><br><span class="line">     <span class="built_in">CMyString</span>(<span class="type">const</span> CMyString &amp; str);</span><br><span class="line">     <span class="comment">// 析构函数</span></span><br><span class="line">     ~<span class="built_in">CMyString</span>(<span class="type">void</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="type">char</span>* m_pData;</span><br><span class="line">};</span><br></pre></td></tr></table></figure><br><span id="more"></span></p>
<h1 id="本题考点："><a href="#本题考点：" class="headerlink" title="本题考点："></a>本题考点：</h1><p>  1). C++基础语法的理解，如运算符函数、常量引用等。</p>
<p>  2). 对内存泄漏的理解</p>
<p>  3). 代码异常安全性的理解</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h1><p><strong>考虑因素：</strong></p>
<p>  1). 返回值的类型应该声明为该类型的引用，并在函数结束前返回实例自身的引用(*this)，因为只有返回一个引用时才可以允许被连续赋值；</p>
<p>  2). 把传入的参数类型声明为常量引用(注意：拷贝构造函数一定要为<strong>常量引用</strong>，如果不是引用而是实例，则会从形参到实参再回调用一次拷贝构造函数，造成<strong>无限调用</strong>)；</p>
<p>  3). 注意释放实例自身已有的内存；</p>
<p>  4). 判断传入的参数和当前的实例(*this)是不是同一个实例则不需要进行赋值操作，直接返回。如果事先不判断就赋值，那么在释放实例自身内存时，之后再赋值就会找不到赋值的内容。</p>
<p><strong>进一步思考</strong></p>
<p>  1). 其实就是一个构造函数，不过形参是该类型本身。</p>
<p>  2). 形参为const的引用，因为拷贝不影响原变量。如果不使用引用会无限循环调用构造函数。</p>
<p>  3). 在给新建变量赋值时会引用。而赋值运算符用在给已存在变量赋值的情况。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/bryceustc/CodingInterviews/blob/master/CMyString/CMyString.cpp">C++</a></p>
<h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CMyString.h文件中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INC_1_CMYSTRING_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INC_1_CMYSTRING_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyString</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyString</span>(<span class="type">char</span> *pData = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">CMyString</span>(<span class="type">const</span> CMyString &amp;);</span><br><span class="line">    ~<span class="built_in">CMyString</span>();</span><br><span class="line">    CMyString &amp;<span class="keyword">operator</span> = (<span class="type">const</span> CMyString &amp;str);</span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *m_pData;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">CMyString::<span class="built_in">CMyString</span>(<span class="type">char</span> *pData){</span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">CMyString::~<span class="built_in">CMyString</span>() {</span><br><span class="line">    <span class="keyword">if</span> (m_pData) {</span><br><span class="line">        <span class="keyword">delete</span>[] m_pData;</span><br><span class="line">        m_pData = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line">CMyString::<span class="built_in">CMyString</span>(<span class="type">const</span> CMyString &amp;str) {</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"这是拷贝构造函数！"</span> &lt;&lt; std::endl;</span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值运算符函数</span></span><br><span class="line">CMyString &amp;CMyString::<span class="keyword">operator</span>=(<span class="type">const</span> CMyString &amp;str) {</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"这是拷贝赋值运算符！"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">        <span class="comment">//检查自赋值的情况</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放原本的内存</span></span><br><span class="line">    <span class="keyword">if</span> (m_pData) {</span><br><span class="line">        <span class="keyword">delete</span>[] m_pData;</span><br><span class="line">        m_pData = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的内存资源</span></span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回本对象的引用</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">CMyString::getData</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> m_pData;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//INC_1_CMYSTRING_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CMyString.cpp文件中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"CMyString.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> *temp = <span class="string">"Hello World"</span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">myStr</span><span class="params">(temp)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"myStr: "</span> &lt;&lt; myStr.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    CMyString test = myStr;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"test: "</span> &lt;&lt; test.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *temp2 = <span class="string">"show the difference."</span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">myStr2</span><span class="params">(temp2)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"myStr2: "</span> &lt;&lt; myStr2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    myStr2 = test;</span><br><span class="line">    cout &lt;&lt; <span class="string">"myStr2 after operator \"=\": "</span> &lt;&lt; myStr2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp中的测试程序</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"CMyString.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> *temp = <span class="string">"Hello World"</span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">myStr</span><span class="params">(temp)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"myStr: "</span> &lt;&lt; myStr.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    CMyString test = myStr; <span class="comment">// 类似 CMyString test(myStr)这种的浅拷贝</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"test: "</span> &lt;&lt; test.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *temp2 = <span class="string">"show the difference."</span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">myStr2</span><span class="params">(temp2)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"myStr2: "</span> &lt;&lt; myStr2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    myStr2 = test;</span><br><span class="line">    cout &lt;&lt; <span class="string">"myStr2 after operator \"=\": "</span> &lt;&lt; myStr2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">myStr: Hello World</span><br><span class="line">这是拷贝构造函数！</span><br><span class="line">test: Hello World</span><br><span class="line">myStr2: show the difference.</span><br><span class="line">这是拷贝赋值运算符！</span><br><span class="line">myStr2 after operator "=": Hello World</span><br></pre></td></tr></table></figure>
<h2 id="更完善版本：考虑new分配空间是否足够，内存不足时，直接new会抛出异常，"><a href="#更完善版本：考虑new分配空间是否足够，内存不足时，直接new会抛出异常，" class="headerlink" title="更完善版本：考虑new分配空间是否足够，内存不足时，直接new会抛出异常，"></a>更完善版本：考虑new分配空间是否足够，内存不足时，直接new会抛出异常，</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CMyString &amp;CMyString::<span class="keyword">operator</span>=(<span class="type">const</span> CMyString &amp;str) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) {</span><br><span class="line">        <span class="comment">//调用拷贝构造函数，构造临时变量</span></span><br><span class="line">        CMyString <span class="built_in">strTmp</span>(str);</span><br><span class="line">        <span class="comment">// 交换当前对象与临时对象的数据。</span></span><br><span class="line">        <span class="type">char</span> *pTmp = strTmp.m_pData;</span><br><span class="line">        strTmp.m_pData = m_pData;</span><br><span class="line">        m_pData = pTmp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><p><a href="https://www.runoob.com/cplusplus/assignment-operators-overloading.html">赋值运算符</a>:就像其他运算符一样，可以重载赋值运算符（ = ），用于创建一个对象，比如拷贝构造函数。</p>
</li>
<li><p><a href="https://www.runoob.com/cplusplus/cpp-this-pointer.html">this指针</a>:在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p>
</li>
<li><p><a href="https://www.runoob.com/cplusplus/cpp-constructor-destructor.html">构造函数</a>:类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>
</li>
<li><p><a href="https://www.runoob.com/cplusplus/cpp-constructor-destructor.html">析构函数</a>:类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。<strong>析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源</strong>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>利用scp 远程上传下载文件/文件夹</title>
    <url>/2020/06/21/%E5%88%A9%E7%94%A8scp-%E8%BF%9C%E7%A8%8B%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<p>学习工作中经常会用到scp远程下载或者传输文件/文件夹，记录一下具体的操作。</p>
<p>1、从服务器下载文件<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp username@servername:/path/filename /tmp/local_destination</span><br></pre></td></tr></table></figure></p>
<p>例如：把192.168.0.101上的/home/kimi/test.txt的文件下载到 /tmp/local_destination</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp codinglog@192.168.0.101:/home/kimi/test.txt </span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>2、上传本地文件到服务器<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp /path/local_filename username@servername:/path  </span><br></pre></td></tr></table></figure></p>
<p>例如：把本机/var/www/目录下的test.php文件上传到192.168.0.101这台服务器上的/var/www/目录中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp /var/www/test.php  codinglog@192.168.0.101:/var/www/ </span><br></pre></td></tr></table></figure>
<p>3、从服务器下载整个目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r username@servername:remote_dir/ /tmp/local_dir </span><br></pre></td></tr></table></figure>
<p>例如:把服务器下的test目录下载到本地的/tmp/local_dir目录<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r codinglog@192.168.0.101 /home/kimi/test  /tmp/local_dir</span><br></pre></td></tr></table></figure></p>
<p>4、上传目录到服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp  -r /tmp/local_dir username@servername:remote_dir</span><br></pre></td></tr></table></figure>
<p>例如：把当前目录下的test目录上传到服务器 的/var/www/ 目录<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r test      codinglog@192.168.0.101:/var/www/ </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（七）：重建二叉树</title>
    <url>/2023/09/20/%E5%89%91%E6%8C%87offer%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><span id="more"></span></p>
<h1 id="本题考点："><a href="#本题考点：" class="headerlink" title="本题考点："></a>本题考点：</h1><p>  1). 二叉树的三种遍历（前序遍历(DLR)，中序遍历(LDR)，后序遍历(LRD)）实现。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h1><p>  此题与LeetCode-105题一样，与106题从中序与后序遍历序列构造二叉树思路类似。</p>
<p>  理解二叉树以及三种遍历的概念。<a href="https://www.jianshu.com/p/acb33735b933">二叉树 - 前序遍历、中序遍历、后序遍历</a></p>
<p>  注意前序遍历中的第一个数字是根节点的值，在中序遍历中根节点的值在序列中间，左子树的节点的值在根节点的值的左边，而右子树的节点的值位于根节点的右边，所以先扫描中序遍历，找到根节点所在位置，然后找到左子树和右子树的前序遍历和中序遍历即可。如图所示：</p>
   <img src="/2023/09/20/%E5%89%91%E6%8C%87offer%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/09/20/%E5%89%91%E6%8C%87offer%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/1.jpg" class>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pre,vector&lt;<span class="type">int</span>&gt; vin)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (pre.<span class="built_in">empty</span>() || vin.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> n = pre.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 前序遍历的第一个数字是根节点的值</span></span><br><span class="line">        <span class="type">int</span> root = pre[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 创建根节点</span></span><br><span class="line">        TreeNode* t = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root);</span><br><span class="line">        <span class="comment">// 找到root所在的位置，确定好前序和中序中左子树和右子树序列的范围</span></span><br><span class="line">        <span class="type">int</span> root_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (vin[i] == root) {</span><br><span class="line">                root_index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 左子树</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left_pre,left_in, right_pre, right_in;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; root_index; i++) {</span><br><span class="line">            left_pre.<span class="built_in">push_back</span>(pre[i+<span class="number">1</span>]); <span class="comment">// +1 是因为前序遍历的第一个节点是根节点</span></span><br><span class="line">            left_in.<span class="built_in">push_back</span>(vin[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 右子树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=root_index+<span class="number">1</span>;i&lt;n;i++) {</span><br><span class="line">            right_pre.<span class="built_in">push_back</span>(pre[i]);</span><br><span class="line">            right_in.<span class="built_in">push_back</span>(vin[i]);</span><br><span class="line">        }</span><br><span class="line">        t-&gt;left = <span class="built_in">reConstructBinaryTree</span>(left_pre,left_in);</span><br><span class="line">        t-&gt;right = <span class="built_in">reConstructBinaryTree</span>(right_pre,right_in);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reConstructBinaryTree</span>(<span class="params">self, pre, tin</span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(pre.pop(<span class="number">0</span>))</span><br><span class="line">        index = tin.index(root.val)</span><br><span class="line">        root.left = self.reConstructBinaryTree(pre, tin[:index])</span><br><span class="line">        root.right = self.reConstructBinaryTree(pre, tin[index + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><p><a href="https://github.com/bryceustc/LeetCode_Note/blob/master/cpp/Construct-Binary-Tree-From-Preorder-And-Inorder-Traversal/README.md">LeetCode-105-从前序与中序遍历序列构造二叉树</a></p>
</li>
<li><p><a href="https://github.com/bryceustc/LeetCode_Note/blob/master/cpp/Construct-Binary-Tree-From-Ineorder-And-Postorder-Traversal/README.md">LeetCode-106-从中序与后序遍历序列构造二叉树</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（三）：数组中重复的数字</title>
    <url>/2023/09/16/%E5%89%91%E6%8C%87offer%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p>在一个长度为n的数组里的所有数字都在0~n-1范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。<br>请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2，3，1，0，2，5，3}，那么对应的输出是重复的数字2或者3<br><span id="more"></span></p>
<h1 id="本题考点："><a href="#本题考点：" class="headerlink" title="本题考点："></a>本题考点：</h1><p>  1). 一维数组的理解，一维数组在内存中占据连续空间，可以根据下标定位对应的元素</p>
<p>  2). 二分查找算法的理解，快速正确实现二分查找</p>
<p>  3). 时间复杂度与空间复杂度的理解</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h1><p>  1). 把输入的数组进行排序，排序后再判断有无重复数字，时间复杂度为O(nlogn)</p>
<p>  2). 使用哈希表来解决，时间复杂度为O(n)，但空间复杂度也为O(n)</p>
<p>  3). <strong>交换位置重排法</strong>，把每个数字放回对应位置的方法。如果出现一个数字无法放回（所在位置已经是对应数字了），那么说明该数字重复，<strong>时间复杂度为O(n)，空间复杂度为O(1)</strong></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/bryceustc/CodingInterviews/blob/master/DuplicationInArray/DuplicationInArray.cpp">C++</a></p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="方法一：排序后直接查找"><a href="#方法一：排序后直接查找" class="headerlink" title="方法一：排序后直接查找"></a>方法一：排序后直接查找</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">Duplication1</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums,<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>{</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()||n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> || nums[i] &gt; n - <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());<span class="function">tem</span></span><br><span class="line"><span class="function">            <span class="title">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span></span></span><br><span class="line"><span class="function">            </span>{</span><br><span class="line">                <span class="keyword">if</span> (nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                {</span><br><span class="line">                    res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="方法二：利用哈希表"><a href="#方法二：利用哈希表" class="headerlink" title="方法二：利用哈希表"></a>方法二：利用哈希表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">Duplication2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums,<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>{</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums.<span class="built_in">empty</span>() || n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> || nums[i] &gt; n<span class="number">-1</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                } </span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</span><br><span class="line">            {</span><br><span class="line">                m[i]++;</span><br><span class="line">                <span class="keyword">if</span>(m[i]&gt;<span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="方法三：交换位置重排"><a href="#方法三：交换位置重排" class="headerlink" title="方法三：交换位置重排"></a>方法三：交换位置重排</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="comment">//只要当前数值与索引不等，就要一直替换</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) {</span><br><span class="line">                <span class="comment">//一旦遇到当前的数值与另外一个换位的值相等，就停止，说明找到了重复的数字</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) {</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                }</span><br><span class="line">                <span class="type">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[temp];</span><br><span class="line">                nums[temp] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><p><a href="https://blog.csdn.net/hunanchenxingyu/article/details/8101795">循环结构中break、continue、return和exit的区别</a></p>
</li>
<li><p><a href="https://blog.csdn.net/zolalad/article/details/11848739">时间复杂度和空间复杂度</a></p>
</li>
<li><a href="https://github.com/bryceustc/LeetCode_Note/blob/master/cpp/Find-First-And-Last-Position-Of-Element-In-Sorted-Array/BinarySearch.md">二分查找算法</a></li>
</ul>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（九）：用两个栈实现队列</title>
    <url>/2023/09/26/%E5%89%91%E6%8C%87offer%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。理解题意就是利用两个先进后出的栈实现一个先进先出的队列<br><span id="more"></span></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h1><p>   理解题意后是要用两个“先进后出”的栈实现一个“先进先出”的队列，先将元素填进stack1，stack1.push(node)，然后stack2为空，但stack1不为空，就将stack1的元素弹出，再压入栈2，这样先进的元素就在栈2顶，这样就实现了先进先出。就是先进后出+后进先出=先进先出。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="C"><a href="#C" class="headerlink" title="C++:"></a>C++:</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">peek</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 注意要加这个判断，因为有可能先加进去3个元素，只弹出一个</span></span><br><span class="line">        <span class="comment">// 后边再加元素，剩下的两个元素优先级还是最高</span></span><br><span class="line">        <span class="keyword">if</span> (s2.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>()) {</span><br><span class="line">                s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!s2.<span class="built_in">empty</span>()) <span class="keyword">return</span> s2.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>() &amp;&amp; s2.<span class="built_in">empty</span>();</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.s1, self.s2 = [], []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.s1.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        peek = self.peek()</span><br><span class="line">        self.s2.pop()</span><br><span class="line">        <span class="keyword">return</span> peek</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.s2: </span><br><span class="line">            <span class="keyword">while</span> self.s1:</span><br><span class="line">                self.s2.append(self.s1.pop())</span><br><span class="line">        <span class="keyword">if</span> self.s2:</span><br><span class="line">            <span class="keyword">return</span> self.s2[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">not</span> self.s1) <span class="keyword">and</span> (<span class="keyword">not</span> self.s2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/l494926429/article/details/52066918">C++ stl容器stack栈pop用法</a></li>
<li><a href="https://www.runoob.com/python/att-list-pop.html">Python list pop()用法</a></li>
<li><a href="https://www.jianshu.com/p/1327cc0de255">Python栈实现</a></li>
</ul>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（二）：实现Singleton模式</title>
    <url>/2023/09/16/%E5%89%91%E6%8C%87offer%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p>设计一个类，我们只能生成该类的一个实例</p>
<h1 id="本题考点："><a href="#本题考点：" class="headerlink" title="本题考点："></a>本题考点：</h1><p>  1). 考察对单例的(Singleton)模式的理解。</p>
<p>  2). 基础语法的理解，如静态构造函数</p>
<p>  3). 多线程编程的理解</p>
<span id="more"></span>
<h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>书中本节的代码是采用C#编写的，这里用C++实现。</p>
<h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><h2 id="方法一：单线程解法"><a href="#方法一：单线程解法" class="headerlink" title="方法一：单线程解法"></a>方法一：单线程解法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)<span class="comment">//第一次调用要判断指针是否为空</span></span><br><span class="line">            {</span><br><span class="line">                p_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">Singleton</span>(){}; <span class="comment">//构造函数设计成私有的</span></span><br><span class="line">        <span class="type">static</span> Singleton *p_instance; <span class="comment">//用类的指针指向唯一的实例</span></span><br><span class="line">};</span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//静态数据成员是静态存储的，必须对他进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Singleton *object = Singleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="方法二：多线程-加锁"><a href="#方法二：多线程-加锁" class="headerlink" title="方法二：多线程+加锁"></a>方法二：多线程+加锁</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉模式：Singleton在程序第一次调用的时候才会初始化自己</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="comment">//  这里使用了两个 if判断语句的技术称为双检锁；好处是，只有判断指针为空的时候才加锁，</span></span><br><span class="line">            <span class="comment">//  避免每次调用 GetInstance的方法都加锁，锁的开销毕竟还是有点大的。</span></span><br><span class="line">            <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                mtx.<span class="built_in">lock</span>(); <span class="comment">// 使用C++11中的多线程库</span></span><br><span class="line">                <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)</span><br><span class="line">                {</span><br><span class="line">                    p_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">                }</span><br><span class="line">                mtx.<span class="built_in">unlock</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> Singleton *p_instance; <span class="comment">//用类的指针指向唯一的实例</span></span><br><span class="line">        <span class="comment">// 将其构造和析构成为私有的, 禁止外部构造和析构</span></span><br><span class="line">        <span class="built_in">Singleton</span>();</span><br><span class="line">        ~<span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="comment">// 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值</span></span><br><span class="line">        <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;signal);</span><br><span class="line">        <span class="type">const</span> Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;signal);</span><br><span class="line">};</span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//静态数据成员是静态存储的，必须对他进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> Singleton *p_instance; <span class="comment">//用类的指针指向唯一的实例</span></span><br><span class="line">        <span class="comment">// 将其构造和析构成为私有的, 禁止外部构造和析构</span></span><br><span class="line">        <span class="built_in">Singleton</span>();</span><br><span class="line">        ~<span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="comment">// 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值</span></span><br><span class="line">        <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;signal);</span><br><span class="line">        <span class="type">const</span> Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;signal);</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 代码一运行就初始化创建实例 ，本身就线程安全</span></span><br><span class="line">Singleton* Singleton::p_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Singleton *object = Singleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="方法三：const-实例"><a href="#方法三：const-实例" class="headerlink" title="方法三：const + 实例"></a>方法三：const + 实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">Singleton</span>(){}</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> Singleton* m_pInstance;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;Singleton*&gt;(m_pInstance); <span class="comment">// 去掉“const”特性</span></span><br><span class="line">            <span class="comment">// 注意！若该函数的返回值改为const static型，则此处不必进行const_cast静态转换</span></span><br><span class="line">            <span class="comment">// 所以该函数可以改为：</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            const static Singleton* getInstance(){</span></span><br><span class="line"><span class="comment">                return m_pInstance;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroyInstance</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">if</span>(m_pInstance != <span class="literal">NULL</span>){</span><br><span class="line">                <span class="keyword">delete</span> m_pInstance;</span><br><span class="line">                m_pInstance = <span class="literal">NULL</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="type">const</span> Singleton* Singleton::m_pInstance = <span class="keyword">new</span> <span class="built_in">Singleton</span>(); <span class="comment">// 利用const只能定义一次，不能再次修改的特性，static继续保持类内只有一个实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_singleton_instance</span><span class="params">()</span></span>{</span><br><span class="line">        Singleton *singletonObj = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">        cout &lt;&lt; singletonObj &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多个进程获得单例</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// 预期结果，打印出相同的地址，之间可能缺失换行符，也属正常现象</span></span><br><span class="line">        vector&lt;thread&gt; threads;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i){</span><br><span class="line">            threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(print_singleton_instance));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thr : threads){</span><br><span class="line">            thr.<span class="built_in">join</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="built_in">Test1</span>();</span><br><span class="line">        Singleton::<span class="built_in">destroyInstance</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*因为静态初始化在程序开始时，也就是进入主函数之前，由主线程以单线程方式完成了初始化，所以静态初始化实例保证了线程安全性。在性能要求比较高时，就可以使用这种方式，从而避免频繁的加锁和解锁造成的资源浪费。由于上述三种实现，都要考虑到实例的销毁，关于实例的销毁，待会在分析。*</span></span><br></pre></td></tr></table></figure>
<h2 id="方法四：在get函数中创建并返回static临时实例的引用"><a href="#方法四：在get函数中创建并返回static临时实例的引用" class="headerlink" title="方法四：在get函数中创建并返回static临时实例的引用"></a>方法四：在get函数中创建并返回static临时实例的引用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(){}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="type">static</span> Singleton m_pInstance; <span class="comment">// 注意，声明在该函数内</span></span><br><span class="line">        <span class="keyword">return</span> &amp;m_pInstance;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_singleton_instance</span><span class="params">()</span></span>{</span><br><span class="line">    Singleton *singletonObj = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; singletonObj &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个进程获得单例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// 预期结果，打印出相同的地址，之间可能缺失换行符，也属正常现象</span></span><br><span class="line">    vector&lt;thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i){</span><br><span class="line">        threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(print_singleton_instance));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thr : threads){</span><br><span class="line">        thr.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个进程获得多次实例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// 预期结果，打印出相同的地址，之间换行符分隔</span></span><br><span class="line">    <span class="built_in">print_singleton_instance</span>();</span><br><span class="line">    <span class="built_in">print_singleton_instance</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Test1 begins: "</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Test1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"Test2 begins: "</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Test2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="方法五：-最终方案，最简-amp-显式控制实例销毁"><a href="#方法五：-最终方案，最简-amp-显式控制实例销毁" class="headerlink" title="方法五： 最终方案，最简&显式控制实例销毁"></a>方法五： 最终方案，最简&amp;显式控制实例销毁</h2><p>在上述的四种方法中，除了第四种没有使用new操作符实例化对象以外，其余三种都使用了；</p>
<p>​ 我们一般的编程观念是，new操作是需要和delete操作进行匹配的；是的，这种观念是正确的。在上述的实现中，是添加了一个destoryInstance的static函数，这也是最简单，最普通的处理方法了；但是，很多时候，我们是很容易忘记调用destoryInstance函数，就像你忘记了调用delete操作一样。由于怕忘记delete操作，所以就有了智能指针；那么，在单例模型中，没有“智能单例”，该怎么办？</p>
<p>​ 在实际项目中，特别是客户端开发，其实是不在乎这个实例的销毁的。因为，全局就这么一个变量，全局都要用，它的生命周期伴随着软件的生命周期，软件结束了，它也就自然而然的结束了，因为一个程序关闭之后，它会释放它占用的内存资源的，所以，也就没有所谓的内存泄漏了。</p>
<p>​但是，有以下情况，是必须需要进行实例销毁的：在类中，有一些文件锁了，文件句柄，数据库连接等等，这些随着程序的关闭而不会立即关闭的资源，必须要在程序关闭前，进行手动释放；</p>
<p>​ 在代码实现部分的第四种方法能满足第二个条件，但是无法满足第一个条件。好了，接下来，就介绍一种方法，这种方法也是我从网上学习而来的，代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(){}</span><br><span class="line">    <span class="type">static</span> Singleton* m_pInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// **重点在这**</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">GC</span> <span class="comment">// 类似Java的垃圾回收器</span></span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">GC</span>(){</span><br><span class="line">            <span class="comment">// 可以在这里释放所有想要释放的资源，比如数据库连接，文件句柄……等等。</span></span><br><span class="line">            <span class="keyword">if</span>(m_pInstance != <span class="literal">NULL</span>){</span><br><span class="line">                cout &lt;&lt; <span class="string">"GC: will delete resource !"</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">delete</span> m_pInstance;</span><br><span class="line">                m_pInstance = <span class="literal">NULL</span>;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类的实例</span></span><br><span class="line">    <span class="type">static</span> GC gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_pInstance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">Singleton::GC Singleton::gc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_instance</span><span class="params">()</span></span>{</span><br><span class="line">    Singleton* obj1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; obj1 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多线程获取单例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// 预期输出：相同的地址，中间可能缺失换行符，属于正常现象</span></span><br><span class="line">    vector&lt;thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i){</span><br><span class="line">        threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(print_instance));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thr : threads){</span><br><span class="line">        thr.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单线程获取单例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// 预期输出：相同的地址，换行符分隔</span></span><br><span class="line">    <span class="built_in">print_instance</span>();</span><br><span class="line">    <span class="built_in">print_instance</span>();</span><br><span class="line">    <span class="built_in">print_instance</span>();</span><br><span class="line">    <span class="built_in">print_instance</span>();</span><br><span class="line">    <span class="built_in">print_instance</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Test1 begins: "</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"预期输出：相同的地址，中间可以缺失换行（每次运行结果的排列格式通常不一样）。"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Test1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"Test2 begins: "</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"预期输出：相同的地址，每行一个。"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Test2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在程序运行结束时，系统会调用Singleton的静态成员GC的析构函数，该析构函数会进行资源的释放，而这种资源的释放方式是在程序员“不知道”的情况下进行的，而程序员不用特别的去关心，使用单例模式的代码时，不必关心资源的释放。</p>
<p>​ 那么这种实现方式的原理是什么呢？由于程序在结束的时候，系统会自动析构所有的全局变量，系统也会析构所有类的静态成员变量，因为静态变量和全局变量在内存中，都是存储在静态存储区的，所有静态存储区的变量都会被释放。</p>
<h3 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h3><p><a href="https://blog.csdn.net/huhaijing/article/details/51756225">Singleton模式 C++实现</a></p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（十一）：旋转数组的最小数字</title>
    <url>/2023/10/07/%E5%89%91%E6%8C%87offer%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><span id="more"></span></p>
<h1 id="本题考点："><a href="#本题考点：" class="headerlink" title="本题考点："></a>本题考点：</h1><p>  1). 数组非减排序</p>
<p>  2). 二分查找</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h1><p>  1). 直接暴力遍历数组所有元素，寻找最小元素，时间复杂度为O(n)</p>
<p>  2). 使用二分查找，时间复杂度为O(log<sub>2</sub>n)</p>
<p>  用二分法查找，需要始终将目标值（这里是最小值）套住，并不断收缩左边界或右边界。左、中、右三个位置的值相比较，有以下几种情况：</p>
<p>  a. 左值 &lt; 中值, 中值 &lt; 右值 ：没有旋转，最小值在最左边，可以<strong>收缩右边界</strong></p>
<pre><code>        右
    中
左
</code></pre><p>  b. 左值 &gt; 中值, 中值 &lt; 右值 ：有旋转，最小值在左半边，可以<strong>收缩右边界</strong></p>
<pre><code>左       右
    中  
</code></pre><p>  c. 左值 &lt; 中值, 中值 &gt; 右值 ：有旋转，最小值在右半边，可以<strong>收缩左边界</strong></p>
<pre><code>    中
左      右
</code></pre><p>  d. 左值 &gt; 中值, 中值 &gt; 右值 ：单调递减，不可能出现</p>
<pre><code>右        
    中
        左
</code></pre><p>分析前面三种可能的情况，会发现情况1、2是一类，情况3是另一类。</p>
<p>如果中值 &lt; 右值，则最小值在左半边，可以收缩右边界。 </p>
<p>如果中值 &gt; 右值，则最小值在右半边，可以收缩左边界。 </p>
<p>通过比较中值与右值，可以确定最小值的位置范围，从而决定边界收缩的方向。</p>
<p>而情况1与情况3都是左值 &lt; 中值，但是最小值位置范围却不同，这说明，如果只比较左值与中值，不能确定最小值的位置范围。</p>
<p>所以我们需要通过<strong>比较中值与右值来确定最小值的位置范围</strong>，进而确定边界收缩的方向。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="C"><a href="#C" class="headerlink" title="C++:"></a>C++:</h2><h3 id="方法一：暴力遍历"><a href="#方法一：暴力遍历" class="headerlink" title="方法一：暴力遍历"></a>方法一：暴力遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();     </span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (res&gt;nums[i])</span><br><span class="line">                res = nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="方法二：二分查找："><a href="#方法二：二分查找：" class="headerlink" title="方法二：二分查找："></a>方法二：二分查找：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n = nums.<span class="built_in">size</span>();     </span><br><span class="line">            <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> end = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (end &gt; start) {</span><br><span class="line">                <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; nums[end]) { <span class="comment">/* 中值 &gt; 右值，最小值在右半边，收缩左边界 */</span> </span><br><span class="line">                    start = mid + <span class="number">1</span>; <span class="comment">/* 因为中值 &gt; 右值，中值肯定不是最小值，左边界可以跨过mid */</span> </span><br><span class="line">                } <span class="keyword">else</span> { <span class="comment">/* 明确中值 &lt; 右值，最小值在左半边，收缩右边界 */</span> </span><br><span class="line">                    end = mid; <span class="comment">/* 因为中值 &lt; 右值，中值也可能是最小值，右边界只能取到mid处 */</span> </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> nums[start]; <span class="comment">/* start == end，最小值输出nums[start]或nums[end]均可 */</span>   </span><br><span class="line">        }</span><br><span class="line">};</span><br><span class="line"><span class="comment">/* 包含重复元素的情况</span></span><br><span class="line"><span class="comment">class Solution {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int findMin(vector&lt;int&gt;&amp; nums) {</span></span><br><span class="line"><span class="comment">        if (nums.empty()) return 0;</span></span><br><span class="line"><span class="comment">        int n = nums.size();</span></span><br><span class="line"><span class="comment">        int start = 0;</span></span><br><span class="line"><span class="comment">        int end = n-1;</span></span><br><span class="line"><span class="comment">        while(end &gt; start)</span></span><br><span class="line"><span class="comment">        {</span></span><br><span class="line"><span class="comment">            int mid = start + (end-start)/2;</span></span><br><span class="line"><span class="comment">            if (nums[mid] &gt; nums[end]) {</span></span><br><span class="line"><span class="comment">                start = mid+1;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            else if (nums[mid] &lt; nums[end]) {</span></span><br><span class="line"><span class="comment">                end = mid;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            else {</span></span><br><span class="line"><span class="comment">                end--;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        return nums[start];</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h2><h3 id="方法一：暴力遍历："><a href="#方法一：暴力遍历：" class="headerlink" title="方法一：暴力遍历："></a>方法一：暴力遍历：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (n):</span><br><span class="line">            <span class="keyword">if</span> res &gt;nums[i]:</span><br><span class="line">                res = nums[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'_ main__'</span>:</span><br><span class="line">    nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">    res = Solution().findMin(nums)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h3 id="方法二：二分查找：-1"><a href="#方法二：二分查找：-1" class="headerlink" title="方法二：二分查找："></a>方法二：二分查找：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> end&gt;=start:</span><br><span class="line">            mid = start+(end-start)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;=res:</span><br><span class="line">                start=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;res:</span><br><span class="line">                end = mid-<span class="number">1</span></span><br><span class="line">            res = <span class="built_in">min</span>(res,nums[mid])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'_ main__'</span>:</span><br><span class="line">    nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">    res = Solution().findMin(nums)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><p><a href="https://github.com/bryceustc/LeetCode_Note/blob/master/cpp/Find-First-And-Last-Position-Of-Element-In-Sorted-Array/BinarySearch.md">二分查找算法</a></p>
</li>
<li><p><a href="https://github.com/bryceustc/LeetCode_Note/blob/master/cpp/Find-Minimum-In-Rotated-Sorted-Array/README.md">寻找旋转排序数组中的最小值</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（五）：替换空格</title>
    <url>/2023/09/18/%E5%89%91%E6%8C%87offer%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>在网络编程中，如果URL参数中含有特殊字符，如空格、’#’等，可能导致服务器端无法获得正确的参数值。我们需要将这些特殊符号转换成服务器可以识别的字符。转换的规则是在’%’后面跟上ASCII码的两位十六进制的表示。比如空格的ASCII码是32，即十六进制的0x20，因此空格被替换成”%20”。再比如’#’的ASCII码为35，即十六进制的0x23，它在URL中被替换为”%23”。<br><span id="more"></span></p>
<img src="/2023/09/18/%E5%89%91%E6%8C%87offer%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/09/18/%E5%89%91%E6%8C%87offer%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/1.jpg" class>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h1><ol>
<li><p>遍历添加法。<br> 新搞一个字符串res，从头到尾扫描字符串，每一次碰到空格字符的res添加字符串 “%20” ,否则添加字符。<br> <strong>时间复杂度</strong>: O(n), <strong>空间复杂度</strong>: O(n)</p>
</li>
<li><p>原地替换法<br> a. 先遍历一次字符串，这样就能统计出字符串中空格的总数，并可以由此计算出替换之后的字符串的总长度。<br> b. 从字符串的后面开始复制和替换。<br> <strong>时间复杂度</strong>: O(n), <strong>空间复杂度</strong>: O(1)</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="遍历添加法"><a href="#遍历添加法" class="headerlink" title="遍历添加法"></a>遍历添加法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>{     <span class="comment">//字符数组</span></span><br><span class="line">        string res;   <span class="comment">//存储结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s){   <span class="comment">//遍历原字符串</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">' '</span>){</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">'%'</span>);</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">'2'</span>);</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">'0'</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                res.<span class="built_in">push_back</span>(c);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="原地替换法"><a href="#原地替换法" class="headerlink" title="原地替换法"></a>原地替换法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) cnt++;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> len = (n + <span class="number">2</span> * cnt); <span class="comment">// 计算替换空格后的字符串的长度</span></span><br><span class="line">        s.<span class="built_in">resize</span>(len);</span><br><span class="line">        <span class="comment">// 当i &lt; j 时说明是还有空格的，跳出循环的条件是i==j;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>, j = len - <span class="number">1</span>; i &lt; j; i--, j--) {</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">' '</span>) {</span><br><span class="line">                s[j] = s[i];   </span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                s[j] = <span class="string">'0'</span>;</span><br><span class="line">                s[j<span class="number">-1</span>] = <span class="string">'2'</span>;</span><br><span class="line">                s[j<span class="number">-2</span>] = <span class="string">'%'</span>;</span><br><span class="line">                j-=<span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（八）：二叉树的下一个节点</title>
    <url>/2023/09/21/%E5%89%91%E6%8C%87offer%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br><span id="more"></span></p>
<h1 id="本题考点："><a href="#本题考点：" class="headerlink" title="本题考点："></a>本题考点：</h1><p>  二叉树的中序遍历(LDR)，以及分情况讨论。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h1><img src="/2023/09/21/%E5%89%91%E6%8C%87offer%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/09/21/%E5%89%91%E6%8C%87offer%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/1.png" class>
<p>上图二叉树的中序遍历是d,b,h,e,i,a,f,c,g。</p>
<p><strong>情况1:</strong> </p>
<p><strong>如果一个结点有右子树，那么它的下一个结点就是它的右子树的最左子结点</strong>。也就是说从右子结点出发一直沿着指向左子树结点的指针，我们就能找到它的下一个结点。例如，图中结点b的下一个结点是h，结点a的下一个结点是f。</p>
<p><strong>情况2:</strong></p>
<p>结点没有右子树的情形。<strong>如果结点是它父结点的左子结点，那么它的下一个结点就是它的父结点</strong>。例如，途中结点d的下一个结点是b，f的下一个结点是c。</p>
<p><strong>情况3:</strong></p>
<p>如果一个结点既没有右子树，并且它还是父结点的右子结点，这种情形就比较复杂。我们可以沿着指向父结点的指针一直向上遍历，<strong>直到找到第一个当前节点是其父节点左孩子的节点</strong>。例如，为了找到结点i的下一个结点，我们沿着指向父结点的指针向上遍历，先到达结点e。由于结点e是父结点b的右子结点，我们继续向上遍历到达结点b，b是父节点a的左子节点，所以节点a是i的下一节点。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeLinkNode {</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *right;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *next;</span></span><br><span class="line"><span class="comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* Node)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (Node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeLinkNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 当前结点有右子树，那么它的下一个结点就是它的右子树中最左子结点</span></span><br><span class="line">        <span class="keyword">if</span> (Node-&gt;right != <span class="literal">NULL</span>) {</span><br><span class="line">            TreeLinkNode* p = Node-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;left != <span class="literal">NULL</span>) {</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            }</span><br><span class="line">            res = p;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 当前结点无右子树，则找第一个当前节点是父节点左孩子的节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Node-&gt;next!=<span class="literal">NULL</span>) {</span><br><span class="line">            TreeLinkNode* p = Node;</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;next) { <span class="comment">//找第一个当前节点是父节点左孩子的节点，返回其父节点</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;next-&gt;left == p) <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">//退到了根节点仍没找到，则返回null</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeLinkNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetNext</span>(<span class="params">self, Node</span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> Node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> Node.right:</span><br><span class="line">            pRight = Node.right</span><br><span class="line">            <span class="keyword">while</span> pRight.left:</span><br><span class="line">                pRight = pRight.left</span><br><span class="line">            res = pRight</span><br><span class="line">        <span class="keyword">elif</span> Node.<span class="built_in">next</span>:</span><br><span class="line">            pCur = Node</span><br><span class="line">            pNext = Node.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> pNext <span class="keyword">and</span> pNext.right == pCur:</span><br><span class="line">                pCur = pNext</span><br><span class="line">                pNext = pNext.<span class="built_in">next</span></span><br><span class="line">            res = pNext</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.leetcodecn.com/pages/3fc857/#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5">二叉树的下一个节点</a></p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（六）：从尾到头打印链表</title>
    <url>/2023/09/19/%E5%89%91%E6%8C%87offer%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p>输入一个链表的头结点，从尾到头反过来打印出每个节点的值。链表节点定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) {}</span><br><span class="line">};</span><br></pre></td></tr></table></figure><br><span id="more"></span></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>此题与LeetCode-206题反转链表类似。</p>
<p>思路1：此题要求打印链表每个节点的值，由于不用考虑链表的生成（其实有点复杂），所以我们直接在函数中依次将链表中的节点值取出来，保存至一个容器（对于C++）或者列表（对于Python）中；然后再逆序打印这个容器或者列表即可。</p>
<p>思路2：思路1其实偷懒了，因为严格意义上来说，既然是对于链表来操作，那么其实返回结果其实也应该是链表，而不应该是简单的容器或者列表。按这样理解，我们其实应该直接对链表进行逆序打印，而不是转换成中间变量来操作。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="方法一：保存至容器，然后逆序打印"><a href="#方法一：保存至容器，然后逆序打印" class="headerlink" title="方法一：保存至容器，然后逆序打印"></a>方法一：保存至容器，然后逆序打印</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">if</span> (p==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            res.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 用c++自带的库函数reverse</span></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="方法二：原地反转链表-重要"><a href="#方法二：原地反转链表-重要" class="headerlink" title="方法二：原地反转链表(重要)"></a>方法二：原地反转链表(<strong>重要</strong>)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* temp = cur-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            temp = cur-&gt;next;<span class="comment">//temp作为中间节点，记录当前结点的下一个节点的位置</span></span><br><span class="line">            cur-&gt;next = prev;<span class="comment">//当前结点指向前一个节点</span></span><br><span class="line">            prev = cur;<span class="comment">//指针后移</span></span><br><span class="line">            cur = temp;<span class="comment">// 指针后移,处理下一个节点</span></span><br><span class="line">        }</span><br><span class="line">        ListNode* p = prev;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        {</span><br><span class="line">            res.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="方法一：保存为列表，然后逆序打印"><a href="#方法一：保存为列表，然后逆序打印" class="headerlink" title="方法一：保存为列表，然后逆序打印"></a>方法一：保存为列表，然后逆序打印</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            res.append(p.val)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="comment">## 列表反转的两种方法</span></span><br><span class="line">        res = res[::-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># res.reverse()</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="方法二：原地旋转链表-重要"><a href="#方法二：原地旋转链表-重要" class="headerlink" title="方法二：原地旋转链表(重要)"></a>方法二：原地旋转链表(<strong>重要</strong>)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        temp = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            temp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = temp</span><br><span class="line">        p = prev</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            res.append(p.val)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/bryceustc/LeetCode_Note/blob/master/cpp/Reverse-Linked-List/README.md">LeetCode-206-反转链表</a></li>
</ul>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（十二）：矩阵中的路径</title>
    <url>/2023/10/08/%E5%89%91%E6%8C%87offer%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”<strong>b</strong>“,”c”,”e”],<br>[“s”,”<strong>f</strong>“,”<strong>c</strong>“,”s”],<br>[“a”,”d”,”<strong>e</strong>“,”e”]]</p>
<span id="more"></span>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p><strong>示例：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h1><p>使用深度优先遍历DFS：</p>
<ol>
<li>遍历二维字符网格board，寻找和单词word第一个字母相同的字符，即board[i][j]==word[0]。</li>
<li>对于board[i][j]等于word第一个字母的情况，进行深度优先搜索，从当前字符board[i][j]出发，向上、下、左、右四个方向进行搜索。</li>
<li>在每个方向上，判断下一个字符是否等于word中的下一个字符，如果相等，则继续递归搜索，否则返回上一层。</li>
<li>如果搜索到word的最后一个字符，则说明存在这个单词，返回true；否则，返回false。<h1 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h1>O(n^2)<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1>O(n)</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (board.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> rows = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 初始化visited 数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span> (rows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;rows;i++) {</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;cols;j++) {</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>]) { <span class="comment">// 如果当前字符匹配到了单词中的第一个字符</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">dfs</span>(board,rows, cols, i, j, word, <span class="number">0</span>, visited)) {</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果找到符合条件的单词，就返回true</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果遍历了整个矩阵都没有找到符合条件的单词，就返回false</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> i, <span class="type">int</span> j, string word, <span class="type">int</span> k, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;visited)</span> </span>{</span><br><span class="line">        <span class="comment">// 如果已经找到了单词的最后一个字符就返回true</span></span><br><span class="line">        <span class="keyword">if</span> (k == word.<span class="built_in">size</span>()){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果当前位置越界、已经被访问过、或者当前位置的字符与单词中下一个要搜索的字符不匹配，就返回false</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>|| i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || board[i][j]!=word[k] || visited[i][j]==<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 标记当前位置已经访问过</span></span><br><span class="line">        visited[i][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从当前位置的上、下、左、右四个方向递归地搜索下一个字符，如果在这些方向中任意一个方向找到符合条件的单词，就返回true</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(board,rows, cols, i<span class="number">-1</span>, j, word, k+<span class="number">1</span>, visited)||</span><br><span class="line">        <span class="built_in">dfs</span>(board,rows, cols, i+<span class="number">1</span>, j, word, k+<span class="number">1</span>, visited)||</span><br><span class="line">        <span class="built_in">dfs</span>(board,rows, cols, i, j<span class="number">-1</span>, word, k+<span class="number">1</span>, visited)||</span><br><span class="line">        <span class="built_in">dfs</span>(board,rows, cols, i, j+<span class="number">1</span>, word, k+<span class="number">1</span>, visited)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果在所有方向中都没有找到符合条件的单词，就回溯到上一个字符位置，并将其标记为未访问过</span></span><br><span class="line">        visited[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> board == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rows = <span class="built_in">len</span>(board)</span><br><span class="line">        cols = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(cols)] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> self.dfs(board, rows,  cols, i, j, word, <span class="number">0</span>, visited):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, board, rows, cols, i, j, word, k, visited</span>):</span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=rows <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;=cols <span class="keyword">or</span> board[i][j]!=word[k] <span class="keyword">or</span> visited[i][j]==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="built_in">len</span>(word)-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        visited[i][j]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, rows, cols, i-<span class="number">1</span>, j, word, k+<span class="number">1</span>, visited):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, rows, cols, i+<span class="number">1</span>, j, word, k+<span class="number">1</span>, visited):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, rows, cols, i, j-<span class="number">1</span>, word, k+<span class="number">1</span>, visited):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, rows, cols, i, j+<span class="number">1</span>, word, k+<span class="number">1</span>, visited):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        visited[i][j]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（四）：二维数组中的查找</title>
    <url>/2023/09/16/%E5%89%91%E6%8C%87offer%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，<br>判断数组中是否含有该整数</p>
 <span id="more"></span> 
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h1><p>  1). 直接暴力遍历二维数组所有元素，时间复杂度为O(m*n)</p>
<p>  2). 对每一行使用一次二分查找，时间复杂度为O(m*logn)</p>
<p>  3). 根据简单的例子寻找规律，从右上角开始寻找，时间复杂度为O(m+n)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/bryceustc/CodingInterviews/blob/master/FindInPartiallySortedMatrix/FindInPartiallySortedMatrix.cpp">C++</a></p>
<h1 id="C"><a href="#C" class="headerlink" title="C++:"></a>C++:</h1><h2 id="方法一：暴力遍历"><a href="#方法一：暴力遍历" class="headerlink" title="方法一：暴力遍历"></a>方法一：暴力遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> m = matrix.<span class="built_in">size</span>();       </span><br><span class="line">            <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][j]==target)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    }                    </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;          </span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="方法二：遍历行-二分查找："><a href="#方法二：遍历行-二分查找：" class="headerlink" title="方法二：遍历行+二分查找："></a>方法二：遍历行+二分查找：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> n = matrix.<span class="built_in">size</span>();       </span><br><span class="line">            <span class="type">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> end = m<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span> (end&gt;=start)</span><br><span class="line">                {</span><br><span class="line">                    <span class="type">int</span> mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][mid]==target)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][mid]&lt;target)</span><br><span class="line">                        start = mid+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][mid]&gt;target)</span><br><span class="line">                        end = mid<span class="number">-1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;          </span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="方法三：从右上角或者左下角开始查找："><a href="#方法三：从右上角或者左下角开始查找：" class="headerlink" title="方法三：从右上角或者左下角开始查找："></a>方法三：从右上角或者左下角开始查找：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 右上角开始查找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) {</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左下角开始查找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = m<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;=<span class="number">0</span> &amp;&amp; j &lt; n) {</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) {</span><br><span class="line">                j++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) {</span><br><span class="line">                i--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针滑动窗口算法总结</title>
    <url>/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>滑动窗口算法，这个算法技巧的思路非常简单，就是利用双指针维护一个窗口，不断滑动，然后更新答案。LeetCode上有差不多10道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下：<br><span id="more"></span><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.<span class="built_in">add</span>(s[right]);</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个算法技巧的时间复杂度是 O(N)，比一般的字符串暴力算法要高效。</p>
<p>要注意各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果等。算法基本框架如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个…处的操作分别是右移和左移窗口更新操作，它们操作是完全对称的。</p>
<p>下面以四道 LeetCode 原题为例来套这个框架</p>
<h3 id="1、最小覆盖子串"><a href="#1、最小覆盖子串" class="headerlink" title="1、最小覆盖子串"></a>1、最小覆盖子串</h3><p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1.png" alt></p>
<p>使用暴力解法，代码大概是这样的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++)</span><br><span class="line">        <span class="keyword">if</span> s[i:j] 包含 t 的所有字母:</span><br><span class="line">            更新答案</span><br></pre></td></tr></table></figure></p>
<p><strong>滑动窗口算法思路：</strong></p>
<p>1、在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，<strong>把索引左闭右开区间[left, right)称为一个「窗口」。</strong> </p>
<p>2、先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。</p>
<p>3、此时，停止增加right，转而不断增加left指针缩小窗口[left, right)，直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。</p>
<p>4、重复第 2 和第 3 步，直到right到达字符串S的尽头。</p>
<p><strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解</strong>，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p>
<p>下面画图理解一下，needs和window相当于计数器，分别记录T中字符出现次数和「窗口」中的相应字符的出现次数。</p>
<p>初始状态：</p>
<p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/2.webp" alt></p>
<p>增加right，直到窗口[left, right)包含了T中所有字符：</p>
<p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/3.webp" alt></p>
<p>现在开始增加left，缩小窗口[left, right)。</p>
<p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/4.webp" alt></p>
<p>直到窗口中的字符串不再符合要求，left不再继续移动。</p>
<p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/5.webp" alt></p>
<p>之后重复上述过程，先移动right，再移动left…… 直到right指针到达字符串S的末端，算法结束。</p>
<p>首先，初始化window和need两个哈希表，记录窗口中的字符和需要凑齐的字符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br></pre></td></tr></table></figure>
<p>然后，使用left和right变量初始化窗口的两端，不要忘了，区间[left, right)是左闭右开的，所以初始情况下窗口没有包含任何元素：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> valid = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 开始滑动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>其中valid变量表示窗口中满足need条件的字符个数</strong>，如果valid和need.size()的大小相同，则说明窗口已满足条件，已经完全覆盖了串T。</p>
<p>现在开始套模板，只需要思考以下四个问题：</p>
<p>1、当移动right扩大窗口，即加入字符时，应该更新哪些数据？</p>
<p>2、什么条件下，窗口应该暂停扩大，开始移动left缩小窗口？</p>
<p>3、当移动left缩小窗口，即移出字符时，应该更新哪些数据？</p>
<p>4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p>
<p>如果一个字符进入窗口，应该增加window计数器；如果一个字符将移出窗口的时候，应该减少window计数器；当valid满足need时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p>
<p>下面是完整代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, len = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.<span class="built_in">count</span>(c)) </span><br><span class="line">        &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在这里更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; len)</span><br><span class="line">            &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.<span class="built_in">count</span>(d))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最小覆盖子串</span></span><br><span class="line">    <span class="keyword">return</span> len == n+<span class="number">1</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2、字符串排列"><a href="#2、字符串排列" class="headerlink" title="2、字符串排列"></a>2、字符串排列</h3><p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/2.png" alt> </p>
<p>注意哦，输入的s1是可以包含重复字符的，所以这个题难度不小。</p>
<p>这种题目，是明显的滑动窗口算法，相当给你一个S和一个T，请问你S中是否存在一个子串，包含T中所有字符且不包含其他字符？</p>
<p>首先，先套用滑动窗口算法框架代码，然后明确刚才提出的 4 个问题，写出如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 s 中是否存在 t 的排列</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string t, string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= t.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在这里判断是否找到了合法的子串</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.<span class="built_in">count</span>(d))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到符合条件的子串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、找到字符串中所有字母异位词"><a href="#3、找到字符串中所有字母异位词" class="headerlink" title="3、找到字符串中所有字母异位词"></a>3、找到字符串中所有字母异位词</h3><p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/3.png" alt></p>
<p>相当于，输入一个串S，一个串T，找到S中所有T的排列，并返回它们的起始索引。直接套用刚才的框架。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; needs, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (needs.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == needs[c]) </span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left == t.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当窗口符合条件时，把起始索引加入 res</span></span><br><span class="line">            <span class="keyword">if</span> (valid == needs.<span class="built_in">size</span>())</span><br><span class="line">                res.<span class="built_in">push_back</span>(left);</span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.<span class="built_in">count</span>(d))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入res即可。</p>
<h3 id="4、最长无重复子串"><a href="#4、最长无重复子串" class="headerlink" title="4、最长无重复子串"></a>4、最长无重复子串</h3><p><img src="/2020/04/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/4.png" alt></p>
<p>根据提出的四个问题，依次根据具体情况填入框架即可，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = s[right++];</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        m[c]++;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (m[c] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> d = s[left++];</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            m[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这里更新答案</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当m[c]值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动left缩小窗口。</p>
<p>要在收缩窗口完成后更新res，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复元素了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247485141&amp;idx=1&amp;sn=0e4583ad935e76e9a3f6793792e60734&amp;chksm=9bd7f8ddaca071cbb7570b2433290e5e2628d20473022a5517271de6d6e50783961bebc3dd3b&amp;scene=126&amp;sessionid=1587516905&amp;key=90f15a20186b1d46c2992f11e82b01a0cda6178792cdef35f4436e8185c7cc6e973a629da69bafba62e0b6551c49abdf6c71bd261ba3c3acf9539e3ecf9390d5761103a4d3a3c3eb9f0c41aadad3a4c5&amp;ascene=1&amp;uin=MjE1ODMxOTYzOA%3D%3D&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=A4FXMMlE%2Bef9sSA4mIuJSO0%3D&amp;pass_ticket=ppDnFMJpc9c%2Bn6RJFcuQ6KqAmN5hl%2BcvIiSNRu3bA2J3Np0Zr%2Fv7M6xJCQYQC60l"> labuladong公众号</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（十）：斐波那契数列</title>
    <url>/2023/09/27/%E5%89%91%E6%8C%87offer%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p>
<p><img src="https://cuijiahua.com/wp-content/uploads/2017/11/basis_7_3.jpg" alt><br><span id="more"></span></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h1><ol>
<li>传统暴力递归，复杂较高，可以用记忆化递归优化，时间复杂度O(2<sup>n</sup>);</li>
<li>动态规划，只用前两个数计算节省空间，时间复杂度O(n);</li>
<li><p>矩阵快速幂，利用数学公式，时间复杂度O(log<sub>2</sub>n);</p>
<img src="/2023/09/27/%E5%89%91%E6%8C%87offer%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/09/27/%E5%89%91%E6%8C%87offer%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/1.png" class>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="C"><a href="#C" class="headerlink" title="C++:"></a>C++:</h2><h3 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">fib</span>(n<span class="number">-2</span>) + <span class="built_in">fib</span>(n<span class="number">-1</span>)) % mod;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="记忆化搜索递归"><a href="#记忆化搜索递归" class="headerlink" title="记忆化搜索递归"></a>记忆化搜索递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">ans</span>(<span class="number">101</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(ans[n] != <span class="number">0</span>) <span class="keyword">return</span> ans[n];</span><br><span class="line">        ans[n] = (<span class="built_in">fib</span>(n<span class="number">-2</span>)+<span class="built_in">fib</span>(n<span class="number">-1</span>)) % mod;</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f_one = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> f_two = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">            f = (f_two + f_one) % mod;</span><br><span class="line">            f_two = f_one;</span><br><span class="line">            f_one = f;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span> {</span><br><span class="line">    ll mat[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">matrix</span>() { <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); }<span class="comment">//构造函数初始化</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    matrix res, transition;</span><br><span class="line">    <span class="comment">//矩阵乘法</span></span><br><span class="line">    <span class="function">matrix <span class="title">mul</span><span class="params">(matrix A, matrix B)</span> </span>{  <span class="comment">// return A * B</span></span><br><span class="line">        matrix C;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) {</span><br><span class="line">                    C.mat[i][j] += (A.mat[i][k] % mod * B.mat[k][j] % mod) % mod;</span><br><span class="line">                    C.mat[i][j] %= mod;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//快速幂</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fast_pow</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (n) {</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) {</span><br><span class="line">                res = <span class="built_in">mul</span>(res, transition);</span><br><span class="line">            }</span><br><span class="line">            transition = <span class="built_in">mul</span>(transition, transition);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        res.mat[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        transition.mat[<span class="number">0</span>][<span class="number">0</span>] = transition.mat[<span class="number">0</span>][<span class="number">1</span>] = transition.mat[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">fast_pow</span>(n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.mat[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h1><h3 id="递归-未通过OJ"><a href="#递归-未通过OJ" class="headerlink" title="递归 未通过OJ"></a>递归 未通过OJ</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Fibonacci</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> self.Fibonacci(n-<span class="number">1</span>) + self.Fibonacci(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Fibonacci</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        fn_one = <span class="number">1</span></span><br><span class="line">        fn_two = <span class="number">0</span></span><br><span class="line">        fn = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            fn = fn_one + fn_two</span><br><span class="line">            fn_two = fn_one</span><br><span class="line">            fn_one = fn</span><br><span class="line">        <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈总结</title>
    <url>/2020/04/04/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>单调栈主要回答这样的几种问题</p>
<ul>
<li>比当前元素更大的下一个元素</li>
<li>比当前元素更大的前一个元素</li>
<li>比当前元素更小的下一个元素</li>
<li><p>比当前元素更小的前一个元素</p>
<span id="more"></span>
<p>单调栈的一大优势就是<strong>线性的时间复杂度</strong>，所有的元素只会进栈一次，而且一旦出栈后就不会再进来了。</p>
<p><strong>单调递增栈可以找到左起第一个比当前数字小的元素</strong>。比如数组 [2 1 4 6 5]，刚开始2入栈，数字1入栈的时候，发现栈顶元素2比较大，将2移出栈，此时1入栈。那么2和1都没左起比自身小的数字。然后数字4入栈的时候，栈顶元素1小于4，于是1就是4左起第一个小的数字。此时栈里有1和4，然后数字6入栈的时候，栈顶元素4小于6，于是4就是6左起第一个小的数字。此时栈里有1，4，6，然后数字5入栈的时候，栈顶元素6大于5，将6移除，此时新的栈顶元素4小于5，那么4就是5左起的第一个小的数字，最终栈内数字为1，4，5。</p>
<p>同样的道理，<strong>单调递减栈可以找到左起第一个比当前数字大的元素</strong>。</p>
<h3 id="LeetCode-42：接雨水-（单调递减栈）"><a href="#LeetCode-42：接雨水-（单调递减栈）" class="headerlink" title="LeetCode 42：接雨水 （单调递减栈）"></a>LeetCode 42：接雨水 （单调递减栈）</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
</li>
</ul>
<p><img src="/2020/04/04/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/1.png" alt></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>
<p>分析：</p>
<p>必须两边高，中间低可以装下水，就可以使用一个单调递减栈，将递减的边界存进去，一旦发现当前的数字大于栈顶元素了，那么就有可能会有能装水的地方产生。此时我们当前的数字是右边界，我们从栈中至少需要有两个数字，才能形成一个坑槽，先取出的那个最小的数字，就是坑槽的最低点，再次取出的数字就是左边界，我们比较左右边界，取其中较小的值为装水的边界，然后此高度减去水槽最低点的高度，乘以左右边界间的距离就是装水量了。由于需要知道左右边界的位置，所以我们虽然维护的是递减栈，但是栈中数字并不是存递减的高度，而是递减的高度的坐标。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n =height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>() || height[i] &lt; height[s.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> h = <span class="built_in">min</span>(height[s.<span class="built_in">top</span>()],height[i]) -  height[t];</span><br><span class="line">                <span class="type">int</span> w = i-s.<span class="built_in">top</span>()<span class="number">-1</span>;</span><br><span class="line">                res += h*w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-84：柱状图中最大的矩形（单调递增栈）"><a href="#LeetCode-84：柱状图中最大的矩形（单调递增栈）" class="headerlink" title="LeetCode 84：柱状图中最大的矩形（单调递增栈）"></a>LeetCode 84：柱状图中最大的矩形（单调递增栈）</h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="/2020/04/04/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/2.png" alt></p>
<p>分析：就是找两边第一个小于它的值，比如height[i]，以第i根柱子为最矮柱子所能延伸的最大面积，是以i 为中心，向左找第一个小于 heights[i] 的位置 left_i；向右找第一个小于于 heights[i] 的位置 right_i，即最大面积为 heights[i] * (right_i - left_i -1)，如下图所示:</p>
<p><img src="/2020/04/04/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/3.png" alt><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 单调递增栈，为保证所有元素都出栈，最后加一个0</span></span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || heights[i] &gt; heights[s.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 出栈是计算以栈顶元素高度为矩形长的最大矩形面积</span></span><br><span class="line">                <span class="type">int</span> t = s.<span class="built_in">top</span>();  </span><br><span class="line">                <span class="comment">// height[t]高度为最高，寻找左右两端小于高度heights[t]的坐标,右边小于高度t的坐标为i，</span></span><br><span class="line">                <span class="comment">// 如果出栈后不为空，则左边小于高度t的坐标为s.top(), 因为维持递增序列，</span></span><br><span class="line">                <span class="comment">// 出栈后下一个栈顶是小于高度t的，为空则说明左边没有小于高度t的</span></span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    w = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 注意-1</span></span><br><span class="line">                    w = i - s.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, heights[t] * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode-496：下一个更大元素-I（单调递减栈-哈希表）"><a href="#LeetCode-496：下一个更大元素-I（单调递减栈-哈希表）" class="headerlink" title="LeetCode 496：下一个更大元素 I（单调递减栈+哈希表）"></a>LeetCode 496：下一个更大元素 I（单调递减栈+哈希表）</h3><p>给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。</p>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字2，第二个数组中的下一个较大数字是3。</span><br><span class="line">    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 单调递减栈 寻找nums2数组对应元素右起的比它大的数</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;n2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>()|| nums2[i]&lt;s.<span class="built_in">top</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(nums2[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                m[t] = nums2[i]; </span><br><span class="line">                <span class="comment">// 哈希表存储对应的数字的下一个更大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 没有更大的数</span></span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m[s.<span class="built_in">top</span>()] = <span class="number">-1</span>;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(m[num]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode-503：下一个更大元素-II（单调不增栈）"><a href="#LeetCode-503：下一个更大元素-II（单调不增栈）" class="headerlink" title="LeetCode 503：下一个更大元素 II（单调不增栈）"></a>LeetCode 503：下一个更大元素 II（单调不增栈）</h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure></p>
<p>注意:</p>
<p>如果不是循环数组，就可以写成如下形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>()||nums[i]&lt;nums[s.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                res[t] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>循环数组形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="comment">// 循环数组，相当于复制两次数组，遍历两次，一般环形利用取模运算来实现</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="number">2</span>*n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || nums[i%n] &lt;= nums[s.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(i%n);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 只用考虑出栈的元素，在栈里边的不用考虑</span></span><br><span class="line">                res[t] = nums[i%n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode-739：-每日温度（单调不增栈）"><a href="#LeetCode-739：-每日温度（单调不增栈）" class="headerlink" title="LeetCode 739： 每日温度（单调不增栈）"></a>LeetCode 739： 每日温度（单调不增栈）</h3><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>分析：</p>
<p>利用单调不增栈，当当前元素严格大于栈顶元素才出栈。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = T.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || T[i] &lt;= T[s.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                res[t] = i-t;  <span class="comment">//  注意返回的是两坐标之差</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>至于最后一点要说的就是，如何确定是使用严格单调栈还是非严格单调栈？<strong>只要根据题意确定我们栈中是否可以存放相同元素即可</strong></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>在Hexo博客中发布文章</title>
    <url>/2020/03/21/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h4 id="1、新建一篇文章"><a href="#1、新建一篇文章" class="headerlink" title="1、新建一篇文章"></a>1、新建一篇文章</h4><p>（1）在hexo博客目录下，进入Git Bash命令窗口中，输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;在这里&quot;</span><br></pre></td></tr></table></figure>
<p>（2）在博客目录下的/source/_posts/ 文件夹下，可以看到已经生成了标题为(在这里.md)的博客文件：<br>如图所示：<br><img src="https://winney07.github.io/2018/08/02/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/zai.png" alt></p>
<span id="more"></span>
<p>（3）在（在这里.md）文件中编辑自己的博客文章即可。<br>注意：Hexo 发布的文章是 Markdown 格式的文件， Markdown 基本语法的网址：<a href="https://www.jianshu.com/p/191d1e21f7ed">点这里前往</a></p>
<h4 id="2、给文章添加分类和标签"><a href="#2、给文章添加分类和标签" class="headerlink" title="2、给文章添加分类和标签"></a>2、给文章添加分类和标签</h4><p>(1) 在（在这里.md）文件中设置tags和categories属性：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 在这里</span><br><span class="line">date: 2018-08-02 11:41:10</span><br><span class="line">tags:</span><br><span class="line">- 博客           //多个标签可以这样添加</span><br><span class="line">- hexo</span><br><span class="line">categories: test</span><br></pre></td></tr></table></figure><br>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/zai-edit.png" alt></p>
<h4 id="3、启动服务器，本地测试"><a href="#3、启动服务器，本地测试" class="headerlink" title="3、启动服务器，本地测试"></a>3、启动服务器，本地测试</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<h4 id="4、添加“阅读全文”按钮"><a href="#4、添加“阅读全文”按钮" class="headerlink" title="4、添加“阅读全文”按钮"></a>4、添加“阅读全文”按钮</h4><p>方法一：在文章任意你想添加的位置添加即可<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure></p>
<p>方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto_excerpt进行修改：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure></p>
<p>其中length代表显示摘要的截取字符长度。</p>
<p>注：这两种方法，在博客首页显示的效果不一样，根据自己的需要，选择自己喜欢的方法</p>
<h4 id="5、在博文中添加图片"><a href="#5、在博文中添加图片" class="headerlink" title="5、在博文中添加图片"></a>5、在博文中添加图片</h4><p>方法一：</p>
<p>(1)在blog目录下，安装插件：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><br>(2)在blog\source 目录下新建一个images文件夹，把图片放置在里面；</p>
<p>(3)在xxx.md文件中引用图片：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">{% asset_img "header.jpg" "header" %}</span><br></pre></td></tr></table></figure></p>
<p>方法二：</p>
<p>(1)在全局配置文件（blog/_config.yml)中将post_asset_folder设置为true；</p>
<p>(2)创建文章（在创建的时候，会在blog/source/_post目录下，生成一个XXX.md文件和一个XXX的文件夹）：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;XXX&quot;</span><br></pre></td></tr></table></figure></p>
<p>(3)把XXX这个博文需要展示的图片放在XXX文件夹目录下；</p>
<p>(4)在XXX.md文件中引入图片的方式：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">{% asset_img "图片名.jpg" "你想输入的替代文字" %}</span><br></pre></td></tr></table></figure></p>
<h4 id="6、发布到Github上"><a href="#6、发布到Github上" class="headerlink" title="6、发布到Github上"></a>6、发布到Github上</h4><p>（1）发表的文章在本地预览无误后，在 Git Bash 命令窗口执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>（2）在浏览器，访问自己的博客域名，即可看到刚 发布的文章</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解协议</title>
    <url>/2020/04/06/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>协议：</p>
<p>“协”字，代表必须有两个以上的参与者。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。</p>
<p>“议”字，代表的意思是对参与者的一种行为约定和规范。例如三方协议里规定的试用期限、毁约金等；租房协议里的租用期限、每月租金金额等。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Git总结</title>
    <url>/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>针对学习Git的操作命令进行了一个总结。具体如下面这张思维导图，记录一下提纲，方便自己建立完整的Git知识体系。</p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/1.png" alt></p>
<span id="more"></span>
<h2 id="一、-原理"><a href="#一、-原理" class="headerlink" title="一、 原理"></a>一、 原理</h2><h3 id="1-三个工作区"><a href="#1-三个工作区" class="headerlink" title="1. 三个工作区"></a>1. 三个工作区</h3><p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/2.jpg" alt></p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/3.jpg" alt></p>
<h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/4.jpg" alt></p>
<h2 id="二、-操作"><a href="#二、-操作" class="headerlink" title="二、 操作"></a>二、 操作</h2><h3 id="1-设置"><a href="#1-设置" class="headerlink" title="1. 设置"></a>1. 设置</h3><ul>
<li><p>git init</p>
<p>  <img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/5.jpg" alt></p>
<ul>
<li>在LearnGit目录下创建一个版本库该目录下的所有内容都会被作为版本库的组成，会默认创建一个隐藏的.git目录，用来存放版本库的全部原数据。</li>
</ul>
</li>
<li><p>git config</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;bryceustc&quot;</span><br><span class="line">git config --global user.mail bryce@mail.ustc.edu.cn</span><br></pre></td></tr></table></figure>
<p>  用来对本地版本库进行一些设置  比如本地版本库的拥有者是谁 联系方式是怎样的<br>  也就是这两个参数 :user.name和user.email </p>
<ol>
<li>仅这两个全局变量值是必须设置的。但所有可设置的值超过130个。其中大部分都很少用得上。</li>
<li><p>命令中global的意思是 把这个设置应用于本地计算机的所有地方，也就是说你在本地所有地方建立的版本库拥有者和联系方式都是这个</p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/6.jpg" alt></p>
<p>可以用命令<code>git config --global --list</code>来看一下上面设置的一些属性</p>
</li>
</ol>
</li>
</ul>
<h3 id="2-编辑"><a href="#2-编辑" class="headerlink" title="2. 编辑"></a>2. 编辑</h3><ul>
<li><p>git add</p>
<ul>
<li><p>这个命令的功能是将文件添加到暂存区</p>
<p>  可以有两种方式去去使用</p>
<p>  一种是通过直接git add 的方式把要添加的文件跟在后面 也就是通过命令行的方式</p>
<p>  一种是通过git add -i的方式调出交互式接口来使用 更多子命令功能更丰富<br>  这里只说第一种方式的使用</p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/7.jpg" alt></p>
</li>
<li><p>在目录下建立文件README.md 内容如上</p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/8.jpg" alt></p>
</li>
<li><p>输入 git add README.md 即可。如果没有任何提示说明已经添加成功了</p>
</li>
</ul>
</li>
<li><p>git commit</p>
<ul>
<li><p>把修改后的文件从本地暂存区 提交到 本地仓库 (注意不是远程仓库)<br>使用git commit 提交缓冲区文件到本地仓库的时候必须写好备注 也就是说明提交的原因 也就是得加上-m参数  像下面这样<br>这样默认会把暂存区所有的文件都推到本地仓库</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit-m&quot; first commit&quot;</span><br></pre></td></tr></table></figure>
<p>  <img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/9.jpg" alt></p>
</li>
<li><p>如果只是想把暂存区部分文件推到本地仓库可以在后面加上你要推的指定的文件名</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m&quot;first commit &quot;  test3.txt</span><br></pre></td></tr></table></figure></li>
<li><p>git commit -C HEAD -a —amend这个命令的功能是在想改进上次提交里面的某些错误</p>
<p> -C 参数表示就采用和上次提交一样的备注</p>
<p> HEAD参数表示提交名称</p>
<p> -a表示提交所有暂存区的文件</p>
<p> —amend就是表示把改动融合进上次的提交里面</p>
</li>
</ul>
</li>
<li><p>git status</p>
<ul>
<li><p>没有git add</p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/11.jpg" alt></p>
</li>
<li><p>git add 以后</p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/10.jpg" alt></p>
</li>
<li><p>git commit 以后</p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/12.jpg" alt></p>
</li>
<li><p>删除工作区文件之后</p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/14.jpg" alt></p>
</li>
<li><p>改动工作区文件以后</p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/13.jpg" alt><br><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/15.jpg" alt></p>
</li>
</ul>
</li>
<li><p>git diff</p>
<ul>
<li><p>改动工作区文件以后</p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/16.jpg" alt></p>
</li>
<li><p>git diff 不加参数 </p>
<p>  （1）当暂存区中没有文件时，git diff比较的是，工作区中的文件与上次提交到版本库中的文件。</p>
<p>  （2）当暂存区中有文件时，git diff则比较的是，当前工作区中的文件与暂存区中的文件。</p>
</li>
<li>git  diff —cached 比较暂存区和本地仓库文件的区别</li>
<li>git diff HEAD 比较的是工作区中的文件与版本库中文件的差异(当前分支上)  </li>
<li>git diff new 将当前分支和指定分支new对比</li>
</ul>
</li>
<li><p>git mv </p>
<ul>
<li><p>git mv  把工作区的文件重命名或者移动 </p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git  mv  README.md </span><br><span class="line">git mv readme.md</span><br></pre></td></tr></table></figure></li>
<li><p>你也可以不用git mv </p>
<p>  直接在操作系统下鼠标操作移动或者重命名但是这样的话你得重新git add 然后git commit 而用了git mv 的话只要git commit就可以了 </p>
</li>
</ul>
</li>
<li><p>git rm</p>
<ul>
<li>git rm  把工作区的文件删除<br>  比如  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git  rm  readme.md</span><br></pre></td></tr></table></figure></li>
<li><p>你也可以不用git rm</p>
<p>  直接在操作系统下鼠标操作删除但是这样的话你得重新git add 然后git commit 而用了git rm 的话只要git commit就可以了 </p>
</li>
</ul>
</li>
</ul>
<h3 id="3-日志"><a href="#3-日志" class="headerlink" title="3. 日志"></a>3. 日志</h3><ul>
<li><p>git log</p>
<ul>
<li><p>git log 47f9e8e 传递一个指定的版本，并以此作为查看日志的起始点（查看从那时起到现在的全部提交）</p>
</li>
<li><p>git log —since=”5 hours”查看最近5小时内的提交</p>
<p>  <img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/17.jpg" alt></p>
<p>  git log 可以显示提交的日志项，包括是谁，何时做的提交，以及本次提交的具体代码改动（可选的）等信息 按照时间倒序显示 后面可以通过设置各种各样的参数来过滤日志</p>
<p>  每个提交有四部分信息：提交名称、提交人、提交日期、提交留言</p>
</li>
<li><p>git log —before=”5 hours” -1来查看5小时之前的最后一个</p>
</li>
<li><p>git log 47f9e8e..440b963用“最老版本..最新版本”这种格式作为查找范围。最老版本在前，最新版本在后</p>
</li>
</ul>
</li>
<li><p>git reset</p>
<p>  git reset —hard HEAD  回退到head之前的那一个版本</p>
<p>  git reset —hard HEAD^  回退到head之前在之前的一个版本</p>
<p>  git reset —hard 版本库ID  回退到版本库ID的那个版本</p>
<p>  <img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/18.jpg" alt></p>
<p>  <img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/19.jpg" alt></p>
<p>  <img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/20.jpg" alt></p>
<p>  <img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/21.jpg" alt></p>
<p>  Git reset 命令有三个主要选项：git reset —soft; git reset —mixed; git reset —hard;</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --soft</span><br></pre></td></tr></table></figure>
<p>  将HEAD引用指向给定提交。索引（暂存区）和工作目录的内容是不变的，在三个命令中对现有版本库状态改动最小。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --mixed（git reset默认的模式）</span><br></pre></td></tr></table></figure>
<p>  HEAD引用指向给定提交，并且索引（暂存区）内容也跟着改变，工作目录内容不变。这个命令会将索引（暂存区）变成你刚刚暂存该提交全部变化时的状态，会显示工作目录中有什么修改。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure>
<p>  HEAD引用指向给定提交，索引（暂存区）内容和工作目录内容都会变给定提交时的状态。也就是在给定提交后所修改的内容都会丢失(新文件会被删除，不在工作目录中的文件恢复，未清除回收站的前提)。</p>
<p>  <img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/22.jpg" alt></p>
</li>
<li><p>git revert</p>
</li>
</ul>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/23.jpg" alt></p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/24.png" alt></p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/25.png" alt></p>
<p><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/26.jpg" alt></p>
<h3 id="4-分支"><a href="#4-分支" class="headerlink" title="4. 分支"></a>4. 分支</h3><ul>
<li><p>分支的介绍</p>
<p>  在项目开发的过程中 有时需要添加新功能 测试新算法  修正新bug 如果只有一条版本演进的轨迹 则很难实现，故需要引入多条分支来开发</p>
</li>
<li><p>git branch</p>
<ul>
<li><p>git branch -m master mymaster 分支重命名</p>
</li>
<li><p>git branch 查看当前分支</p>
</li>
<li><p>git branch mybranch 创建一个新分支 mybranch</p>
</li>
<li><p>git branch -r 显示远程分支</p>
</li>
<li><p>git branch -d mybranch 删除分支mybranch 只有当要删除的分支</p>
<p>  已经成功合并到当前分支时删除才会成功  可以把小写的d改成大写的D这样就不会检查 强行删除</p>
</li>
</ul>
</li>
<li><p>git checkout</p>
<ul>
<li><p>git checkout mybranch   切换到新分支 mybranch</p>
</li>
<li><p>git checkout -b mybranch  创建并切换到新分支mybranch</p>
</li>
<li><p>git checkout -b mybranch master   基于主分支上创建并切换到新分支mybranch</p>
</li>
</ul>
</li>
<li><p>git merge</p>
<ul>
<li><p>git merge mybranch  把分支mybranch合并到当前分支上 </p>
<p>  当mybranch添加内容会添加到当前分支上  在mybranch中删除的内容在当前分支也会删除 但是当两个分支在同一个文件的同一行发生差异时 合并时就会发生冲突 从而也就不能自动合并得人工处理</p>
<p>  <img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/27.jpg" alt></p>
<p>  分支冲突处理:Git不能自动合并时，称之为冲突(conflict）。冲突总是发生在对不同分支上的同一文件的同一文本块以不同的方式修改，并试图合并的时候,它就会停下来等待人工处理。</p>
<p>  比如在master 分支下commit了一个readme.md文件<br>  在new1分支下也commit了一个readme.md文件<br>  这两个文件在第2行是不同的<br>  这个时候你跳到master分支上用git merge new1 就会发生冲突<br>  而且在本地生成一个需要你修改的临时文件<br>  你需要对他进行修改，改成你觉得合适的结果<br>  然后git add ,git commit -m就完成了合并</p>
<p>  <a href="https://www.jianshu.com/p/7b2d2cd0f308">参考Git 合并冲突处理</a></p>
</li>
<li><p>git merge —squash mybranch   略</p>
</li>
</ul>
</li>
<li><p>git rebase <a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">变基</a></p>
</li>
<li><p>git cherry-pick</p>
</li>
</ul>
<h3 id="5-协作"><a href="#5-协作" class="headerlink" title="5. 协作"></a>5. 协作</h3><ul>
<li><p>git clone</p>
<ul>
<li><p>git clone <a href="https://github.com/bryceustc/bryceustc.github.io.git">https://github.com/bryceustc/bryceustc.github.io.git</a></p>
<p>  从远程库克隆到本地工作区</p>
</li>
<li><p>git clone —recursive  <a href="https://github.com/bryceustc/bryceustc.github.io.git">https://github.com/bryceustc/bryceustc.github.io.git</a></p>
<p>  若需要克隆含有子模块的仓库，直接 进行克隆是无法拉取之模块的代码，可加上 —recursive 参数</p>
</li>
<li><p>git submodule update —init —recursive</p>
<p>  如果不确定子模块是否已经下载完全了 执行这个命令确认一下</p>
</li>
<li><p>git clone -b dev_jk <a href="http://10.1.1.11/service/tmall-service.git">http://10.1.1.11/service/tmall-service.git</a><br>克隆指定分支</p>
</li>
</ul>
</li>
<li><p>git remote </p>
<ul>
<li><p>给指定的远程库地址设置一个别名，不然的话每次push/pull都得把完整的一大串地址写下来</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/bryceustc/bryceustc.github.io.git</span><br></pre></td></tr></table></figure>
<p>  把远程库地址指定一个别名为origin</p>
<p>  关于远程分支名前面的前缀origin/表示远程版本库上的分支名称，<br>  用于区别本地分支名称。<br>  而origin是默认的远程版本库别名，即克隆时指定的远程版本库</p>
</li>
<li><p>使用不带任何参数的git remote命令，可以查看本地创建的全部远程版本库别名</p>
</li>
<li><p>使用git remote show <name>命令可以查看某个远程版本库的详细信息<br><img src="/2020/05/01/%E5%AD%A6%E4%B9%A0Git%E6%80%BB%E7%BB%93/28.jpg" alt></name></p>
</li>
<li><p>如果不再需要某个远程版本库的别名，或者想用这个别名称呼其他远程版本<br>库，则可以使用git remote rm命令先删除该别名。</p>
</li>
</ul>
</li>
<li><p>git fetch</p>
<ul>
<li><p>git fetch 相当于是从远程获取最新到本地，不会自动merge，如下指令：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin master:tmp //从远程仓库master分支获取最新，在本地建立tmp分支</span><br><span class="line">git diff tmp //將當前分支和tmp進行對比</span><br><span class="line">git merge tmp //合并tmp分支到当前分支</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于rebase的合并方式，与merge的主要区别在于git log上：是否保留分支的commit提交节点 。rebase其实就是寻找公共祖先，具体理解可参考<a href="https://www.jianshu.com/p/f23f72251abc">这里</a></p>
</li>
</ul>
</li>
<li><p>git pull</p>
<ul>
<li><p>git pull是相当于从远程仓库获取最新版本，然后再与本地分支合并。</p>
<p>  git pull = git fetch + git merge(默认是用merge 加-r参数变可以合并方式改成rebase)</p>
</li>
<li>git pull origin master 把远程的master分支拉取并用merge的方式合并到本地分支上</li>
<li>git pull origin master:new 把远程的master分支拉取并用merge合并到本地的new分支上</li>
<li>git pull  -r origin master:new 把远程的master分支拉取并用rebase的方式合并到本地的new分支上</li>
</ul>
</li>
</ul>
<ul>
<li><p>git push</p>
<ul>
<li>git push origin  master 把本地master分支推到对应的远程库(origin)的master分支  如果远程库分支不存在 将会新建</li>
<li>git push origin new把本地new分支推到对应的远程库(origin)的new分支  如果远程库分支不存在 将会新建</li>
<li>git push origin new:远端分支 把本地的new分支推到对应远程库(origin)的指定名字的远端分支 如果不存在将会新建</li>
<li>git push origin :远端分支    删除远程库的指定远端分支 因为这样相当与推送一个空的分支到指定的远端分支 </li>
<li>git push origin —delete 远端分支名 等同于上面那条命令</li>
<li>git push -u origin new 把本地分支new推到远端主机的对应new分支 同时把origin设定为new分支对应的默认主机 这样的话就下次就可以不用加参数直接用git push 就可以把当前分支推送到默认主机的对应分支</li>
<li>git push —set-upstream origin new   把origin设定为new分支对应的默认主机 这样的话就下次就可以不用加参数直接用git push 就可以把当前分支推送到默认主机的对应分支</li>
<li>git push origin 把当前分支推送到origin主机的对应分支</li>
<li>git push -all origin 将本地所有分支都推送到远程分支</li>
<li>git push  —force origin   当本地分支的版本小于远端分支的时候 push会出错会提示你将远程的的分支拉下来先处理矛冲突载push  这个时候可以强行push也就是加—force命令 也可以简写为git push -f</li>
<li>git push origin —tags 加上—tags选项可以推送标签</li>
</ul>
</li>
<li><p>push冲突处理</p>
<ul>
<li><p>当你git push 的时候在可能会发生冲突 导致push失败  </p>
<p>  冲突发生的原因</p>
<p>  情况一:在你提交之前 别人已经在同一个文件的同一个地方进行了修改 </p>
<p>  情况二:你提交的本地库的版本号落后于远程版本库</p>
</li>
<li><p>冲突处理的方法:</p>
<p>  方法一:在用git pull  把远程库的文件拉下来 如果不能进行自动合并 则在本地手动合并发生发生冲突的文件 合并完成以后再进行git push就行了</p>
<p>  方法二: 直接用git  push -f 直接用本地库强制覆盖远程库</p>
</li>
</ul>
</li>
</ul>
<h2 id="三、-实战"><a href="#三、-实战" class="headerlink" title="三、 实战"></a>三、 实战</h2><ul>
<li><p>git clone</p>
</li>
<li><p>git init</p>
</li>
<li><p>git remote add</p>
</li>
<li><p>git pull</p>
</li>
<li><p>git branch 创建自己的开发分支</p>
</li>
<li><p>开始编码</p>
</li>
<li><p>git add</p>
</li>
<li><p>git  commit</p>
</li>
<li><p>git push</p>
</li>
<li><p>在github界面执行合并</p>
<p>  把你更改的分支和目标分支合并等待管理员通过</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>将Hexo博客主题更换为NexT主题</title>
    <url>/2020/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p>1、把默认主题更改成Next主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>这是将Next主题下载到blog目录的themes主题下的next文件夹中。打开站点的_config.yml配置文件，修改主题为next<br><img src="/2020/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/1.jpg" class><br><span id="more"></span><br>打开<strong>主题theme</strong>的_config.yml配置文件，不是<strong>站点site</strong>主题文件，找到Scheme Settings<br><img src="/2020/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/2.jpg" class><br>next主题有三个样式，我用的是Pisces，可以选择你自己喜欢的样式（只需要把行首的#去除，#是注释），选择好后，再次部署网站，hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。</p>
<p>2、在主题配置文件 _config.yml中配置博客网站底部的基本信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup.</span><br><span class="line">  # If not defined, current year will be used.</span><br><span class="line">  since: 2020      #网站起始运营年份</span><br><span class="line"></span><br><span class="line">  # Icon between year and copyright info.</span><br><span class="line">  icon: user     #声明图标</span><br><span class="line"></span><br><span class="line">  # If not defined, will be used `author` from Hexo main config.</span><br><span class="line">  copyright: bryceustc   #版权所有</span><br><span class="line">  # ------------------------------------------------------------</span><br><span class="line">  # Hexo link (Powered by Hexo).</span><br><span class="line">  powered: true</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">    enable: false    #是否显示主题</span><br><span class="line">    # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">    version: false     #是否显示驱动</span><br></pre></td></tr></table></figure>
<p>3、在主题配置文件 _config.yml中配置菜单按钮，找到menu属性，做以下配置：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line"> home: / || home     #首页，后面的表示图标</span><br><span class="line"> categories: /categories/ || th   #分类</span><br><span class="line"> tags: /tags/ || tags       #标签</span><br><span class="line"> archives: /archives/ || archive     #归档</span><br><span class="line"> about: /about/ || user       #关于</span><br><span class="line"> #schedule: /schedule/ || calendar</span><br><span class="line"> #sitemap: /sitemap.xml || sitemap</span><br><span class="line"> #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure><br>4、创建相应的页面</p>
<p>（1）执行命令hexo s，本地预览我们的博客页面，会发现，点击分类、标签、关于这几个页面的时候，会显示404。</p>
<p>（2）在Git Bash命令窗口，输入以下命令来创建相应页面：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &#x27;categories&#x27;</span><br><span class="line">hexo new page &#x27;tags&#x27;</span><br><span class="line">hexo new page &#x27;about&#x27;</span><br></pre></td></tr></table></figure><br>（3）可以在hexo/source目录下看到创建的3个文件夹<br><img src="https://winney07.github.io/2018/08/01/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/source.png" alt></p>
<p>5、每一个分类菜单都生成了一个 index.md 初始文件（在刚创建的文件夹目录下），默认包含了 title 和 date 字段，我们需要给每一 index.md 文件添加上 type 字段<br>如下所示：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-3-20 16:28:33</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-3-20 16:28:33</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2020-3-20 16:28:33</span><br><span class="line">type: about</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>6、配置搜索菜单：<br>（1）安装 hexo-generator-searchdb ，在 Git Bash 命令窗口，输入以下命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></p>
<p>（2）打开全局配置文件（hexo/_config.yml），新增以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p>（3）打开主题配置文件（hexo/themes/next/_config.yml），找到 local_search 属性，开启本地搜索功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>
<p>7、执行命令hexo s，本地预览我们的博客页面，发现刚才的配置已经完成</p>
<p>8、在命令窗口，输入以下命令，将修改后的本地hexo项目托管到GitHub上<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></p>
<p>9、上传成功后，可以通过自己的博客域名访问修改主题和修改相关配置后的博客页面</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>完全二叉树DFS转BFS</title>
    <url>/2021/05/09/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91DFS%E8%BD%ACBFS/</url>
    <content><![CDATA[<h1 id="题目描述-完全二叉树DFS转BFS"><a href="#题目描述-完全二叉树DFS转BFS" class="headerlink" title="题目描述:完全二叉树DFS转BFS"></a>题目描述:完全二叉树DFS转BFS</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个字符串，其字符序列是根据一个完全二叉树通过深度优先遍历得到的，二叉树的每个节点是一个单字符。如果对这个完全二叉树改用广度优先遍历算法，那么得到的字符串是什么，将这个字符串序列以字符串的形式输出。</p>
<p>输入描述：</p>
<p>输入一行，一个由字母和数字组成的字符串，字符串长度为2<sup>n</sup>-1，例如 2<sup>3</sup>-1 = 7，n大于等于1。如果输入字符串的长度不合要求，那么统一输出字符串WRONG INPUT。</p>
<p>输出描述：<br>输出一行字符串。</p>
<p>样例输入：abcdefg<br>样例输出：abecdfg<br> <span id="more"></span> </p>
<h1 id="本题考点："><a href="#本题考点：" class="headerlink" title="本题考点："></a>本题考点：</h1><p>  1). 完全二叉树的理解</p>
<p>  2). 前序遍历</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, i;</span><br><span class="line">string x, res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> ((n&amp;(n<span class="number">-1</span>))==<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(index &lt; n) {</span><br><span class="line">        res[index] = x[i++];</span><br><span class="line">        <span class="built_in">dfs</span>(index * <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    n = x.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Check</span>(n)) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"WRONG INPUT"</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        res = x;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            cout &lt;&lt; res[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>字节序：大端法和小端法</title>
    <url>/2020/04/08/%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%9A%E5%A4%A7%E7%AB%AF%E6%B3%95%E5%92%8C%E5%B0%8F%E7%AB%AF%E6%B3%95/</url>
    <content><![CDATA[<p>字节序，顾名思义字节的顺序，再多说两句就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。</p>
<p>大端法：高位保存在低地址中。<br>小端法：高位存放在高地址中。</p>
<p><img src="/2020/04/08/%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%9A%E5%A4%A7%E7%AB%AF%E6%B3%95%E5%92%8C%E5%B0%8F%E7%AB%AF%E6%B3%95/1.webp" alt><br><span id="more"></span><br><strong>程序判断大端法还是小端法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">short</span> s;</span><br><span class="line">        <span class="type">char</span> c[<span class="built_in">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125; u;</span><br><span class="line"></span><br><span class="line">    u.s = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sizeof</span>(<span class="type">short</span>) == <span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (u.c[<span class="number">0</span>] == <span class="number">0x12</span> &amp;&amp; u.c[<span class="number">1</span>] == <span class="number">0x34</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Big-Endian&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (u.c[<span class="number">0</span>] == <span class="number">0x34</span> &amp;&amp; u.c[<span class="number">1</span>] == <span class="number">0x12</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Little-Endian&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not known&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(short) =&quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>大端和小端法对程序的影响</strong></p>
<ul>
<li><p>字节序不是由操作系统决定，而是由cpu架构决定的，比如 x86 的是小端序，而 PPC (PowerPC) 是big endian。 所以跑在 x86 上的 linux/windows 都是小端，而跑在 PPC 上的linux则是大端。</p>
</li>
<li><p>网络字节序为大端。</p>
</li>
<li><p>网络编程中常用的字节序转换函数有如下几个：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;&lt;netinet/in.h&gt;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uing16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> host16bitvalue)</span></span>;    </span><br><span class="line"><span class="comment">// 参数为16位主机字节序的值，返回值是16位网络字节序的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> host32bitvalue)</span></span>;    </span><br><span class="line"><span class="comment">// 参数为32位主机字节序的值，返回值是32位网络字节序的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint16_t</span> net16bitvalue)</span></span>;     </span><br><span class="line"><span class="comment">// 参数为16位网络字节序的值，返回值是16位主机字节序的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">uint32_t</span> net32bitvalue)</span></span>;     </span><br><span class="line"><span class="comment">// 参数为16位网络字节序的值，返回值是16位主机字节序的值</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法</title>
    <url>/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>整理一些常见的六大基础排序算法： 冒泡排序、选择排序、<strong>插入排序</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong></p>
<p><img src="/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort_summary.jpg" alt></p>
<span id="more"></span>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span></span><br><span class="line"><span class="comment">    2. 对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</span></span><br><span class="line"><span class="comment">    3. 针对所有的元素重复以上的步骤，除了最后已经选出的元素（有序）。</span></span><br><span class="line"><span class="comment">    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定排序，平均 O(n**2)，最好 O(n), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// swap(nums[j], nums[j+1]);</span></span><br><span class="line">                <span class="type">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt></p>
<h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</span></span><br><span class="line"><span class="comment">    2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</span></span><br><span class="line"><span class="comment">    3. 以此类推，直到所有元素均排序完毕。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定排序，平均 O(n**2)，最好 O(n**2), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> idx = i;</span><br><span class="line">        <span class="comment">//每一趟循环比较时，idx用于存放较小元素的数组下标，</span></span><br><span class="line">        <span class="comment">//这样当前批次比较完毕最终存放的就是此趟内最小的元素</span></span><br><span class="line">        <span class="comment">//的下标，避免每次遇到较小元素都要进行交换。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] &gt; nums[j]);</span><br><span class="line">            &#123;</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (idx !=i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp = nums[idx];</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-插入排序（重要）"><a href="#3-插入排序（重要）" class="headerlink" title="3. 插入排序（重要）"></a>3. 插入排序（重要）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt></p>
<h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   直接插入排序基本思想是每一步将一个待排序的记录，</span></span><br><span class="line"><span class="comment">   插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   1. 从第一个元素开始，该元素可以认为已经被排序</span></span><br><span class="line"><span class="comment">   2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</span></span><br><span class="line"><span class="comment">   3. 如果被扫描的元素（已排序）大于新元素，将该元素后移一位</span></span><br><span class="line"><span class="comment">   4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span></span><br><span class="line"><span class="comment">   5. 将新元素插入到该位置后</span></span><br><span class="line"><span class="comment">   6. 重复步骤2~5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定排序，平均 O(n**2)，最好 O(n), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 从下标为1的元素开始选择合适的位置插入，</span></span><br><span class="line">    <span class="comment">// 因为下标为0的只有一个元素，默认是有序的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 记录要插入的数据</span></span><br><span class="line">        <span class="type">int</span> temp  = nums[i];</span><br><span class="line">        <span class="type">int</span> j = i- <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//与已排序的数逐一比较，大于temp时，该数移后</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span>) &amp;&amp; (nums[j] &gt; nums[j])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-归并排序（重要）"><a href="#4-归并排序（重要）" class="headerlink" title="4. 归并排序（重要）"></a>4. 归并排序（重要）</h3><p><img src="/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/guibing1.png" alt><br><img src="/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/guibing1.png" alt></p>
<h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   将已有序的子序列合并，得到完全有序的序列；</span></span><br><span class="line"><span class="comment">   即先使每个子序列有序，再使子序列段间有序。</span></span><br><span class="line"><span class="comment">   若将两个有序表合并成一个有序表，称为二路归并。</span></span><br><span class="line"><span class="comment">   归并排序是一种稳定的排序方法。</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">1、确定数组的大小，以及输入数组中的元素值；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、将输入的数组进行分组归并；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、将整个数组分成左右两个数组，左右两个数组再向下分，直至子数组的元素少于2个时，子数组将停止分割；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4、当左右子数组不能再分割，也是都是一个元素时，比较他们的大小，进行排序合并；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5、再排序合并上一级子数组为两个元素的数组，接着再排序合并上一级子数组为四个元素的数组；</span></span><br><span class="line"><span class="comment">直至到排序合并刚开始的两个子数组，最后成为排好序的数组；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定排序，平均 O(nlogn)，最好 O(nlogn), 最差 O(nlogn),辅助空间 O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp[high+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>; <span class="comment">//临时数组指针</span></span><br><span class="line">        <span class="type">int</span> l=low;<span class="comment">//左序列指针</span></span><br><span class="line">        <span class="type">int</span> r=mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid&amp;&amp;r&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]&lt;nums[r])</span><br><span class="line">                temp[i++]=nums[l++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[i++]=nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid) <span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[i++]=nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=high) <span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[i++]=nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将temp中的元素全部拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[low++]=temp[i++];</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">mergesort</span>(nums,low,mid);  <span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">            <span class="built_in">mergesort</span>(nums,mid+<span class="number">1</span>,high); <span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">            <span class="built_in">merge</span>(nums,low,high); <span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-快速排序（重要）"><a href="#5-快速排序（重要）" class="headerlink" title="5. 快速排序（重要）"></a>5. 快速排序（重要）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt></p>
<h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 从数列中挑出一个元素作为基准数。</span></span><br><span class="line"><span class="comment">    2. 重新排序数列，将比基准数大的放到右边，小于或等于它的数都放到左边。</span></span><br><span class="line"><span class="comment">    3. 再对左右区间递归执行第二步，直至各区间只有一个数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定排序，平均 O(nlogn)，最好 O(nlogn), 最差 O(n**2),辅助空间 O(logn)</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">Paritition</span> <span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="type">int</span> pivot = nums[low];</span><br><span class="line">   <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= pivot)</span><br><span class="line">     &#123;</span><br><span class="line">       --high;</span><br><span class="line">     &#125;</span><br><span class="line">     nums[low] = nums[high];</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt; pivot)</span><br><span class="line">     &#123;</span><br><span class="line">       ++low;</span><br><span class="line">     &#125;</span><br><span class="line">     nums[high] = nums[low];</span><br><span class="line">   &#125;</span><br><span class="line">   nums[low] = pivot;</span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> <span class="comment">//快排母函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">int</span> i = <span class="built_in">Paritition</span>(nums, low, high);</span><br><span class="line">     <span class="built_in">QuickSort</span>(nums, low, i - <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">QuickSort</span>(nums, i + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>精简版</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> l = low, r = high, pivot = nums[low];</span><br><span class="line">		<span class="keyword">while</span>(l&lt;r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r] &gt;=pivot) <span class="comment">// 从右向左找第一个小于基准的数</span></span><br><span class="line">			&#123;</span><br><span class="line">			    r--;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[l] = nums[r];</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l] &lt; pivot) <span class="comment">// 从左向右找第一个大于等于基准的数</span></span><br><span class="line">			&#123;</span><br><span class="line">			    l++;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[r] = nums[l];</span><br><span class="line">		&#125;</span><br><span class="line">		nums[l] = pivot;</span><br><span class="line">		<span class="built_in">quick_sort</span>(nums, low, l<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">quick_sort</span>(nums, l+<span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-堆排序（重要）"><a href="#6-堆排序（重要）" class="headerlink" title="6. 堆排序（重要）"></a>6. 堆排序（重要）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt></p>
<h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">堆排序的基本思想是：将待排序序列构造成一个大顶堆，</span></span><br><span class="line"><span class="comment">此时，整个序列的最大值就是堆顶的根节点。将其与末</span></span><br><span class="line"><span class="comment">尾元素进行交换，此时末尾就为最大值。然后将剩余n-1</span></span><br><span class="line"><span class="comment">个元素重新构造成一个堆，这样会得到n个元素的次小值。</span></span><br><span class="line"><span class="comment">如此反复执行，便能得到一个有序序列了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  1.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　2.将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与</span></span><br><span class="line"><span class="comment">  当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定排序，平均 O(nlogn)，最好 O(nlogn), 最差 O(nlogn),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjustHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> i,<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = nums[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; nums[k]&lt;nums[k+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[k] &gt;temp)</span><br><span class="line">        <span class="comment">//如果子节点大于父节点，将子节点值赋给父节点</span></span><br><span class="line">        <span class="comment">//（不用进行交换）</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = nums[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[i] = temp;    <span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">        <span class="built_in">adjustHeap</span>(nums,i,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>],nums[j]);</span><br><span class="line">        <span class="comment">//将堆顶元素(最大值)与末尾元素进行交换，</span></span><br><span class="line">        <span class="comment">//将最大值交换到数组的最后位置保存</span></span><br><span class="line">        <span class="built_in">adjustHeap</span>(nums,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解排序算法(三)之堆排序</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序非递归实现</title>
    <url>/2020/04/24/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>为什么要实现快排非递归算法，不是已经有了递归算法了吗？</p>
<p>数据特别大时，快排递归会耗尽空间。因为计算机在实现递归时会调用系统的堆栈，这很消耗计算机内存资源，所以采用非递归算法的本质就是手动模拟系统的堆栈调用来降低computer资源的消耗。<br><span id="more"></span></p>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>非递归实现快排本质就是用栈实现递归的操作。具体步骤如下：</p>
<ol>
<li><p>申请一个栈，存放排序数组的起始位置和终点位置。</p>
</li>
<li><p>将整个数组的起始位置start和终点位置end进栈</p>
</li>
<li><p>出栈数据，对出栈的数据进行排序，查找基准数据所在最终的位置pivot。</p>
</li>
<li><p>判断起始位置start是否小于基准位置pivot-1，如果小于则将起始位置和pivot-1为终点位置进栈</p>
</li>
<li><p>判断基准位置pivot+1 是否小于终点位置end,如果小于则将 pivot+1作为起始位置，end作为终点位置进栈</p>
</li>
<li><p>判断栈是否为空，如果不为空则重复第三步，否则退出操作。</p>
</li>
</ol>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//划分算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; nums, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = nums[low];</span><br><span class="line">    <span class="keyword">while</span> (low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[high]&gt;=pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = nums[high]; <span class="comment">//将比枢轴值小的元素移到左边</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[low]&lt;pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[high] = nums[low]; <span class="comment">//将比枢轴值大的元素移到右边</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums[low] = pivot;  <span class="comment">//将枢轴值元素置于最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归快排</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//手动利用栈来存储每次分块快排的起始点</span></span><br><span class="line">	<span class="comment">//栈非空时循环获取中轴入栈</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (start&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">Partition</span>(nums,start,end);</span><br><span class="line">        <span class="keyword">if</span> (pivot<span class="number">-1</span>&gt;start)  <span class="comment">//确保左分区存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将左分区端点入栈</span></span><br><span class="line">            s.<span class="built_in">push</span>(start);</span><br><span class="line">            s.<span class="built_in">push</span>(pivot<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pivot+<span class="number">1</span>&lt;end) <span class="comment">//确保右分区存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将右分区端点入栈</span></span><br><span class="line">            s.<span class="built_in">push</span>(pivot+<span class="number">1</span>);</span><br><span class="line">            s.<span class="built_in">push</span>(end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//得到其中一个分区的左右边界</span></span><br><span class="line">            <span class="type">int</span> r = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> l = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            pivot = <span class="built_in">Partition</span>(nums,l,r);</span><br><span class="line">            <span class="keyword">if</span>(pivot<span class="number">-1</span>&gt;l)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(l);</span><br><span class="line">                s.<span class="built_in">push</span>(pivot<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pivot+<span class="number">1</span>&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(pivot+<span class="number">1</span>);</span><br><span class="line">                s.<span class="built_in">push</span>(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">quickSort</span>(nums,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num: nums)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2020/04/24/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/1.png" alt></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列的区别及应用</title>
    <url>/2020/05/30/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>经常会用到栈和队列，也是比较常问到的一个问题，就系统整理一下。</p>
<p><strong>栈（Stack）和队列（Queue）是两种操作受限的线性表。</strong><br><span id="more"></span><br>（线性表：线性表是一种线性结构，它是一个含有n≥0个结点的有限序列，同一个线性表中的数据元素数据类型相同并且满足“一对一”的逻辑关系。</p>
<p>“一对一”的逻辑关系指的是对于其中的结点，有且仅有一个开始结点没有前驱但有一个后继结点，有且仅有一个终端结点没有后继但有一个前驱结点，其它的结点都有且仅有一个前驱和一个后继结点。）</p>
<p>这种受限表现在：栈的插入和删除操作只允许在表的尾端进行（在栈中成为“栈顶”），满足“先进后出”原则；队列只允许在表尾插入数据元素，在表头删除数据元素,满足“先进先出”原则。</p>
<p><strong>栈与队列的相同点：</strong></p>
<ol>
<li><p>都是线性结构。</p>
</li>
<li><p>插入操作都是限定在表尾进行。</p>
</li>
<li><p>都可以通过顺序结构和链式结构实现。</p>
</li>
<li><p>插入与删除的时间复杂度都是O（1），在空间复杂度上两者也一样。</p>
</li>
</ol>
<p><strong>栈与队列的不同点：</strong></p>
<ol>
<li><p>删除数据元素的位置不同，栈的删除操作在表尾进行，队列的删除操作在表头进行。</p>
</li>
<li><p>应用场景不同；常见栈的应用场景包括括号问题的求解，表达式的转换和求值，函数调用和递归实现，深度优先搜索遍历等；常见的队列的应用场景包括计算机系统中各种资源的管理，消息缓冲器的管理和广度优先搜索遍历等。</p>
</li>
<li><p>顺序栈能够实现多栈空间共享，而顺序队列不能。</p>
</li>
</ol>
<p>STL中stack和queue的实现</p>
<p>queue和stack的实现都是默认以deque为底层实现的，这是他们两个的一个相同点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = deque&lt;T&gt; &gt; <span class="keyword">class</span> queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = deque&lt;T&gt; &gt; <span class="keyword">class</span> stack;</span><br></pre></td></tr></table></figure>
<p>上边说到的不同应用场景不同，这里稍微详细展开说一下</p>
<p><strong>栈的应用：</strong></p>
<p>1.括号匹配问题</p>
<p>判断是否是有效括号（<a href="https://leetcode-cn.com/problems/valid-parentheses/">LeetCode 20题有效括号</a>)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">      stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">      <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">if</span> (n%<span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>2.十进制表示N进制</p>
<p>十进制表示N进制的话，将十进制对N取余的结果保存在栈中，按序输出栈即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="comment">// 将余数入栈</span></span><br><span class="line">           s.<span class="built_in">push</span>(result % n);</span><br><span class="line">           result = result / n;</span><br><span class="line">           <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="comment">// 1111</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.表达式求值</p>
<p>例如：要计算 2 + 9 / 3 - 5</p>
<ul>
<li>运算数，如：2，9，3等</li>
<li>运算符号，如+，-等，而且不同运算符号优先级不一样</li>
</ul>
<p>由于运算符号优先级不同，而且运算符号位于运算数中，所以使得运算变得复杂了。使用逆波兰算法可以轻松解决。他的核心思想是将普通的中缀表达式转换为后缀表达式。</p>
<p>转换为后缀表达式的好处是：</p>
<p>去除原来表达式中的括号，因为括号只指示运算顺序，不是完成计算必须的元素。</p>
<p>使得运算顺序有规律可寻，计算机能编写出代码完成计算。虽然后缀表达式不利于人阅读，但利于计算机处理。</p>
<ul>
<li>中缀表达式：2 + 9 / 3 - 5</li>
<li>后缀表达式：2 9 3 / + 5 -</li>
</ul>
<p>后缀表达式求值</p>
<p>由于后缀表达式不需要考虑运算符的优先规则，因此求值算法就变得简单了：</p>
<ul>
<li><p>从左到右依次遍历表达式；</p>
</li>
<li><p>遇到数字就直接入栈；</p>
</li>
<li>遇到操作符就弹出两个元素，先弹出的元素放到操作符的右边，后弹出的元素放到操作符的左边（左边的运算数先入栈，因此后出），将计算得到的结果再压入栈；</li>
<li>直到整个表达式遍历完，最后弹出的栈顶元素就是表达式最终的值。</li>
</ul>
<p>以33-5+表达式为例，运行状态如下:</p>
<p><img src="/2020/05/30/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8/1.png" alt></p>
<p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">LeetCode 150题逆波兰表达式求值</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,res;</span><br><span class="line">        <span class="type">int</span> n = tokens.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;+&quot;</span>||tokens[i]==<span class="string">&quot;-&quot;</span>||tokens[i]==<span class="string">&quot;*&quot;</span>||tokens[i]==<span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> b=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">                    res=a+b;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">                    res=b-a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">                    res=a*b;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res=b/a;</span><br><span class="line">                &#125;</span><br><span class="line">                s.<span class="built_in">push</span>(res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> tmp = <span class="built_in">stoi</span>(tokens[i]);</span><br><span class="line">                s.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res=s.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>队列的应用</strong><br>1、生产者消费者模型</p>
<p>2、消息队列</p>
<p>3、排队现象</p>
<p>4、网络数据传输</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建轻量级Web服务器&lt;一&gt;</title>
    <url>/2020/05/02/%E6%90%AD%E5%BB%BA%E8%BD%BB%E9%87%8F%E7%BA%A7Web%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%B8%80/</url>
    <content><![CDATA[<h3 id="TinyWebServer"><a href="#TinyWebServer" class="headerlink" title="TinyWebServer"></a>TinyWebServer</h3><p>参考<a href="https://github.com/qinguoyi/TinyWebServer">Github</a>在Linux下搭建C++轻量级Web服务器，快速实践学习网络编程，搭建属于自己的服务器.</p>
<ul>
<li><p>使用<strong>线程池 + epoll(ET和LT均实现) + 模拟Proactor模式</strong>并发模型</p>
</li>
<li><p>使用<strong>状态机</strong>解析HTTP请求报文，支持解析GET和POST请求</p>
</li>
<li><p>通过访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件</p>
</li>
<li><p>实现<strong>同步/异步日志系统</strong>，记录服务器运行状态</p>
</li>
<li><p>经Webbench压力测试可以实现<strong>上万的并发连接</strong>数据交换</p>
<span id="more"></span>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3></li>
<li><p>项目框架主要分为I/O处理单元、逻辑处理单元和存储单元三个模块</p>
<ul>
<li><p>I/O处理单元和逻辑处理单元对应<strong>半同步/半反应堆线程池</strong></p>
</li>
<li><p>逻辑处理单元和存储单元对应<strong>数据库连接池和日志系统</strong></p>
</li>
</ul>
</li>
<li><p><strong>半同步/半反应堆线程池</strong>将web端和服务器端建立通信</p>
<ul>
<li><p>实现http请求报文的处理与响应</p>
</li>
<li><p>定时器完成非活动连接的处理</p>
</li>
</ul>
</li>
<li><p><strong>数据库连接池</strong>避免频繁访问数据库，实现登录和校验功能</p>
</li>
<li><p><strong>日志系统</strong>实现同步和异步两种方式记录服务器运行状态</p>
</li>
</ul>
<p><img src="/2020/05/02/%E6%90%AD%E5%BB%BA%E8%BD%BB%E9%87%8F%E7%BA%A7Web%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%B8%80/1.jpeg" alt></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>WebServer</tag>
      </tags>
  </entry>
  <entry>
    <title>最大正整数</title>
    <url>/2020/08/31/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>记录自己一道没有做出来的面试题。</p>
<p>数组中存储了一堆小于10的非负整数，整个数组从左到右代表一个正整数（如数组[0, 1, 3, 2]代表正整数132）。现给出一个正整数K，要求经过K次数组相邻位置元素交换（必须完成K次交换），使得这个数组代表的数字最大。<br>例如,<br>int array[] = {0, 1, 3, 2}, K = 1，则经过1次交换后，数组所能代表的最大值为1032；<br>int array[] = {0, 1, 3, 2}, K = 2，则经过2次交换后，数组所能代表的最大值为3012。</p>
<span id="more"></span>
<p><strong>输入描述:</strong></p>
<p>首先，输入一个正整数T，表示接收T组测试用例；</p>
<p>此后，输入T组测试用例，其中每组测试用例包含如下内容：</p>
<p>输入1：一个正整数K，表示在当前测试用例中，可以对数组进行K次相邻元素间的位置交换；</p>
<p>输入2：一个正整数N，表示当前用例包含数组的长度；</p>
<p>输入3：N个数组元素，所有元素都是小于10的非负整数；</p>
<p><strong>输出描述:</strong></p>
<p>输出共N行，对应于N个用例的输出：</p>
<p>每行输出为一个数组，数组元素之间用一个空格隔开，要求每行输出前后均无多余空格。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>k次交换，如果k无穷大（其实大于n*(n-1) / 2 就会已经排好序了），最后数组应该是一个降序的排序。</p>
<p>k次交换，i从0开始，就是可以最远将nums[i+k]的元素交换到nums[i], 所以就是首先将0-k之间最大的元素交换到开头<br>，如果还有剩余交换次数就继续交换，直到交换次数用完。时间复杂度为(n^2)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> k, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">findMax</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (k &gt; n * (n - <span class="number">1</span>) / <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">sort</span>(a, a+n);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="type">int</span> num = a[i];</span><br><span class="line">        <span class="type">int</span> idx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n &amp;&amp; j &lt; i + k + <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="comment">// 记录到k之间最大的元素，以及下标</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; num) {</span><br><span class="line">                num = a[j];</span><br><span class="line">                idx = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = idx; t &gt; i; t--) {</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">int</span> temp = a[t];</span><br><span class="line">                a[t] = a[t<span class="number">-1</span>];</span><br><span class="line">                a[t<span class="number">-1</span>] = temp;</span><br><span class="line">                k--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) {</span><br><span class="line">        cin &gt;&gt; k &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">findMax</span>(a, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            cout &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线程与进程的区别及其通信方式</title>
    <url>/2020/04/10/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%85%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>线程：是操作系统能够进行运算调度的最小单位。是进程中的一个执行流程，一个进程中可以运行多个线程。</p>
<p>进程：是操作系统中资源分配的基本单元，一个执行中的程序的实例。<br><span id="more"></span></p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li>进程是操作系统中资源分配的基本单元，是运行中的程序，线程是是操作系统能够进行运算调度的最小单位，是进程的一个执行流程</li>
<li><strong>地址空间和其它资源：</strong> 进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li>
<li><strong>调度和切换：</strong> 线程上下文切换比进程上下文切换要快得多。</li>
<li><strong>通信：</strong> 正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。</li>
</ul>
<p><strong>补充：</strong></p>
<p>线程一般是<code>New</code>出来的，而进程一般<code>fork</code>某个母体而产生的。</p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>在 linux 下进程间通信的几种主要手段简介：</p>
<ol>
<li><p>管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p>
</li>
<li><p>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；</p>
</li>
<li><p>消息队列（Message）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
</li>
<li><p>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</p>
</li>
<li><p>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</p>
</li>
<li><p>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</p>
</li>
</ol>
<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><h3 id="进程与线程的使用选择"><a href="#进程与线程的使用选择" class="headerlink" title="进程与线程的使用选择"></a>进程与线程的使用选择</h3><p>进程与线程的选择取决以下几点：</p>
<p>1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。</p>
<p>2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应</p>
<p>3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；</p>
<p>4、并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求；</p>
<p>5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟地址、逻辑地址、物理地址区别与联系</title>
    <url>/2020/04/07/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E3%80%81%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>泵站机组故障诊断</title>
    <url>/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/</url>
    <content><![CDATA[<h3 id="故障诊断系统概述"><a href="#故障诊断系统概述" class="headerlink" title="故障诊断系统概述"></a>故障诊断系统概述</h3><p>研究的基于自动化机器学习的故障诊断系统既具有故障诊断算法训练功能，也具有算法部署功能。它会读取故障数据，进行特征提取，然后使用自动化机器学习方法找出最优机器学习流程，并将该流程训练好保存下来，最后使用Web服务器对故障诊断算法进行部署。所研究的故障诊断系统具有高度自动化、功能拓展方便、模型更新方便的特点。<br><span id="more"></span><br>本系统由以下几个子部分构成：</p>
<p>（1）系统运行日志。日志是对系统运行状态的记录，它可以帮助检验系统运行是否正常，在出现异常情况时可以帮助使用者快速查找错误。日志的记录是分级别的，一般分为DEBUG、INFO、WARNING、ERROR、CRITICAL 五个级别，这五个级别的严重程度越来越高。</p>
<p>（2）系统配置文件。系统配置文件本质上是文本文件，通过配套的文本解析方法可以提取出变量名及其对应的设定值。系统在主功能运行前读取配置文件，从而设定程序的运行模式或训练任务，达到不改变代码就可以改变程序运行的效果。</p>
<p>（3）故障样本数据库。所研究的故障诊断算法是基于机器学习的，而机器学习方法是由数据驱动的，因此一个故障样本数据库是必要的。由于本文研究对象泵站机组具有型号多、运行工况复杂的特点，故障样本数据库在设计的时候充分考虑了这些特点。</p>
<p>（4）样本平衡性检验。在用数据进行训练之前，应该对样本平衡性进行检验，样本数量比较少的做一些特殊处理，样本数量太少的应从训练集里予以剔除，更失衡严重的就终止本次训练，等待数据收集完毕后再开始。</p>
<p>（5）故障特征提取。从故障数据库获得的数据是传感器数据，而传感器数据是无法直接作为机器学习算法输入的。为了提高故障诊断算法的效果，应该先对数据库中传感器数据使用快速傅里叶变换进行预处理。</p>
<p>（6）使用TPOT进行模型训练。采用基于遗传算法的自动化机器学习方法TPOT是使用遗传算法对特征归一化、特征选择、模型和参数选择等环节组成的机器学习流程进行自动构建并寻优的方法。</p>
<p>（7）故障诊断模型工程部署。所研究的故障诊断模型工程部署方法是基于Python轻型Web服务器框架Flask通过HTTP协议实现Python环境与Java环境的交互。</p>
<p>故障诊断系统工作流程图如下所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/liucheng1.png" alt></p>
<h3 id="故障诊断系统研究"><a href="#故障诊断系统研究" class="headerlink" title="故障诊断系统研究"></a>故障诊断系统研究</h3><h4 id="故障数据库设计规范"><a href="#故障数据库设计规范" class="headerlink" title="故障数据库设计规范"></a>故障数据库设计规范</h4><p>在泵站机组型号或运行工况不一样的情况下，虽然机组发生了同一种故障类型，但同样位置的传感器数据会有所不同，这就导致提取的特征也有点不同。因此，在故障数据存储时必须要体现出故障样本的来源背景，这里用机组型号和运行工况来表示。</p>
<p>以机组某个部件有两个传感器为例设计的故障数据库规范如下表所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/shujuku1.png" alt></p>
<h4 id="故障样本不平衡处理"><a href="#故障样本不平衡处理" class="headerlink" title="故障样本不平衡处理"></a>故障样本不平衡处理</h4><h5 id="样本不平衡下的训练方法"><a href="#样本不平衡下的训练方法" class="headerlink" title="样本不平衡下的训练方法"></a>样本不平衡下的训练方法</h5><p>针对样本不平衡下的训练数据集采用简单易行的调整类的权重方法，该方法是在误差函数里添加类别权重，以达到误差平衡，带权重的误差函数为：</p>
<script type="math/tex; mode=display">
\text { error }=\frac{\sum_{i=1}^{n} w_{i}\left(y_{i}^{\prime}-y_{i}\right)^{2}}{n}</script><p>其中：</p>
<p>$𝑛$ 代表样本总数；</p>
<p>$𝑤_𝑖$ 代表第$i$个样本所在类别的权重；</p>
<p>$y_{i}^{\prime}$代表第$i$个样本的预测结果；</p>
<p>$𝑦_𝑖$代表第$i$个样本的实际结果。</p>
<h5 id="样本不平衡下的评估方法"><a href="#样本不平衡下的评估方法" class="headerlink" title="样本不平衡下的评估方法"></a>样本不平衡下的评估方法</h5><p>在统计和机器学习中，常常用AUC 来评估二分类模型的性能（多分类也可以使用，作为二分类的拓展）。AUC 的全称是Area under the curve，即曲线下的面积。通常这里的曲线指的是受试者操作曲线(Receiver Operating Characteristic,ROC)。相比于准确率、召回率、F1 值等依赖于判决阈值的评估指标，AUC则没有这个问题。</p>
<p>ROC 曲线：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/ROC.jpg" alt></p>
<p>AUC值为ROC 曲线下方所覆盖的区域面积，AUC越大, 说明曲线越靠近(0,1) 这个点，越接近理想曲线，分类效果自然更好。</p>
<p>AUC指标为什么可以作为样本不平衡情况下的模型评价指标？因为当用来验证算法效果的数据集中的样本比例发生变化时，ROC曲线的形状能够保持不变，而AUC是ROC曲线的下方面积，所以当模型一定时，AUC的值也不随正负样本分布的变化而变化，所以能够作为不平衡数据集的模型评价指标。</p>
<h4 id="故障特征提取"><a href="#故障特征提取" class="headerlink" title="故障特征提取"></a>故障特征提取</h4><p>泵轴的常见故障有油膜涡动、接触摩擦、油膜振荡、转子不平衡和转子不对中，这些故障都可以体现在泵轴的振动信号里，通常采用泵轴的摆度数值作为它的振动信号。通过利用FFT快速傅里叶变换将时域的振动信号转换为频域的能量分布。</p>
<p>下面对泵轴的转子不平衡故障数据进行特征提取实验，介绍如下：</p>
<p>（1）数据来源传感器：泵轴$Y$方向摆度信号</p>
<p>（2）数据滤波方法与窗函数：小波阈值去噪、汉宁窗</p>
<p>（3）基频$𝐹<em>0$、采样频率$𝐹</em>𝑠$和采样点数$𝑁$：$20Hz$、$2048Hz$、$2048$由上面几个数据，可得到下面几个频谱分析需要的参数：</p>
<p>（a）最高有效频率𝐹𝑚：𝐹𝑚 = 𝐹𝑠/2.56=800Hz</p>
<p>（b）频率分辨率𝛥𝐹 ：𝛥𝐹 = 𝐹𝑠/𝑁=2048/2048=1Hz</p>
<p>（c）谱线数𝑀：𝑀 = 𝑁/2.56=2048/2.56=800</p>
<p>下图为转子不平衡故障特征提取过程。</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/tezheng.jpg" alt></p>
<p>图中共有三个子图，其中最上面的图是泵轴摆度信号的时域图，表现出<br>了周期性，中间图是对摆度信号的时域数据作快速傅立叶变换得到的频谱，最下面图是从频谱提取的特征向量。</p>
<h4 id="自动化机器学习工具TPOT"><a href="#自动化机器学习工具TPOT" class="headerlink" title="自动化机器学习工具TPOT"></a>自动化机器学习工具TPOT</h4><p><a href="/TPOT——一个自动化的Python机器学习工具.md">此节具体参考这里</a></p>
<h4 id="诊断算法的部署"><a href="#诊断算法的部署" class="headerlink" title="诊断算法的部署"></a>诊断算法的部署</h4><p>设置Web服务器，通过HTTP协议进行调用。生产环境软件通过网络IP、端口将需要诊断的数据传递给Web服务器。Web服务器接受到数据后会进行诊断服务，在诊断结束后，诊断结果会原路返回给服务调用者。<br>诊断数据与Web 服务器之间使用HTTP协议进行通信，HTTP协议下有GET、POST、PUT 和DELETE 等方法，因为通信过程中需要传输传感器数据，所以这里使用可携带数据体的POST方法。</p>
<p>在故障诊断的各个环节中，诊断算法具有“一次加载、多次使用”的特点，而特征提取、算法调用等步骤随着传输数据的不同而采用不同的方法，所以故障诊断Web服务器在实现时应该按照这样的方式：加载诊断算法在创建故障诊断Web服务器时进行，数据获取、特征提取、调用诊断算法和诊断结果返回这些步骤在POST方法中实现。</p>
<h3 id="故障诊断系统具体实现"><a href="#故障诊断系统具体实现" class="headerlink" title="故障诊断系统具体实现"></a>故障诊断系统具体实现</h3><h4 id="系统开发环境"><a href="#系统开发环境" class="headerlink" title="系统开发环境"></a>系统开发环境</h4><p>故障诊断系统是在Windows 10上使用Python编程语言开发的，<br>其中数据库使用SQL Server，日志管理使用Logging，配置文件解析加载使用Configparser，频域分析工具包使用Scipy，矩阵数据处理使用Pandas 和Numpy，自动化机器学习工具使用TPOT，模型序列化保存工具使用Pickle，Web 应用框架使用Flask。</p>
<p>下表是详细的故障诊断系统开发环境。</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/environment.png" alt></p>
<h4 id="系统功能模块的实现"><a href="#系统功能模块的实现" class="headerlink" title="系统功能模块的实现"></a>系统功能模块的实现</h4><h5 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h5><p>系统日志管理工具使用Logging 模块实现，具体的是使用了Logging 下的logger 对象，使用logger 对象可以避免多个程序使用同一个日志文件时产生重复记录的问题。系统日志管理工具被打包成一个独立的文件，方便不同任务的复用。<a href="https://cuiqingcai.com/6080.html">logging模块的基本用法</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_logger</span>():</span><br><span class="line">    logger = logging.getLogger(__name__)</span><br><span class="line">    logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    stream_handler = logging.StreamHandler()</span><br><span class="line">    stream_handler.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    file_handler = logging.FileHandler(filename=<span class="string">&#x27;日志.log&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    file_handler.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">    formatter = logging.Formatter(fmt=<span class="string">&#x27;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    stream_handler.setFormatter(formatter)</span><br><span class="line">    file_handler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">    logger.addHandler(stream_handler)</span><br><span class="line">    logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logger</span><br></pre></td></tr></table></figure>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>配置文件的格式有ini、toml、yaml、json 和xml 等，其中ini格式的最为简单直观，这里使用的配置文件就是ini格式.部分配置如下图所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/ini.jpg" alt></p>
<h4 id="建立机组故障数据库"><a href="#建立机组故障数据库" class="headerlink" title="建立机组故障数据库"></a>建立机组故障数据库</h4><p>利用数据库SQL Server 2017 与数据库可视化管理工具Navicat Premium进行搭建，首先参考<a href="https://www.cnblogs.com/ios9/p/9527939.html">Win10 SQL Server 2017安装</a>，利用Navicat进行创建一个Faults数据库，并在Faults数据库中创建Rotor表如图所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan2.png" alt></p>
<p>然后根据数据库设计规范，在表中创建相对应的字段。如图所示:</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan.png" alt></p>
<p><strong>注意：</strong> SQL Server 2017不支持数组形式，这里采用将数组转化为字符串,将他们拼接起来当做文本写入。</p>
<p>字段类型在设置的时候注意采用nvarchar(max)的类型，具体如下图：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan3.png" alt></p>
<p><a href="https://data.mendeley.com/datasets/p9bsmj4xwg/1/files/9ecd3bf8-6ed0-452b-8c84-05a4833ac803">Rotor数据</a>, 数据是.mat文件，利用Python处理数据后，写入数据库CGQ1这一列中，最终如图所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan4.png" alt></p>
<h5 id="平衡性检验"><a href="#平衡性检验" class="headerlink" title="平衡性检验"></a>平衡性检验</h5><p>平衡性检验工具的实现是先使用Pandas 筛选数据，然后使用Collections模块的Counter 工具进行统计。</p>
<h5 id="故障特征提取-1"><a href="#故障特征提取-1" class="headerlink" title="故障特征提取"></a>故障特征提取</h5><p>故障特征提取工具以独立的代码文件形式进行存放，该工具是多个特征提取函数的集合，如果想使用哪个特征提取函数，只需要在配置文件里指定函数名，如果想使用的函数不存在，模仿已有的函数编辑添加即可。通过这样的设计，无需更改主函数就可改变系统功能。特征提取函数代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transfer</span>(<span class="params">string</span>):</span><br><span class="line">    string_arr = string.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="comment">#print(string_arr)</span></span><br><span class="line">    float_arr = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, string_arr))</span><br><span class="line">    <span class="keyword">return</span> float_arr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rotor_simple</span>(<span class="params">arr, logger, conf=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(arr,<span class="built_in">dict</span>):<span class="comment">#如果数据来源于web,  isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。</span></span><br><span class="line">        arr = trans(arr)</span><br><span class="line">    <span class="comment">#print(arr[1])</span></span><br><span class="line">    rotation_frequency = <span class="built_in">round</span>(<span class="built_in">float</span>(arr[<span class="number">0</span>])/<span class="number">60</span>) <span class="comment"># 旋转频率</span></span><br><span class="line">    sample_frequency = <span class="built_in">int</span>(arr[<span class="number">1</span>]) <span class="comment"># 采样频率</span></span><br><span class="line">    useful_bandwidth = <span class="built_in">int</span>(sample_frequency/<span class="number">2.56</span>) <span class="comment"># 有效带宽</span></span><br><span class="line">    <span class="keyword">if</span> useful_bandwidth&lt;rotation_frequency*<span class="number">6</span>:</span><br><span class="line">        logger.warning(<span class="string">&#x27;数据采样频率过低！数据作废&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    sensor_data = transfer(arr[<span class="number">3</span>]) <span class="comment"># 将逗号拼接的传感器数据变成数组</span></span><br><span class="line">    data_length = <span class="built_in">len</span>(sensor_data) <span class="comment"># 采样长度</span></span><br><span class="line">    sample_time = data_length/sample_frequency <span class="comment"># 采样时间</span></span><br><span class="line">    frequency_resolution = <span class="number">1</span>/sample_time <span class="comment"># 频率分辨率</span></span><br><span class="line">    <span class="keyword">if</span> (rotation_frequency&lt;<span class="number">10</span> <span class="keyword">and</span> frequency_resolution&gt;<span class="number">0.1</span>) <span class="keyword">or</span> sample_time&lt;<span class="number">1</span>:</span><br><span class="line">        logger.warning(<span class="string">&#x27;采样时间过短！数据作废&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    f0_candidates = [rotation_frequency-<span class="number">2</span>,rotation_frequency-<span class="number">1</span>,rotation_frequency,rotation_frequency+<span class="number">1</span>,rotation_frequency+<span class="number">2</span>] <span class="comment"># 基频</span></span><br><span class="line">    spectrum = <span class="built_in">abs</span>(fft(sensor_data))[:useful_bandwidth]/<span class="built_in">len</span>(sensor_data)  <span class="comment"># 频谱</span></span><br><span class="line">    f0 = f0_candidates[spectrum[f0_candidates].argmax()]<span class="comment"># 确定基频</span></span><br><span class="line">    segments = [[<span class="number">1</span>,<span class="built_in">int</span>(<span class="number">0.40</span>*f0)],[<span class="built_in">int</span>(<span class="number">0.40</span>*f0),<span class="built_in">int</span>(<span class="number">0.50</span>*f0)],</span><br><span class="line">                [<span class="built_in">int</span>(<span class="number">0.5</span>*f0)],[<span class="built_in">int</span>(<span class="number">0.50</span>*f0)+<span class="number">1</span>,<span class="built_in">int</span>(f0)],[f0],[<span class="built_in">int</span>(<span class="number">2</span>*f0)],</span><br><span class="line">                [<span class="built_in">int</span>(<span class="number">3</span>*f0),<span class="built_in">int</span>(<span class="number">5</span>*f0)+<span class="number">1</span>],[<span class="built_in">int</span>(<span class="number">6</span>*f0),useful_bandwidth]]</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> seg <span class="keyword">in</span> segments:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(seg)==<span class="number">2</span>:</span><br><span class="line">            max_value = <span class="built_in">max</span>(spectrum[seg[<span class="number">0</span>]:seg[<span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_value = spectrum[seg[<span class="number">0</span>]]</span><br><span class="line">        temp.append(max_value)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rotor</span>(<span class="params">data, useful_labels, conf, model_dir, logger</span>):</span><br><span class="line">    djzs_field_name = conf[<span class="string">&#x27;Table&#x27;</span>][<span class="string">&#x27;djzs_field_name&#x27;</span>]</span><br><span class="line">    gzlx_field_name = conf[<span class="string">&#x27;Table&#x27;</span>][<span class="string">&#x27;gzlx_field_name&#x27;</span>]</span><br><span class="line">    cypl_field_name = conf[<span class="string">&#x27;Table&#x27;</span>][<span class="string">&#x27;cypl_field_name&#x27;</span>]</span><br><span class="line">    filtered_data = data.loc[:,[djzs_field_name,cypl_field_name,gzlx_field_name,<span class="string">&#x27;CGQ1&#x27;</span>]][data[gzlx_field_name].isin(useful_labels)]</span><br><span class="line">    </span><br><span class="line">    config_for_web = &#123;<span class="string">&#x27;mission&#x27;</span>:conf[<span class="string">&#x27;Mission&#x27;</span>][<span class="string">&#x27;table&#x27;</span>],</span><br><span class="line">                      <span class="string">&#x27;label&#x27;</span>:useful_labels,</span><br><span class="line">                     <span class="string">&#x27;function_for_web&#x27;</span>:conf[<span class="string">&#x27;Mission&#x27;</span>][<span class="string">&#x27;extract_feature_function_for_web&#x27;</span>]&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(model_dir+<span class="string">&#x27;\config_for_web.json&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        json.dump(config_for_web, file, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    feature_and_label = []</span><br><span class="line">    <span class="keyword">for</span> arr <span class="keyword">in</span> filtered_data.values:</span><br><span class="line">        temp = rotor_simple(arr, logger)</span><br><span class="line">        <span class="keyword">if</span> temp != <span class="literal">None</span>:<span class="comment"># 数据有效</span></span><br><span class="line">            temp.append(useful_labels.index(arr[<span class="number">2</span>]))</span><br><span class="line">            feature_and_label.append(temp)</span><br><span class="line">    feature_and_label = np.array(feature_and_label, dtype=np.float32)</span><br><span class="line">    </span><br><span class="line">    column = [<span class="string">&#x27;feature&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(feature_and_label.shape[<span class="number">1</span>]-<span class="number">1</span>)]+[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">    df = pd.DataFrame(data=feature_and_label, columns=column)</span><br><span class="line">    df.to_csv(model_dir+<span class="string">&#x27;\\feature_and_label.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> feature_and_label</span><br></pre></td></tr></table></figure>
<h5 id="自动化机器学习"><a href="#自动化机器学习" class="headerlink" title="自动化机器学习"></a>自动化机器学习</h5><p>Python 的第三方包TPOT已经实现了基于遗传算法的自动化机器学习，通过在Python 环境中安装TPOT，并且调用相关方法即可实现自动化机器学习。部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger.info(<span class="string">&#x27;自动化机器学习初始化...&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"></span><br><span class="line">generations = <span class="built_in">int</span>(conf[<span class="string">&#x27;Tpot&#x27;</span>][<span class="string">&#x27;generations&#x27;</span>])</span><br><span class="line">population_size = <span class="built_in">int</span>(conf[<span class="string">&#x27;Tpot&#x27;</span>][<span class="string">&#x27;population_size&#x27;</span>])</span><br><span class="line">verbosity = <span class="built_in">int</span>(conf[<span class="string">&#x27;Tpot&#x27;</span>][<span class="string">&#x27;verbosity&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model = TPOTClassifier(generations=generations, population_size=population_size,  scoring=<span class="string">&#x27;f1_macro&#x27;</span>, cv=<span class="number">5</span>, n_jobs=<span class="number">1</span>, verbosity=verbosity)</span><br><span class="line">feature = feature_and_label[:,:-<span class="number">1</span>]</span><br><span class="line">label = feature_and_label[:,-<span class="number">1</span>]</span><br><span class="line">logger.info(<span class="string">&#x27;初始化完毕，开始寻找最优机器学习流程...&#x27;</span>)</span><br><span class="line">model.fit(feature, label)</span><br><span class="line">logger.info(<span class="string">&#x27;寻优结束，开始保存最优机器学习流程...&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line">joblib.dump(model.fitted_pipeline_, model_dir+<span class="string">&#x27;\pipeline.pkl&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;保存成功，训练结束！&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="故障诊断系统部署"><a href="#故障诊断系统部署" class="headerlink" title="故障诊断系统部署"></a>故障诊断系统部署</h5><p>利用Python轻型Web框架来进行部署构建故障诊断Web服务器。加载诊断算法和实现HTTP的POST方法。、</p>
<p>加载诊断算法并创建Web服务器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">function_for_web = &#123;&#125;</span><br><span class="line">pipeline = &#123;&#125;</span><br><span class="line">label = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> model_dirs:</span><br><span class="line">    logger.info(<span class="string">&#x27;正在读取web配置文件...&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(each+<span class="string">&#x27;\config_for_web.json&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            config_for_web = json.load(file)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        logger.error(<span class="string">&#x27;读取配置文件&#123;&#125;失败！&#x27;</span>.<span class="built_in">format</span>(each+<span class="string">&#x27;\config.ini&#x27;</span>), exc_info=<span class="literal">True</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    logger.info(<span class="string">&#x27;web配置文件读取完成&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    mission = config_for_web[<span class="string">&#x27;mission&#x27;</span>]</span><br><span class="line">    function_for_web[mission] = config_for_web[<span class="string">&#x27;function_for_web&#x27;</span>]</span><br><span class="line">    pipeline[mission] = joblib.load(each+<span class="string">&#x27;\pipeline.pkl&#x27;</span>)</span><br><span class="line">    label[mission] = config_for_web[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">5050</span>)</span><br></pre></td></tr></table></figure>
<p>POST方法实现<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>,methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">diagnose</span>():</span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    all_data = request.json</span><br><span class="line">    missions = all_data.keys()</span><br><span class="line"><span class="comment">#     logger.info(str(missions))</span></span><br><span class="line">    <span class="keyword">for</span> mission <span class="keyword">in</span> missions:</span><br><span class="line">        <span class="built_in">exec</span>(<span class="string">&#x27;from extract_features import &#123;0&#125; as extract_function&#x27;</span>.<span class="built_in">format</span>(function_for_web[mission]), <span class="built_in">globals</span>())</span><br><span class="line">        data = all_data[mission]</span><br><span class="line">        feature = extract_function(data, logger, conf)<span class="comment"># feature is a list</span></span><br><span class="line">        proba = pipeline[mission].predict_proba(np.array(feature, np.float32).reshape(<span class="number">1</span>, -<span class="number">1</span>))[<span class="number">0</span>]</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(proba):</span><br><span class="line">            result[label[mission][i]] = <span class="string">&#x27;%.1f&#x27;</span>%<span class="built_in">round</span>(<span class="built_in">float</span>(v)*<span class="number">100</span>,<span class="number">1</span>)</span><br><span class="line">        results[mission] = result</span><br><span class="line"><span class="comment">#     print(results)</span></span><br><span class="line">    <span class="keyword">return</span> json.dumps(results, ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></p>
<h5 id="故障诊断系统测试"><a href="#故障诊断系统测试" class="headerlink" title="故障诊断系统测试"></a>故障诊断系统测试</h5><p>使用泵轴故障数据（数据类别为正常、转子不对中、转子不平衡、接触摩擦样本各45 个，来源工况单一）来简单测试一下所实现故障诊断系统，测试结果下图所示，横坐标代表机器学习流程组成的种群代数，纵坐标代表每代种群中最优机器学习流程的AUC评分。</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/res.jpg" alt></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>语音识别</title>
    <url>/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>整个语音识别系统主要构成有四个部分：语音信号处理和特征的提取模块；语音识别的声学模型；语音识别的语言模型；语音识别的解码和搜索部分。系统流程图如下图所示：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/1.png" alt></p>
<span id="more"></span>
<p>整个语音识别的过程可以用贝叶斯理论来描述，假设输入的音频序列为$O={o<em>{1}, o</em>{2}, \cdots, o<em>{n}}$，输出为文本序列为$W={w</em>{1}, w<em>{2}, \cdots, w</em>{n}}$。目的是构建一个模型，使得$\prod<em>{n} P\left(W</em>{n} | O_{n}\right)$最大，也就是训练集中n个样本的后验概率最大。单独拿出一个样本的后验概率使用贝叶斯公式可以得到：</p>
<script type="math/tex; mode=display">P(W | O)=\frac{P(O | W) * P(W)}{P(O)}</script><p>进一步可得:</p>
<script type="math/tex; mode=display">W^{*}=\operatorname{argmax}_{W} P(O | W) * P(W)</script><p>这里$P(W)$是输出词序列的概率，用语言模型来刻画，$P(O | W)$为似然概率，使用声学模型来表达。</p>
<h3 id="数据集构建"><a href="#数据集构建" class="headerlink" title="数据集构建"></a>数据集构建</h3><p>语音数据构建主要分为两种，一是公开数据集—&gt;日常对话，二是特定数据集—&gt;控制命令。</p>
<p>所搜集的公开语音数据集是<a href="http://www.openslr.org/18/">THCHS30</a>、<a href="http://cn-mirror.openslr.org/resources/38/ST-CMDS-20170001_1-OS.tar.gz">ST-CMDS</a>、<a href="http://cn-mirror.openslr.org/resources/33/data_aishell.tgz">AIShell</a>等数据集，这几个数据集是中文语音数据集，基本数据格式如下图所示:</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/2.png" alt></p>
<p>基本信息如下：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/3.png" alt></p>
<p>针对实际的工业控制命令，我们进行专门的语音采集和录制。环境是和实际的泵站控制室一致，安静、近场。这里使用单粒麦克风进行录制，录制的格式与上边格式一致。</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/4.png" alt></p>
<h3 id="语音信号预处理"><a href="#语音信号预处理" class="headerlink" title="语音信号预处理"></a>语音信号预处理</h3><p>语音信号预处理是为了将原始语音信号转换成CNN网络输入的语谱图。CNN的输入层是200维的特征值序列。输出拼音的表示大小是1422，即1421个拼音+1个空白块。预测结果是返回语音识别后的拼音符号列表。</p>
<p>语音信号的预处理过程用到的技术是：预加重（pre-emphasis）、<br>分帧（enframing）、加窗（windowing)</p>
<h4 id="预加重"><a href="#预加重" class="headerlink" title="预加重"></a>预加重</h4><p>预加重可以使得语音信号的频谱信号分布更加均衡。预加重一般是用<br>60db/octave数字滤波器频率特性完成的。过滤器公式给出：</p>
<script type="math/tex; mode=display">H(z)=1-u z^{-1}</script><p>其中$u$是预加重系数。</p>
<h4 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a>分帧</h4><p>使用预先设计好的窗函数处理被分帧分成的多个小片段。通过这种方法在一定程度上解决语音信号帧信号之间的不连续性问题。每一个小段作为语音信的单位，称为帧（frame）。以帧为单位可以分析语音信号的短时特性，从而进一步进行频谱等处理。分帧一般相邻帧之间有交叉重叠，交叉部分叫做帧移，帧移一般定为帧长度的一半。</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/5.png" alt></p>
<h4 id="加窗"><a href="#加窗" class="headerlink" title="加窗"></a>加窗</h4><p>对语音信号增加一个窗函数（Window Function），在语音信号的给定区间内限定为一个实数，其它部分为0。使用的是汉明窗（Hamming Window）汉明窗的时间域表达给出:</p>
<script type="math/tex; mode=display">w(n)=0.54-0.46 \cos \left(\frac{2 \pi n}{N-1}\right)</script><p>其中$𝑛$是时间，$w(n)$是窗函数。</p>
<h4 id="语谱图特征提取"><a href="#语谱图特征提取" class="headerlink" title="语谱图特征提取"></a>语谱图特征提取</h4><p>语谱图（Spectrogram）是语音处理的一个重要特征，是一种描述语音信号的各个频率成分随着时间变换的热力图。</p>
<p>语谱图包含着语音信号的重要信息，用一个二维矩阵表示。其中一个轴表示时间，另外一个轴表示频率。不同的点或者颜色代表对应语音信号能量的大小。</p>
<p>语谱图的提取过程一般包括：采样、傅立叶变换、连续拼接。如下图所示：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/6.jpg" alt></p>
<p>原始语音信号是符合数据格式的后缀是.wav 的原始语音数据。这里定义一个函数，读取该原始语音数据，返回声音信号的时域谱矩阵和帧速率。具体函数如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">一些通用函数，如wav文件读取、信号出来和测试代码</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> python_speech_features <span class="keyword">import</span> mfcc</span><br><span class="line"><span class="keyword">from</span> python_speech_features <span class="keyword">import</span> delta</span><br><span class="line"><span class="keyword">from</span> python_speech_features <span class="keyword">import</span> logfbank</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_wav_data</span>(<span class="params">filename</span>):</span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	读取一个wav文件，返回声音信号的时域谱矩阵和播放时间</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	wav = wave.<span class="built_in">open</span>(filename,<span class="string">&quot;rb&quot;</span>) <span class="comment"># 打开一个wav格式的声音文件流</span></span><br><span class="line">	num_frame = wav.getnframes() <span class="comment"># 获取帧数</span></span><br><span class="line">	num_channel=wav.getnchannels() <span class="comment"># 获取声道数</span></span><br><span class="line">	framerate=wav.getframerate() <span class="comment"># 获取帧速率</span></span><br><span class="line">	num_sample_width=wav.getsampwidth() <span class="comment"># 获取实例的比特宽度，即每一帧的字节数</span></span><br><span class="line">	str_data = wav.readframes(num_frame) <span class="comment"># 读取全部的帧</span></span><br><span class="line">	wav.close() <span class="comment"># 关闭流</span></span><br><span class="line">	wave_data = np.fromstring(str_data, dtype = np.short) <span class="comment"># 将声音文件数据转换为数组矩阵形式</span></span><br><span class="line">	wave_data.shape = -<span class="number">1</span>, num_channel <span class="comment"># 按照声道数将数组整形，单声道时候是一列数组，双声道时候是两列的矩阵</span></span><br><span class="line">	wave_data = wave_data.T <span class="comment"># 将矩阵转置</span></span><br><span class="line">	<span class="keyword">return</span> wave_data, framerate  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetMfccFeature</span>(<span class="params">wavsignal, fs</span>):</span><br><span class="line">	<span class="comment"># 获取输入特征</span></span><br><span class="line">	feat_mfcc=mfcc(wavsignal[<span class="number">0</span>],fs)</span><br><span class="line">	feat_mfcc_d=delta(feat_mfcc,<span class="number">2</span>)</span><br><span class="line">	feat_mfcc_dd=delta(feat_mfcc_d,<span class="number">2</span>)</span><br><span class="line">	<span class="comment"># 返回值分别是mfcc特征向量的矩阵及其一阶差分和二阶差分矩阵</span></span><br><span class="line">	wav_feature = np.column_stack((feat_mfcc, feat_mfcc_d, feat_mfcc_dd))</span><br><span class="line">	<span class="keyword">return</span> wav_feature</span><br><span class="line"></span><br><span class="line">x=np.linspace(<span class="number">0</span>, <span class="number">400</span> - <span class="number">1</span>, <span class="number">400</span>, dtype = np.int64)</span><br><span class="line">w = <span class="number">0.54</span> - <span class="number">0.46</span> * np.cos(<span class="number">2</span> * np.pi * (x) / (<span class="number">400</span> - <span class="number">1</span>) ) <span class="comment"># 汉明窗</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetFrequencyFeature3</span>(<span class="params">wavsignal, fs</span>):</span><br><span class="line">	<span class="comment"># wav波形 加时间窗以及时移10ms</span></span><br><span class="line">	time_window = <span class="number">25</span> <span class="comment"># 单位ms</span></span><br><span class="line">	window_length = fs / <span class="number">1000</span> * time_window <span class="comment"># 计算窗长度的公式，目前全部为400固定值</span></span><br><span class="line">	</span><br><span class="line">	wav_arr = np.array(wavsignal)</span><br><span class="line">	<span class="comment">#wav_length = len(wavsignal[0])</span></span><br><span class="line">	wav_length = wav_arr.shape[<span class="number">1</span>]</span><br><span class="line">	</span><br><span class="line">	range0_end = <span class="built_in">int</span>(<span class="built_in">len</span>(wavsignal[<span class="number">0</span>])/fs*<span class="number">1000</span> - time_window) // <span class="number">10</span> <span class="comment"># 计算循环终止的位置，也就是最终生成的窗数</span></span><br><span class="line">	data_input = np.zeros((range0_end, <span class="number">200</span>), dtype = np.<span class="built_in">float</span>) <span class="comment"># 用于存放最终的频率特征数据</span></span><br><span class="line">	data_line = np.zeros((<span class="number">1</span>, <span class="number">400</span>), dtype = np.<span class="built_in">float</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, range0_end):</span><br><span class="line">		p_start = i * <span class="number">160</span></span><br><span class="line">		p_end = p_start + <span class="number">400</span></span><br><span class="line">		</span><br><span class="line">		data_line = wav_arr[<span class="number">0</span>, p_start:p_end]</span><br><span class="line">		</span><br><span class="line">		data_line = data_line * w <span class="comment"># 加窗</span></span><br><span class="line">		</span><br><span class="line">		data_line = np.<span class="built_in">abs</span>(fft(data_line)) / wav_length</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		data_input[i]=data_line[<span class="number">0</span>:<span class="number">200</span>] <span class="comment"># 设置为400除以2的值（即200）是取一半数据，因为是对称的</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">#print(data_input.shape)</span></span><br><span class="line">	data_input = np.log(data_input + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> data_input</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wav_scale</span>(<span class="params">energy</span>):</span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	语音信号能量归一化</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	means = energy.mean() <span class="comment"># 均值</span></span><br><span class="line">	var=energy.var() <span class="comment"># 方差</span></span><br><span class="line">	e=(energy-means)/math.sqrt(var) <span class="comment"># 归一化能量</span></span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wav_show</span>(<span class="params">wave_data, fs</span>): <span class="comment"># 显示出来声音波形</span></span><br><span class="line">	time = np.arange(<span class="number">0</span>, <span class="built_in">len</span>(wave_data)) * (<span class="number">1.0</span>/fs)  <span class="comment"># 计算声音的播放时间，单位为秒</span></span><br><span class="line">	<span class="comment"># 画声音波形</span></span><br><span class="line">	<span class="comment">#plt.subplot(211)  </span></span><br><span class="line">	plt.plot(time, wave_data)  </span><br><span class="line">	<span class="comment">#plt.subplot(212)  </span></span><br><span class="line">	<span class="comment">#plt.plot(time, wave_data[1], c = &quot;g&quot;)  </span></span><br><span class="line">	plt.show()  </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_wav_list</span>(<span class="params">filename</span>):</span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	读取一个wav文件列表，返回一个存储该列表的字典类型值</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	txt_obj=<span class="built_in">open</span>(filename,<span class="string">&#x27;r&#x27;</span>) <span class="comment"># 打开文件并读入</span></span><br><span class="line">	txt_text=txt_obj.read()</span><br><span class="line">	txt_lines=txt_text.split(<span class="string">&#x27;\n&#x27;</span>) <span class="comment"># 文本分割</span></span><br><span class="line">	dic_filelist=&#123;&#125; <span class="comment"># 初始化字典</span></span><br><span class="line">	list_wavmark=[] <span class="comment"># 初始化wav列表</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> txt_lines:</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="string">&#x27;&#x27;</span>):</span><br><span class="line">			txt_l=i.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">			dic_filelist[txt_l[<span class="number">0</span>]] = txt_l[<span class="number">1</span>]</span><br><span class="line">			list_wavmark.append(txt_l[<span class="number">0</span>])</span><br><span class="line">	txt_obj.close()</span><br><span class="line">	<span class="keyword">return</span> dic_filelist,list_wavmark</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_wav_symbol</span>(<span class="params">filename</span>):</span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	读取指定数据集中，所有wav文件对应的语音符号</span></span><br><span class="line"><span class="string">	返回一个存储符号集的字典类型值</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	txt_obj=<span class="built_in">open</span>(filename,<span class="string">&#x27;r&#x27;</span>) <span class="comment"># 打开文件并读入</span></span><br><span class="line">	txt_text=txt_obj.read()</span><br><span class="line">	txt_lines=txt_text.split(<span class="string">&#x27;\n&#x27;</span>) <span class="comment"># 文本分割</span></span><br><span class="line">	dic_symbol_list=&#123;&#125; <span class="comment"># 初始化字典</span></span><br><span class="line">	list_symbolmark=[] <span class="comment"># 初始化symbol列表</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> txt_lines:</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="string">&#x27;&#x27;</span>):</span><br><span class="line">			txt_l=i.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">			dic_symbol_list[txt_l[<span class="number">0</span>]]=txt_l[<span class="number">1</span>:]</span><br><span class="line">			list_symbolmark.append(txt_l[<span class="number">0</span>])</span><br><span class="line">	txt_obj.close()</span><br><span class="line">	<span class="keyword">return</span> dic_symbol_list,list_symbolmark</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span>(__name__==<span class="string">&#x27;__main__&#x27;</span>):</span><br><span class="line">	</span><br><span class="line">	wave_data, fs = read_wav_data(<span class="string">&quot;A2_0.wav&quot;</span>)  </span><br><span class="line">	</span><br><span class="line">	wav_show(wave_data[<span class="number">0</span>],fs)</span><br><span class="line">	t0=time.time()</span><br><span class="line">	freimg = GetFrequencyFeature(wave_data,fs)</span><br><span class="line">	t1=time.time()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;time cost:&#x27;</span>,t1-t0)</span><br><span class="line">	</span><br><span class="line">	freimg = freimg.T</span><br><span class="line">	plt.subplot(<span class="number">111</span>)</span><br><span class="line">	</span><br><span class="line">	plt.imshow(freimg)</span><br><span class="line">	plt.colorbar(cax=<span class="literal">None</span>,ax=<span class="literal">None</span>,shrink=<span class="number">0.5</span>)  </span><br><span class="line">	 </span><br><span class="line">	plt.show() </span><br></pre></td></tr></table></figure></p>
<p>原始语音信号经过处理后得到帧数、声道数、帧速率。然后读取全部帧数，再经过变换后转换成数组矩阵格式，该数组按照声道数进行数组整形，整形后数组转置得到时域谱矩阵，得到帧速率和时域谱矩阵。在得到帧速率和时域谱矩阵后，经过加窗、采样后、傅里叶变换，以及最后的连续拼接。流程图如下：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/7.png" alt></p>
<p>下图是采用上述代码对中文语音数据提取的波形图和语谱图的结果。波形图的横轴是时间，纵轴可以理解为位移或者压强。语谱图的横轴是拼接的时间，纵轴是频率。</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/8.png" alt></p>
<h3 id="声学模型设计训练"><a href="#声学模型设计训练" class="headerlink" title="声学模型设计训练"></a>声学模型设计训练</h3><p>声学模型输⼊入是语谱图，输出是拼音。如下图所示：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/9.png" alt></p>
<p>声学模型设计主要基于DFCNN网络进行训练，主要设计的结构和相应的参数设置如下：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/10.png" alt></p>
<p>参数设置：</p>
<p>Adam 的参数:<br>(lr = 0.01, beta_1 = 0.9,beta_2 = 0.999, decay = 0.0, epsilon = 10e-8)</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/11.png" alt></p>
<p>CTC是一种针对序列列深度模型的损失函数。相⽐比传统交叉熵损失函数能⾃自动对⻬齐序列列标签，端到端训练模型。具体参考<a href="https://blog.ailemon.me/2019/07/18/sequence-modeling-with-ctc/">这里</a></p>
<p>使用Keras搭建序贯(Sequential)模型，部分代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">声学模型</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> platform <span class="keyword">as</span> plat</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> general_function.file_wav <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> general_function.file_dict <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> general_function.gen_func <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> general_function.muti_gpu <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> multi_gpu_model,plot_model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> keras <span class="keyword">as</span> kr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential, Model</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Input, Reshape, BatchNormalization <span class="comment"># , Flatten</span></span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Lambda, TimeDistributed, Activation,Conv2D, MaxPooling2D <span class="comment">#, Merge</span></span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD, Adadelta, Adam, RMSprop</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ReadData <span class="keyword">import</span> DataSpeech</span><br><span class="line"></span><br><span class="line">abspath = <span class="string">&#x27;&#x27;</span></span><br><span class="line">ModelName=<span class="string">&#x27;_dfcnn&#x27;</span></span><br><span class="line"><span class="comment">#NUM_GPU = 2</span></span><br><span class="line">base_count=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelSpeech</span>(): <span class="comment"># 语音模型类</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, datapath</span>):</span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		初始化</span></span><br><span class="line"><span class="string">		默认输出的拼音的表示大小是1434，即1433个拼音+1个空白块</span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		MS_OUTPUT_SIZE = <span class="number">1434</span></span><br><span class="line">		self.MS_OUTPUT_SIZE = MS_OUTPUT_SIZE <span class="comment"># 神经网络最终输出的每一个字符向量维度的大小</span></span><br><span class="line">		<span class="comment">#self.BATCH_SIZE = BATCH_SIZE # 一次训练的batch</span></span><br><span class="line">		self.label_max_string_length = <span class="number">64</span></span><br><span class="line">		self.AUDIO_LENGTH = <span class="number">1600</span>  <span class="comment">## 16s</span></span><br><span class="line">		self.AUDIO_FEATURE_LENGTH = <span class="number">200</span></span><br><span class="line">		self._model, self.base_model = self.CreateModel() </span><br><span class="line">		</span><br><span class="line">		self.datapath = datapath</span><br><span class="line">		self.slash = <span class="string">&#x27;&#x27;</span></span><br><span class="line">		system_type = plat.system() <span class="comment"># 由于不同的系统的文件路径表示不一样，需要进行判断</span></span><br><span class="line">		<span class="keyword">if</span>(system_type == <span class="string">&#x27;Windows&#x27;</span>):</span><br><span class="line">			self.slash=<span class="string">&#x27;\\&#x27;</span> <span class="comment"># 反斜杠</span></span><br><span class="line">		<span class="keyword">elif</span>(system_type == <span class="string">&#x27;Linux&#x27;</span>):</span><br><span class="line">			self.slash=<span class="string">&#x27;/&#x27;</span> <span class="comment"># 正斜杠</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&#x27;*[Message] Unknown System\n&#x27;</span>)</span><br><span class="line">			self.slash=<span class="string">&#x27;/&#x27;</span> <span class="comment"># 正斜杠</span></span><br><span class="line">		<span class="keyword">if</span>(self.slash != self.datapath[-<span class="number">1</span>]): <span class="comment"># 在目录路径末尾增加斜杠</span></span><br><span class="line">			self.datapath = self.datapath + self.slash</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">CreateModel</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		定义DFCNN模型，使用函数式模型  </span></span><br><span class="line"><span class="string">		输入层：200维的特征值序列，一条语音数据的最大长度设为1600（大约16s）</span></span><br><span class="line"><span class="string">		隐藏层：卷积池化层，卷积核大小为3x3，池化窗口大小为2</span></span><br><span class="line"><span class="string">		隐藏层：全连接层</span></span><br><span class="line"><span class="string">		输出层：全连接层，神经元数量为self.MS_OUTPUT_SIZE，使用softmax作为激活函数，</span></span><br><span class="line"><span class="string">		CTC层：使用CTC的loss作为损失函数，实现连接性时序多输出</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		</span><br><span class="line">		input_data = Input(name=<span class="string">&#x27;the_input&#x27;</span>, shape=(self.AUDIO_LENGTH, self.AUDIO_FEATURE_LENGTH, <span class="number">1</span>))</span><br><span class="line">		</span><br><span class="line">		layer_h1 = Conv2D(<span class="number">32</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">False</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(input_data) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h1 = BatchNormalization(mode=<span class="number">0</span>,axis=-<span class="number">1</span>)(layer_h1)</span><br><span class="line">		layer_h2 = Conv2D(<span class="number">32</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(layer_h1) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h2 = BatchNormalization(axis=-<span class="number">1</span>)(layer_h2)</span><br><span class="line">		layer_h3 = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="literal">None</span>, padding=<span class="string">&quot;valid&quot;</span>)(layer_h2) <span class="comment"># 池化层 800*100</span></span><br><span class="line">		layer_h4 = Conv2D(<span class="number">64</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(layer_h3) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h4 = BatchNormalization(axis=-<span class="number">1</span>)(layer_h4)</span><br><span class="line">		layer_h5 = Conv2D(<span class="number">64</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(layer_h4) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h5 = BatchNormalization(axis=-<span class="number">1</span>)(layer_h5)</span><br><span class="line">		layer_h6 = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="literal">None</span>, padding=<span class="string">&quot;valid&quot;</span>)(layer_h5) <span class="comment"># 池化层 400*50</span></span><br><span class="line">		layer_h7 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(layer_h6) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h7 = BatchNormalization(axis=-<span class="number">1</span>)(layer_h7)</span><br><span class="line">		layer_h8 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(layer_h7) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h8 = BatchNormalization(axis=-<span class="number">1</span>)(layer_h8)</span><br><span class="line">		layer_h9 = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="literal">None</span>, padding=<span class="string">&quot;valid&quot;</span>)(layer_h8) <span class="comment"># 池化层 200*25</span></span><br><span class="line">		layer_h10 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(layer_h9) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h10 = BatchNormalization(axis=-<span class="number">1</span>)(layer_h10)</span><br><span class="line">		layer_h11 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(layer_h10) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h11 = BatchNormalization(axis=-<span class="number">1</span>)(layer_h11)</span><br><span class="line">		layer_h12 = MaxPooling2D(pool_size=<span class="number">1</span>, strides=<span class="literal">None</span>, padding=<span class="string">&quot;valid&quot;</span>)(layer_h11) <span class="comment"># 池化层 200*25</span></span><br><span class="line">		</span><br><span class="line">		layer_h13 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(layer_h12) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h13 = BatchNormalization(axis=-<span class="number">1</span>)(layer_h13)</span><br><span class="line">		layer_h14 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(layer_h13) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h14 = BatchNormalization(axis=-<span class="number">1</span>)(layer_h14)</span><br><span class="line">		layer_h15 = MaxPooling2D(pool_size=<span class="number">1</span>, strides=<span class="literal">None</span>, padding=<span class="string">&quot;valid&quot;</span>)(layer_h14) <span class="comment"># 池化层 None*200*25*128</span></span><br><span class="line">		</span><br><span class="line">		layer_h16 = Reshape((<span class="number">200</span>, <span class="number">3200</span>))(layer_h15)</span><br><span class="line">		layer_h17 = Dense(<span class="number">128</span>, activation=<span class="string">&quot;relu&quot;</span>, use_bias=<span class="literal">True</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(layer_h16) <span class="comment"># 全连接层</span></span><br><span class="line">		layer_h17 = BatchNormalization(axis=<span class="number">1</span>)(layer_h17)</span><br><span class="line">		layer_h18 = Dense(self.MS_OUTPUT_SIZE, use_bias=<span class="literal">True</span>, kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)(layer_h17) <span class="comment"># 全连接层</span></span><br><span class="line">		layer_h18 = BatchNormalization(axis=<span class="number">1</span>)(layer_h18)</span><br><span class="line">		y_pred = Activation(<span class="string">&#x27;softmax&#x27;</span>, name=<span class="string">&#x27;Activation0&#x27;</span>)(layer_h18)</span><br><span class="line">		model_data = Model(inputs = input_data, outputs = y_pred)</span><br><span class="line">		model_data.summary()</span><br><span class="line">		</span><br><span class="line">		labels = Input(name=<span class="string">&#x27;the_labels&#x27;</span>, shape=[self.label_max_string_length], dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">		input_length = Input(name=<span class="string">&#x27;input_length&#x27;</span>, shape=[<span class="number">1</span>], dtype=<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line">		label_length = Input(name=<span class="string">&#x27;label_length&#x27;</span>, shape=[<span class="number">1</span>], dtype=<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line">		<span class="comment"># Keras doesn&#x27;t currently support loss funcs with extra parameters</span></span><br><span class="line">		<span class="comment"># so CTC loss is implemented in a lambda layer</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment"># CTC</span></span><br><span class="line">		loss_out = Lambda(self.ctc_lambda_func, output_shape=(<span class="number">1</span>,), name=<span class="string">&#x27;ctc&#x27;</span>)([y_pred, labels, input_length, label_length])</span><br><span class="line">		</span><br><span class="line">		model = Model(inputs=[input_data, labels, input_length, label_length], outputs=loss_out)</span><br><span class="line">		</span><br><span class="line">		opt = Adam(lr = <span class="number">0.001</span>, beta_1 = <span class="number">0.9</span>, beta_2 = <span class="number">0.999</span>, decay = <span class="number">0.0</span>, epsilon = <span class="number">10e-8</span>)</span><br><span class="line">		<span class="comment">#model.compile(loss=&#123;&#x27;ctc&#x27;: lambda y_true, y_pred: y_pred&#125;, optimizer=sgd)</span></span><br><span class="line">		model.<span class="built_in">compile</span>(loss=&#123;<span class="string">&#x27;ctc&#x27;</span>: <span class="keyword">lambda</span> y_true, y_pred: y_pred&#125;, optimizer = opt)</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># captures output of softmax so we can decode the output during visualization</span></span><br><span class="line">		test_func = K.function([input_data], [y_pred])</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;[*提示] 创建模型成功，模型编译成功&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> model, model_data</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">ctc_lambda_func</span>(<span class="params">self, args</span>):</span><br><span class="line">		y_pred, labels, input_length, label_length = args</span><br><span class="line">		</span><br><span class="line">		y_pred = y_pred[:, :, :]</span><br><span class="line">		<span class="comment">#y_pred = y_pred[:, 2:, :]</span></span><br><span class="line">		<span class="keyword">return</span> K.ctc_batch_cost(labels, y_pred, input_length, label_length)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">TrainModel</span>(<span class="params">self, datapath, epoch = <span class="number">2</span>, save_step = <span class="number">1000</span>, batch_size = <span class="number">32</span>, filename = abspath + <span class="string">&#x27;model_speech/m&#x27;</span> + ModelName + <span class="string">&#x27;/speech_model&#x27;</span>+ModelName</span>):</span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		训练模型</span></span><br><span class="line"><span class="string">		参数：</span></span><br><span class="line"><span class="string">			datapath: 数据保存的路径</span></span><br><span class="line"><span class="string">			epoch: 迭代轮数</span></span><br><span class="line"><span class="string">			save_step: 每多少步保存一次模型</span></span><br><span class="line"><span class="string">			filename: 默认保存文件名，不含文件后缀名</span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		data=DataSpeech(datapath, <span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">		</span><br><span class="line">		num_data = data.GetDataNum() <span class="comment"># 获取数据的数量</span></span><br><span class="line">		</span><br><span class="line">		yielddatas = data.data_genetator(batch_size, self.AUDIO_LENGTH)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch): <span class="comment"># 迭代轮数</span></span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&#x27;[running] train epoch %d .&#x27;</span> % epoch)</span><br><span class="line">			n_step = <span class="number">0</span> <span class="comment"># 迭代数据数</span></span><br><span class="line">			<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">				<span class="keyword">try</span>:</span><br><span class="line">					<span class="built_in">print</span>(<span class="string">&#x27;[message] epoch %d . Have train datas %d+&#x27;</span>%(epoch, n_step*save_step))</span><br><span class="line">					<span class="comment"># data_genetator是一个生成器函数</span></span><br><span class="line">					</span><br><span class="line">					<span class="comment">#self._model.fit_generator(yielddatas, save_step, nb_worker=2)</span></span><br><span class="line">					self._model.fit_generator(yielddatas, save_step)</span><br><span class="line">					n_step += <span class="number">1</span></span><br><span class="line">				<span class="keyword">except</span> StopIteration:</span><br><span class="line">					<span class="built_in">print</span>(<span class="string">&#x27;[error] generator error. please check data format.&#x27;</span>)</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				</span><br><span class="line">				self.SaveModel(comment=<span class="string">&#x27;_e_&#x27;</span>+<span class="built_in">str</span>(epoch)+<span class="string">&#x27;_step_&#x27;</span>+<span class="built_in">str</span>(n_step * save_step))</span><br><span class="line">				self.TestModel(self.datapath, str_dataset=<span class="string">&#x27;train&#x27;</span>, data_count = <span class="number">4</span>)</span><br><span class="line">				self.TestModel(self.datapath, str_dataset=<span class="string">&#x27;dev&#x27;</span>, data_count = <span class="number">4</span>)</span><br><span class="line">				</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">LoadModel</span>(<span class="params">self,filename = abspath + <span class="string">&#x27;model_speech/m&#x27;</span>+ModelName+<span class="string">&#x27;/speech_model&#x27;</span>+ModelName+<span class="string">&#x27;.model&#x27;</span></span>):</span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		加载模型参数</span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		self._model.load_weights(filename)</span><br><span class="line">		self.base_model.load_weights(filename + <span class="string">&#x27;.base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">SaveModel</span>(<span class="params">self,filename = abspath + <span class="string">&#x27;model_speech/m&#x27;</span>+ModelName+<span class="string">&#x27;/speech_model&#x27;</span>+ModelName,comment=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		保存模型参数</span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		self._model.save_weights(filename + comment + <span class="string">&#x27;.model&#x27;</span>)</span><br><span class="line">		self.base_model.save_weights(filename + comment + <span class="string">&#x27;.model.base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">TestModel</span>(<span class="params">self, datapath=<span class="string">&#x27;&#x27;</span>, str_dataset=<span class="string">&#x27;dev&#x27;</span>, data_count = <span class="number">32</span>,comment = <span class="string">&#x27;&#x27;</span>, out_report = <span class="literal">False</span>, show_ratio = <span class="literal">True</span>, io_step_print = <span class="number">10</span>, io_step_file = <span class="number">10</span></span>):</span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		测试检验模型效果</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		io_step_print</span></span><br><span class="line"><span class="string">			为了减少测试时标准输出的io开销，可以通过调整这个参数来实现</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		io_step_file</span></span><br><span class="line"><span class="string">			为了减少测试时文件读写的io开销，可以通过调整这个参数来实现</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		data=DataSpeech(self.datapath, str_dataset)</span><br><span class="line">		<span class="comment">#data.LoadDataList(str_dataset) </span></span><br><span class="line">		num_data = data.GetDataNum() <span class="comment"># 获取数据的数量</span></span><br><span class="line">		<span class="keyword">if</span>(data_count &lt;= <span class="number">0</span> <span class="keyword">or</span> data_count &gt; num_data): <span class="comment"># 当data_count为小于等于0或者大于测试数据量的值时，则使用全部数据来测试</span></span><br><span class="line">			data_count = num_data</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			ran_num = random.randint(<span class="number">0</span>,num_data - <span class="number">1</span>) <span class="comment"># 获取一个随机数</span></span><br><span class="line">			</span><br><span class="line">			words_num = <span class="number">0</span></span><br><span class="line">			word_error_num = <span class="number">0</span></span><br><span class="line">			</span><br><span class="line">			nowtime = time.strftime(<span class="string">&#x27;%Y%m%d_%H%M%S&#x27;</span>,time.localtime(time.time()))</span><br><span class="line">			<span class="keyword">if</span>(out_report == <span class="literal">True</span>):</span><br><span class="line">				txt_obj = <span class="built_in">open</span>(abspath+<span class="string">&#x27;Test_Report_&#x27;</span> + str_dataset + <span class="string">&#x27;_&#x27;</span> + nowtime + <span class="string">&#x27;.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="comment"># 打开文件并读入</span></span><br><span class="line">			</span><br><span class="line">			txt = <span class="string">&#x27;测试报告\n模型编号 &#x27;</span> + ModelName + <span class="string">&#x27;\n\n&#x27;</span></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data_count):</span><br><span class="line">				data_input, data_labels = data.GetData((ran_num + i) % num_data)  <span class="comment"># 从随机数开始连续向后取一定数量数据</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment"># 数据格式出错处理 开始</span></span><br><span class="line">				<span class="comment"># 当输入的wav文件长度过长时自动跳过该文件，转而使用下一个wav文件来运行</span></span><br><span class="line">				num_bias = <span class="number">0</span></span><br><span class="line">				<span class="keyword">while</span>(data_input.shape[<span class="number">0</span>] &gt; self.AUDIO_LENGTH):</span><br><span class="line">					<span class="built_in">print</span>(<span class="string">&#x27;*[Error]&#x27;</span>,<span class="string">&#x27;wave data lenghth of num&#x27;</span>,(ran_num + i) % num_data, <span class="string">&#x27;is too long.&#x27;</span>,<span class="string">&#x27;\n A Exception raise when test Speech Model.&#x27;</span>)</span><br><span class="line">					num_bias += <span class="number">1</span></span><br><span class="line">					data_input, data_labels = data.GetData((ran_num + i + num_bias) % num_data)  <span class="comment"># 从随机数开始连续向后取一定数量数据</span></span><br><span class="line">				<span class="comment"># 数据格式出错处理 结束</span></span><br><span class="line">				</span><br><span class="line">				pre = self.Predict(data_input, data_input.shape[<span class="number">0</span>] // <span class="number">8</span>)</span><br><span class="line">				</span><br><span class="line">				words_n = data_labels.shape[<span class="number">0</span>] <span class="comment"># 获取每个句子的字数</span></span><br><span class="line">				words_num += words_n <span class="comment"># 把句子的总字数加上</span></span><br><span class="line">				edit_distance = GetEditDistance(data_labels, pre) <span class="comment"># 获取编辑距离</span></span><br><span class="line">				<span class="keyword">if</span>(edit_distance &lt;= words_n): <span class="comment"># 当编辑距离小于等于句子字数时</span></span><br><span class="line">					word_error_num += edit_distance <span class="comment"># 使用编辑距离作为错误字数</span></span><br><span class="line">				<span class="keyword">else</span>: <span class="comment"># 否则肯定是增加了一堆乱七八糟的奇奇怪怪的字</span></span><br><span class="line">					word_error_num += words_n <span class="comment"># 就直接加句子本来的总字数就好了</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>((i % io_step_print == <span class="number">0</span> <span class="keyword">or</span> i == data_count - <span class="number">1</span>) <span class="keyword">and</span> show_ratio == <span class="literal">True</span>):</span><br><span class="line">					<span class="comment">#print(&#x27;测试进度：&#x27;,i,&#x27;/&#x27;,data_count)</span></span><br><span class="line">					<span class="built_in">print</span>(<span class="string">&#x27;Test Count: &#x27;</span>,i,<span class="string">&#x27;/&#x27;</span>,data_count)</span><br><span class="line">				</span><br><span class="line">				txt = <span class="string">&#x27;&#x27;</span></span><br><span class="line">				<span class="keyword">if</span>(out_report == <span class="literal">True</span>):</span><br><span class="line">					<span class="comment"># if(i % io_step_file == 0 or i == data_count - 1):</span></span><br><span class="line">					<span class="comment"># 	txt_obj.write(txt)</span></span><br><span class="line">					<span class="comment"># 	txt = &#x27;&#x27;</span></span><br><span class="line">					txt += <span class="built_in">str</span>(i) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">					txt += <span class="string">&#x27;True:\t&#x27;</span> + <span class="built_in">str</span>(data_labels) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">					txt += <span class="string">&#x27;Pred:\t&#x27;</span> + <span class="built_in">str</span>(pre) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">					txt += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">					txt_obj.write(txt)</span><br><span class="line">				</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&#x27;*[Test Result] Speech Recognition &#x27;</span> + str_dataset + <span class="string">&#x27; set word error ratio: &#x27;</span>, word_error_num / words_num * <span class="number">100</span>, <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">			<span class="keyword">if</span>(out_report == <span class="literal">True</span>):</span><br><span class="line">				txt += <span class="string">&#x27;*[测试结果] 语音识别 &#x27;</span> + str_dataset + <span class="string">&#x27; 集语音单字错误率： &#x27;</span> + <span class="built_in">str</span>(word_error_num / words_num * <span class="number">100</span>) + <span class="string">&#x27; %&#x27;</span></span><br><span class="line">				txt_obj.write(txt)</span><br><span class="line">				txt = <span class="string">&#x27;&#x27;</span></span><br><span class="line">				txt_obj.close()</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">except</span> StopIteration:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&#x27;[Error] Model Test Error. please check data format.&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">Predict</span>(<span class="params">self, data_input, input_len</span>):</span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		预测结果</span></span><br><span class="line"><span class="string">		返回语音识别后的拼音符号列表</span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		</span><br><span class="line">		batch_size = <span class="number">1</span> </span><br><span class="line">		in_len = np.zeros((batch_size),dtype = np.int32)</span><br><span class="line">		</span><br><span class="line">		in_len[<span class="number">0</span>] = input_len</span><br><span class="line">		</span><br><span class="line">		x_in = np.zeros((batch_size, <span class="number">1600</span>, self.AUDIO_FEATURE_LENGTH, <span class="number">1</span>), dtype=np.<span class="built_in">float</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(batch_size):</span><br><span class="line">			x_in[i,<span class="number">0</span>:<span class="built_in">len</span>(data_input)] = data_input</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		base_pred = self.base_model.predict(x = x_in)</span><br><span class="line">		</span><br><span class="line">		base_pred =base_pred[:, :, :]</span><br><span class="line">		</span><br><span class="line">		r = K.ctc_decode(base_pred, in_len, greedy = <span class="literal">True</span>, beam_width=<span class="number">100</span>, top_paths=<span class="number">1</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">#print(&#x27;r&#x27;, r)</span></span><br><span class="line">		</span><br><span class="line">		r1 = K.get_value(r[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">		<span class="comment">#print(&#x27;r1&#x27;, r1)</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">#r2 = K.get_value(r[1])</span></span><br><span class="line">		<span class="comment">#print(r2)</span></span><br><span class="line">		</span><br><span class="line">		r1=r1[<span class="number">0</span>]</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> r1</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">RecognizeSpeech</span>(<span class="params">self, wavsignal, fs</span>):</span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		最终做语音识别用的函数，识别一个wav序列的语音</span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">#data = self.data</span></span><br><span class="line">		<span class="comment">#data = DataSpeech(&#x27;E:\\语音数据集&#x27;)</span></span><br><span class="line">		<span class="comment">#data.LoadDataList(&#x27;dev&#x27;)</span></span><br><span class="line">		<span class="comment"># 获取输入特征</span></span><br><span class="line">		<span class="comment">#data_input = GetMfccFeature(wavsignal, fs)</span></span><br><span class="line">		<span class="comment">#t0=time.time()</span></span><br><span class="line">		data_input = GetFrequencyFeature(wavsignal, fs)</span><br><span class="line">		<span class="comment">#t1=time.time()</span></span><br><span class="line">		<span class="comment">#print(&#x27;time cost:&#x27;,t1-t0)</span></span><br><span class="line">		</span><br><span class="line">		input_length = <span class="built_in">len</span>(data_input)</span><br><span class="line">		input_length = input_length // <span class="number">8</span></span><br><span class="line">		</span><br><span class="line">		data_input = np.array(data_input, dtype = np.<span class="built_in">float</span>)</span><br><span class="line">		<span class="comment">#print(data_input,data_input.shape)</span></span><br><span class="line">		data_input = data_input.reshape(data_input.shape[<span class="number">0</span>],data_input.shape[<span class="number">1</span>],<span class="number">1</span>)</span><br><span class="line">		<span class="comment">#t2=time.time()</span></span><br><span class="line">		r1 = self.Predict(data_input, input_length)</span><br><span class="line">		<span class="comment">#t3=time.time()</span></span><br><span class="line">		<span class="comment">#print(&#x27;time cost:&#x27;,t3-t2)</span></span><br><span class="line">		list_symbol_dic = GetSymbolList(self.datapath) <span class="comment"># 获取拼音列表</span></span><br><span class="line">		</span><br><span class="line">		r_str=[]</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> r1:</span><br><span class="line">			r_str.append(list_symbol_dic[i])</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> r_str</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">RecognizeSpeech_FromFile</span>(<span class="params">self, filename</span>):</span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		最终做语音识别用的函数，识别指定文件名的语音</span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		</span><br><span class="line">		wavsignal,fs = read_wav_data(filename)</span><br><span class="line">		</span><br><span class="line">		r = self.RecognizeSpeech(wavsignal, fs)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> r</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">model</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		返回keras model</span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="keyword">return</span> self._model</span><br></pre></td></tr></table></figure></p>
<h3 id="语言模型设计训练"><a href="#语言模型设计训练" class="headerlink" title="语言模型设计训练"></a>语言模型设计训练</h3><h3 id="实验分析和软件设计"><a href="#实验分析和软件设计" class="headerlink" title="实验分析和软件设计"></a>实验分析和软件设计</h3>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>静态与普通成员变量及函数的区别</title>
    <url>/2020/04/27/%E9%9D%99%E6%80%81%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%8F%8A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>静态与普通变量及函数的区别就是在声明部分有无类名，即：</p>
<p><strong>普通成员变量</strong>：返回类型 （类名::*指针名）=</p>
<p><strong>静态成员变量</strong>：返回类型 （*指针名）=</p>
<p>需要注意，<strong>初始化静态成员变量要在类外初始化，不能在声明时直接赋值。</strong></p>
<p>并且，<strong>调用静态成员变量的时候，不需要加对象名，直接*指针，</strong></p>
<p>另外，<strong>因为优先级的原因，调用成员函数指针的时候括号不能少。</strong><br><span id="more"></span><br>举例说明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> j;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> k= <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticfun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;静态成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Class::j = <span class="number">2</span>;                       <span class="comment">//静态成员变量初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class c;</span><br><span class="line">    <span class="comment">//变量指针</span></span><br><span class="line">    <span class="built_in">int</span> (Class::*p1) = &amp;Class::i;        <span class="comment">//普通成员变量指针</span></span><br><span class="line">    <span class="built_in">int</span> (*p2) = &amp;Class::j;               <span class="comment">//静态成员变量指针</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">int</span> <span class="params">(*p3)</span> </span>= &amp;Class::k;        <span class="comment">//静态成员常量指针</span></span><br><span class="line">    <span class="comment">//函数指针</span></span><br><span class="line">    <span class="built_in">void</span>(Class::*p4)() = &amp;Class::fun; <span class="comment">//普通成员函数指针</span></span><br><span class="line">    <span class="built_in">void</span>(*p5)() = &amp;Class::staticfun;  <span class="comment">//静态成员函数指针</span></span><br><span class="line">    <span class="comment">//指针调用</span></span><br><span class="line">    cout &lt;&lt; c.*p1 &lt;&lt; endl &lt;&lt; *p2 &lt;&lt; endl &lt;&lt; *p3 &lt;&lt; endl;</span><br><span class="line">    (c.*p4)();</span><br><span class="line">    (*p5)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
