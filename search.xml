<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何理解协议</title>
    <url>/2020/04/06/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>协议：</p>
<p>“协”字，代表必须有两个以上的参与者。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。</p>
<p>“议”字，代表的意思是对参与者的一种行为约定和规范。例如三方协议里规定的试用期限、毁约金等；租房协议里的租用期限、每月租金金额等。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP和TCP/IP的区别</title>
    <url>/2020/04/06/TCP%E5%92%8CTCP-IP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>TCP/IP是Transmission Control Protocol/Internet Protocol的简写，译名为传输控制协议/因特网协议，是Internet最基本的协议。TCP/IP是这个协议族的统称，它采用了4层的层级结构，而不是指TCP + IP两个协议的总和。</p>
<p>主要包括TCP、IP、UDP、ICMP、RIP、TELNET、FTP、SMTP、ARP、TFTP等许多协议</p>
<a id="more"></a>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP协议包含源主机地址、目标主机地址，还有TCP数据信息。但IP协议没有做任何事情来确认数据包是否按顺序发送或者包是否被破坏，所以IP数据包是不可靠的。</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>面向连接的通信协议，通过三次握手建立连接（socket通过TCP/IP连接时就是经过3次握手），通信完成后要关闭连接，它只用于端对端的通讯</p>
<p>TCP协议通过3次握手建立起一个可靠的连接，通过将数据包进行排序以及检验的方式，可以提供一种可靠的数据流服务</p>
<p>TCP可以限制数据的发送速度，间接地控制流量</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>面向无连接的通讯协议，UDP数据包括原端口号信息以及目标端口号信息，它可以实现广播发送</p>
<p>由于UDP通讯不需要接收方确认，所以属于不可靠的传输，可能会出现丢包现象。</p>
<p>七层网络模型示意图</p>
<p><img src="/2020/04/06/TCP%E5%92%8CTCP-IP%E7%9A%84%E5%8C%BA%E5%88%AB/1.jpg" alt></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP请求与响应全过程</title>
    <url>/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>在浏览器的地址栏输入一个URL，然后回车，回车这一瞬间到看到页面到底发生了什么呢？</p>
<p>主要是进行了一下几个步骤：</p>
<p>1.DNS域名解析；</p>
<p>2.建立TCP连接；</p>
<p>3.发送http请求；</p>
<p>4.服务器处理请求；</p>
<p>5.返回响应结果；</p>
<p>6.关闭TCP连接；</p>
<p>7.浏览器解析HTML；</p>
<p>8.浏览器布局渲染；</p>
<a id="more"></a>

<h3 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h3><p>我们在浏览器输入网址，其实就是要向服务器请求我们想要的页面内容，所有浏览器首先要确认的是域名所对应的服务器在哪里。将域名解析成对应的服务器IP地址这项工作，是由DNS服务器来完成的。</p>
<p>客户端收到你输入的域名地址后，一般会经历以下几个步骤：</p>
<ol>
<li><p>Chrome浏览器会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有<a href="http://www.baidu.com对应的条目，而且没有过期，如果有且没有过期则解析到此结束。" target="_blank" rel="noopener external nofollow noreferrer">www.baidu.com对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</a></p>
<pre><code>注：我们怎么查看Chrome自身的缓存？可以使用 
chrome://net-internals/#dns 来进行查看</code></pre></li>
<li><p>如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</p>
<pre><code>注：怎么查看操作系统自身的DNS缓存，以Windows系统为
例，可以在命令行下使用 ipconfig /displaydns 来进行查看</code></pre></li>
<li><p>如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p>
</li>
<li><p>如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问<a href="http://www.baidu.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.baidu.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.baidu.com" rel="external nofollow noreferrer">www.baidu.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.baidu.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.baidu.com</a>  对应的IP地址，该进行一步的动作了。</p>
</li>
</ol>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/1.png" alt></p>
<h3 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h3><p>费了一顿周折终于拿到服务器IP了，下一步自然就是链接到该服务器。对于客户端与服务器的TCP链接，必然要说的就是『三次握手』。</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/2.png" alt></p>
<p><strong>为什么HTTP协议要基于TCP来实现？</strong></p>
<p>目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</p>
<h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><p>与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）：</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/3.png" alt></p>
<p>请求报文<br>在浏览器中查看报文首部（以google浏览器为例）：</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/4.png" alt></p>
<p>请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。具体每个首部字段的作用，这里不做过多阐述。</p>
<h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><p>服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/5.png" alt></p>
<h3 id="返回响应结果"><a href="#返回响应结果" class="headerlink" title="返回响应结果"></a>返回响应结果</h3><p>在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构：</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/6.png" alt></p>
<p>响应报文</p>
<p>在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。</p>
<p>状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类：</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/7.png" alt></p>
<h3 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h3><p>为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。</p>
<p><img src="/2020/04/04/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E5%85%A8%E8%BF%87%E7%A8%8B/8.png" alt></p>
<h3 id="浏览器解析HTML"><a href="#浏览器解析HTML" class="headerlink" title="浏览器解析HTML"></a>浏览器解析HTML</h3><p>准确地说，浏览器需要加载解析的不仅仅是HTML，还包括CSS、JS。以及还要加载图片、视频等其他媒体资源。</p>
<p>浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。</p>
<p>要注意的是，浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题</p>
<h3 id="浏览器布局渲染"><a href="#浏览器布局渲染" class="headerlink" title="浏览器布局渲染"></a>浏览器布局渲染</h3><p>根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。</p>
<p>replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。</p>
<p>reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。<br>所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。</p>
<p>最后浏览器绘制各个节点，将页面展示给用户。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ thread用法总结</title>
    <url>/2020/04/04/C-thread%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>C++11中加入了<thread>头文件，此头文件主要声明了std::thread线程类。C++11的标准类std::thread对线程进行了封装，定义了C++11标准中的一些表示线程的类、用于互斥访问的类与方法等。应用C++11中的std::thread便于多线程程序的移值。</thread></p>
<a id="more"></a>
<p>std::thread类成员函数：</p>
<p>(1)、get_id：获取线程ID，返回一个类型为std::thread::id的对象。</p>
<p>(2)、joinable：检查线程是否可被join。检查thread对象是否标识一个活动(active)的可行性线程。缺省构造的thread对象、已经完成join的thread对象、已经detach的thread对象都不是joinable。</p>
<p>(3)、join：调用该函数会阻塞当前线程。阻塞调用者(caller)所在的线程直至被join的std::thread对象标识的线程执行结束。</p>
<p>(4)、detach：将当前线程对象所代表的执行实例与该线程对象分离，使得线程的执行可以单独进行。一旦线程执行完毕，它所分配的资源将会被释放。</p>
<p>(5)、native_handle：该函数返回与std::thread具体实现相关的线程句柄。native_handle_type是连接thread类和操作系统SDK API之间的桥梁，如在Linux g++(libstdc++)里，native_handle_type其实就是pthread里面的pthread_t类型，当thread类的功能不能满足我们的要求的时候(比如改变某个线程的优先级)，可以通过thread类实例的native_handle()返回值作为参数来调用相关的pthread函数达到目录。This member function is only present in class thread if the library implementation supports it. If present, it returns a value used to access implementation-specific information associated to the thread.</p>
<p>(6)、swap：交换两个线程对象所代表的底层句柄。</p>
<p>(7)、operator=：moves the thread object</p>
<p>(8)、hardware_concurrency：静态成员函数，返回当前计算机最大的硬件并发线程数目。基本上可以视为处理器的核心数目。</p>
<p>另外，std::thread::id表示线程ID，定义了在运行时操作系统内唯一能够标识该线程的标识符，同时其值还能指示所标识的线程的状态。Values of this type are returned by thread::get_id and this_thread::get_id to identify threads.</p>
<p>有时候我们需要在线程执行代码里面对当前调用者线程进行操作，针对这种情况，C++11里面专门定义了一个命名空间this_thread，此命名空间也声明在<thread>头文件中，其中包括get_id()函数用来获取当前调用者线程的ID；yield()函数可以用来将调用者线程跳出运行状态，重新交给操作系统进行调度，即当前线程放弃执行，操作系统调度另一线程继续执行；sleep_until()函数是将线程休眠至某个指定的时刻(time point),该线程才被重新唤醒；sleep_for()函数是将线程休眠某个指定的时间片(time span)，该线程才被重新唤醒，不过由于线程调度等原因，实际休眠实际可能比sleep_duration所表示的时间片更长。</thread></p>
<h3 id="1-创建一个线程"><a href="#1-创建一个线程" class="headerlink" title="1.创建一个线程"></a>1.创建一个线程</h3><p>创建线程比较简单，使用std的thread实例化一个线程对象就创建完成了，示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //sleep</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span>  <span class="comment">//普通的函数，用来执行线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"t1111\n"</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"t22222\n"</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(t1)</span></span>;  <span class="comment">//实例化一个线程对象th1，使用函数t1构造，然后该线程就开始执行了（t1()）</span></span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(t2)</span></span>;</span><br><span class="line"> </span><br><span class="line">    th1.join(); <span class="comment">// 必须将线程join或者detach 等待子线程结束主进程才可以退出</span></span><br><span class="line">    th2.join(); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//or use detach</span></span><br><span class="line">    <span class="comment">//th1.detach();</span></span><br><span class="line">    <span class="comment">//th2.detach();</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"here is main\n\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述提到的问题，还可以使用detach来解决，detach是用来和线程对象分离的，这样线程可以独立地执行，不过这样由于没有thread对象指向该线程而失去了对它的控制，当对象析构时线程会继续在后台执行，但是当主程序退出时并不能保证线程能执行完。如果没有良好的控制机制或者这种后台线程比较重要，最好不用detach而应该使用join。</p>
<h3 id="2-mutex和std-lock-guard的使用"><a href="#2-mutex和std-lock-guard的使用" class="headerlink" title="2. mutex和std::lock_guard的使用"></a>2. mutex和std::lock_guard的使用</h3><p>头文件是#include <mutex>，mutex是用来保证线程同步的，防止不同的线程同时操作同一个共享数据。</mutex></p>
<p>但使用lock_guard则相对安全，它是基于作用域的，能够自解锁，当该对象创建时，它会像m.lock()一样获得互斥锁，当生命周期结束时，它会自动析构(unlock)，不会因为某个线程异常退出而影响其他线程。示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lockGuard</span><span class="params">(m)</span></span>;</span><br><span class="line">       <span class="comment">// std::m.lock();</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//sleep(1);</span></span><br><span class="line">            --cnt;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// std::m.unlock();</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lockGuard</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="comment">// std::m.lock();</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// std::m.unlock();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">th1</span><span class="params">(t1)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">th2</span><span class="params">(t2)</span></span>;</span><br><span class="line"> </span><br><span class="line">	th1.join();    <span class="comment">//等待t1退出</span></span><br><span class="line">	th2.join();    <span class="comment">//等待t2退出</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"here is the main()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果，cnt是依次递减的，没有因为多线程而打乱次序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="function">here is the <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++虚函数与纯虚函数区别和重载的概念</title>
    <url>/2020/04/04/C-%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>虚函数是在类中添加函数的修饰关键字“Virtual”，且对它进行定义，这时函数变被指定为虚函数。格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CInterFace</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func_Virtual</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。</p>
<h3 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h3><p>为了方便使用多态特性，常常需要在基类中定义虚函数。下面顺便列出C++实现多态的三个条件：</p>
<p>（1）在基类中将这些成员函数声明为虚函数，并实现（必须要实现）。</p>
<p>（2）在派生类中也声明这些成员函数并实现（必须实现），基类和派生类的这些函数必须同名，而且其形参个数和类型，返回值类型必须与基类中的这些函数完全相同。</p>
<p>（3）将派生类对象赋给基类的指针变量或者引用。至此，多态实现，可用基类指针或引用调用派生类的方法（符合多态条件的方法，而不是普通方法）。</p>
<p>相应的不是多态的情况：</p>
<p>（1）基类中声明为虚函数，派生类中也声明为虚函数，并且也同名。但是派生类中该函数的形参类型或者形参个数和基类中的不相同。此时，多态不满足，派生类和基类的这两个虚函数仅仅是隐藏关系，没有虚特性。</p>
<p>（2）基类中声明为虚函数，派生类中也声明了一个同名函数，但没有使用virtual，并且形参类型或者形参个数和基类不相同。这时候基类中的虚函数也丢失虚特性，派生类的该函数不会被虚化，当然也就够不成多态，这两个函数也仅仅是隐藏关系。</p>
<p>（3）基类中的函数不是虚函数，派生类中声明为虚函数，它们同名，这时也够不成多态，派生类的虚函数没有虚特性，它们也是隐藏关系。</p>
<p>（4）基类和派生类的两个函数同名，都是虚函数，形参的个数和类型也都相同，但是返回值类型不同，这时编译会报错，因为两个虚函数在隐藏时，返回值类型发生了冲突，因此隐藏发生错误。注意，如果这两个函数不是虚函数，这不会报错，隐藏会成功；同时，如果派生类中是虚函数，基类中不是虚函数，也不过报错，隐藏也是成功的。这也说明，虚化并隐藏时，返回值类型一定要保持相同。</p>
<h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>是通过虚函数表机制来实现的，当类中存在虚函数时，编译器会在类中自动生成一个虚函数表，并由编译器自动生成和维护，virtual 修饰的成员函数会被编译器放入虚函数表中。</p>
<p>虚表指针：指向自己所使用的虚表</p>
<p>虚函数表:虚函数表是顺序存放虚函数地址的，虚表是顺序表，表里存放了虚函数的地址。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>纯虚函数是在基类中声明的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。</p>
<p>在基类中实现纯虚函数的方法是在函数原型后加“=0”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CInterFace</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func_PureVirtual</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。包含纯虚函数的类叫做抽象类（ 也叫接口类） ， 抽象类不能实例化出对象。 纯虚函数在派生类中重新定义以后， 派生类才能实例化出对象。</p>
<h2 id="虚函数和纯虚函数总结"><a href="#虚函数和纯虚函数总结" class="headerlink" title="虚函数和纯虚函数总结"></a>虚函数和纯虚函数总结</h2><ol>
<li><p>虚函数的定义形式：virtual {method body}   纯虚函数的定义形式：virtual { } = 0;</p>
</li>
<li><p>虚函数和纯虚函数可定义在同一个类(class)中，含有纯虚函数的类是抽象类(abstract class)，而含有虚函数的类则不是。</p>
</li>
<li><p>虚函数可以被直接使用，也可以被子类(sub class)重载以后以多态的形式调用，而纯虚函数必须在子类(sub class)中实现该函数才可以使用，因为纯虚函数在基类(base class)只有声明而没有定义。</p>
</li>
<li><p>在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时候要求前期bind,然而虚函数却是动态绑定(run-time bind)，而且被两者修饰的函数生命周期(life recycle)也不一样。</p>
</li>
</ol>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>就是函数或者方法有相同的名称，但是参数列表不同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。</p>
<p>重载的规则：<br>   1、在使用重载时只能通过相同的方法名、不同的参数形式实现。不同的参数可以是参数类型，参数个数，参数顺序（参数类型必须不一样）；</p>
<p>   2、不能通过访问权限、返回类型、抛出的异常进行重载；</p>
<p>   3、方法的异常类型和数目不会对重载造成影响；</p>
<p>成员函数被重载的特征：</p>
<p>（1）相同的范围（在同一个类中）； </p>
<p>（2）函数名字相同； </p>
<p>（3）参数不同； </p>
<p>（4）virtual 关键字可有可无 。</p>
<p><strong>函数重载在同一个作用域内。</strong>，重载绝对不会发生在基类和派生类之间，在同一个类中，重载函数之间必须依靠形参个数或者形参类型来进行区分，不能依靠返回类型。</p>
<h3 id="函数重载与虚函数的区别"><a href="#函数重载与虚函数的区别" class="headerlink" title="函数重载与虚函数的区别"></a>函数重载与虚函数的区别</h3><p>1.函数重载可以用于非成员函数和类的成员函数，而虚函数只能用于类的成员函数</p>
<p>2.函数重载可用于构造函数，而虚函数不能用于构造函数</p>
<p>3.如果对成员函数进行重载，重载的函数与被重载的函数应该是用一个类中的成员函数，不能分属于两个不同继承层次的类，函数重载处理的是横向的重载。虚函数是对同一类族中的基类和派生类的同名函数的处理，即允许在派生类中对基类的成员函数重新定义。虚函数处理的是纵向的同名函数。</p>
<p>4.重载的函数必须具有相同的函数名，函数类型可以相同也可以不同，但函数的参数个数和参数类型二者中至少有一个不同，否则在编译时无法区分。而虚函数则要求同一类族中的所有虚函数的函数名，函数类型，函数的参数个数和参数类型都全部相同，否则就不是重定义了，也就不是虚函数了</p>
<p>5.函数重载是在程序编译阶段确定操作的对象的，属于静态关联。虚函数是在程序运行阶段确定操作对象的，属于动态关联。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈总结</title>
    <url>/2020/04/04/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>单调栈主要回答这样的几种问题</p>
<ul>
<li><p>比当前元素更大的下一个元素</p>
</li>
<li><p>比当前元素更大的前一个元素</p>
</li>
<li><p>比当前元素更小的下一个元素</p>
</li>
<li><p>比当前元素更小的前一个元素</p>
<a id="more"></a>
<p>单调栈的一大优势就是<strong>线性的时间复杂度</strong>，所有的元素只会进栈一次，而且一旦出栈后就不会再进来了。</p>
<p><strong>单调递增栈可以找到左起第一个比当前数字小的元素</strong>。比如数组 [2 1 4 6 5]，刚开始2入栈，数字1入栈的时候，发现栈顶元素2比较大，将2移出栈，此时1入栈。那么2和1都没左起比自身小的数字。然后数字4入栈的时候，栈顶元素1小于4，于是1就是4左起第一个小的数字。此时栈里有1和4，然后数字6入栈的时候，栈顶元素4小于6，于是4就是6左起第一个小的数字。此时栈里有1，4，6，然后数字5入栈的时候，栈顶元素6大于5，将6移除，此时新的栈顶元素4小于5，那么4就是5左起的第一个小的数字，最终栈内数字为1，4，5。</p>
<p>同样的道理，<strong>单调递减栈可以找到左起第一个比当前数字大的元素</strong>。</p>
<h3 id="LeetCode-42：接雨水-（单调递减栈）"><a href="#LeetCode-42：接雨水-（单调递减栈）" class="headerlink" title="LeetCode 42：接雨水 （单调递减栈）"></a>LeetCode 42：接雨水 （单调递减栈）</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
</li>
</ul>
<p><img src="/2020/04/04/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/1.png" alt></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>
<p>分析：</p>
<p>必须两边高，中间低可以装下水，就可以使用一个单调递减栈，将递减的边界存进去，一旦发现当前的数字大于栈顶元素了，那么就有可能会有能装水的地方产生。此时我们当前的数字是右边界，我们从栈中至少需要有两个数字，才能形成一个坑槽，先取出的那个最小的数字，就是坑槽的最低点，再次取出的数字就是左边界，我们比较左右边界，取其中较小的值为装水的边界，然后此高度减去水槽最低点的高度，乘以左右边界间的距离就是装水量了。由于需要知道左右边界的位置，所以我们虽然维护的是递减栈，但是栈中数字并不是存递减的高度，而是递减的高度的坐标。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =<span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty() || <span class="built_in">height</span>[i] &lt; <span class="built_in">height</span>[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span> (s.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> h = <span class="built_in">min</span>(<span class="built_in">height</span>[s.top()],<span class="built_in">height</span>[i]) -  <span class="built_in">height</span>[t];</span><br><span class="line">                <span class="keyword">int</span> w = i-s.top()<span class="number">-1</span>;</span><br><span class="line">                res += h*w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-84：柱状图中最大的矩形（单调递增栈）"><a href="#LeetCode-84：柱状图中最大的矩形（单调递增栈）" class="headerlink" title="LeetCode 84：柱状图中最大的矩形（单调递增栈）"></a>LeetCode 84：柱状图中最大的矩形（单调递增栈）</h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="/2020/04/04/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/2.png" alt></p>
<p>分析：就是找两边第一个小于它的值，比如height[i]，以第i根柱子为最矮柱子所能延伸的最大面积，是以i 为中心，向左找第一个小于 heights[i] 的位置 left_i；向右找第一个小于于 heights[i] 的位置 right_i，即最大面积为 heights[i] * (right_i - left_i -1)，如下图所示:</p>
<p><img src="/2020/04/04/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/3.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 单调递增栈，为保证所有元素都出栈，最后加一个0</span></span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty() || heights[i] &gt; heights[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 出栈是计算以栈顶元素高度为矩形长的最大矩形面积</span></span><br><span class="line">                <span class="keyword">int</span> t = s.top();  </span><br><span class="line">                <span class="comment">// height[t]高度为最高，寻找左右两端小于高度heights[t]的坐标,右边小于高度t的坐标为i，</span></span><br><span class="line">                <span class="comment">// 如果出栈后不为空，则左边小于高度t的坐标为s.top(), 因为维持递增序列，</span></span><br><span class="line">                <span class="comment">// 出栈后下一个栈顶是小于高度t的，为空则说明左边没有小于高度t的</span></span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    w = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 注意-1</span></span><br><span class="line">                    w = i - s.top() - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, heights[t] * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-496：下一个更大元素-I（单调递减栈-哈希表）"><a href="#LeetCode-496：下一个更大元素-I（单调递减栈-哈希表）" class="headerlink" title="LeetCode 496：下一个更大元素 I（单调递减栈+哈希表）"></a>LeetCode 496：下一个更大元素 I（单调递减栈+哈希表）</h3><p>给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字2，第二个数组中的下一个较大数字是3。</span><br><span class="line">    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 单调递减栈 寻找nums2数组对应元素右起的比它大的数</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;n2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty()|| nums2[i]&lt;s.top())</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(nums2[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                m[t] = nums2[i]; </span><br><span class="line">                <span class="comment">// 哈希表存储对应的数字的下一个更大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 没有更大的数</span></span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            m[s.top()] = <span class="number">-1</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(m[num]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-503：下一个更大元素-II（单调不增栈）"><a href="#LeetCode-503：下一个更大元素-II（单调不增栈）" class="headerlink" title="LeetCode 503：下一个更大元素 II（单调不增栈）"></a>LeetCode 503：下一个更大元素 II（单调不增栈）</h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<p>如果不是循环数组，就可以写成如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty()||nums[i]&lt;nums[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                res[t] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>循环数组形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="comment">// 循环数组，相当于复制两次数组，遍历两次，一般环形利用取模运算来实现</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="number">2</span>*n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty() || nums[i%n] &lt;= nums[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(i%n);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="comment">// 只用考虑出栈的元素，在栈里边的不用考虑</span></span><br><span class="line">                res[t] = nums[i%n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-739：-每日温度（单调不增栈）"><a href="#LeetCode-739：-每日温度（单调不增栈）" class="headerlink" title="LeetCode 739： 每日温度（单调不增栈）"></a>LeetCode 739： 每日温度（单调不增栈）</h3><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>分析：</p>
<p>利用单调不增栈，当当前元素严格大于栈顶元素才出栈。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = T.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty() || T[i] &lt;= T[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                res[t] = i-t;  <span class="comment">//  注意返回的是两坐标之差</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>至于最后一点要说的就是，如何确定是使用严格单调栈还是非严格单调栈？<strong>只要根据题意确定我们栈中是否可以存放相同元素即可</strong></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找算法总结</title>
    <url>/2020/04/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="二分查找算法总结"><a href="#二分查找算法总结" class="headerlink" title="二分查找算法总结"></a>二分查找算法总结</h1><p>二分查找法作为一种常见的查找方法，将原本是线性时间提升到了对数时间范围，大大缩短了搜索时间，具有很大的应用场景，而在 LeetCode 中，要运用二分搜索法来解的题目也有很多，但是实际上二分查找法的查找目标有很多种，而且在细节写法也有一些变化。我就对二分查找法的具体写法做个总结。</p>
<a id="more"></a>
<h2 id="基础-二分查找的框架"><a href="#基础-二分查找的框架" class="headerlink" title="基础: 二分查找的框架"></a>基础: 二分查找的框架</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>,<span class="built_in">end</span> = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid =  start + (<span class="built_in">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) </span><br><span class="line">        &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) </span><br><span class="line">        &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析二分查找的一个技巧是：不要出现 <code>else</code>，而是把所有情况用 <code>else if</code> 写清楚，这样可以清楚地展现所有细节。本文都会使用 <code>else if</code>，旨在讲清楚，读者理解后可自行简化。</p>
<p>其中 … 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p>
<p>另外声明一下，计算 <code>mid</code> 时需要技巧防止溢出，在 <code>start</code> 和 <code>end</code> 都比较大的时候，<code>start + end</code> 很有可能超过 <code>int</code> 类型能表示的最大值，即整型溢出，为了避免这个问题，应该写成： <code>mid=start+(end-start)/2</code>。事实上，<code>int mid = start + (end - start) / 2</code> 在 <code>end</code> 很大、 <code>start</code> 是负数且很小的时候， <code>end - start</code> 也有可能超过 <code>int</code> 类型能表示的最大值，只不过一般情况下 <code>end</code> 和 <code>start</code> 表示的是数组索引值，<code>start</code> 是非负数，因此 <code>end - start</code> 溢出的可能性很小。更好的写法是：<code>int mid = (start + end) &gt;&gt;&gt; 1</code> .</p>
<h2 id="第一类：寻找一个数（基本的二分查找）"><a href="#第一类：寻找一个数（基本的二分查找）" class="headerlink" title="第一类：寻找一个数（基本的二分查找）"></a>第一类：寻找一个数（基本的二分查找）</h2><p>这是最简单的一类，也是我们最开始学二分查找法需要解决的问题,即搜索一个数，如果存在，返回其索引，否则返回 -1，比如我们有数组 <code>[2, 4, 5, 6, 9]</code>，<code>target = 6</code>，那么我们可以写出二分查找法的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">end</span>&gt;=start)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = start + (<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid]==target)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        start = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Q&amp;A:</strong></p>
<p>1.为什么<code>while</code>循环的条件中是 &lt;=，而不是 &lt; ？</p>
<p>答：因为初始化 <code>end</code> 的赋值是 <code>n-1</code>，即最后一个元素的索引，而不是 <code>n</code>。<br>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[start, end]</code>，后者相当于左闭右开区间 <code>[start, end)</code>，因为索引大小为 <code>n</code> 是越界的。</p>
<p>我们这个算法中使用的是前者 <code>[start, end]</code> 两端都闭的区间。这个区间其实就是每次进行搜索的区间，我们称之为「搜索区间」。</p>
<p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br></pre></td></tr></table></figure>
<p>但如果没找到，就需要 <code>while</code> 循环终止，然后返回 <code>-1</code>。那 <code>while</code> 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到。</p>
<p><code>while(start &lt;= end)</code> 的终止条件是 <code>start == end + 1</code>，写成区间的形式就是 <code>[end + 1, end]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见这时候搜索区间为空，这时候 <code>while</code> 循环终止是正确的，直接返回 <code>-1</code> 即可。</p>
<p><code>while(start &lt; end)</code> 的终止条件是 <code>start == end</code>，写成区间的形式就是 <code>[start, end]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，这时候搜索区间非空，还有一个数<code>2</code>，但此时 <code>while</code> 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 <code>2</code>没有被搜索，如果这时候直接返回 <code>-1</code> 就是错误的。</p>
<p>2.为什么 <code>start = mid + 1</code>，<code>end = mid - 1</code>？我看有的代码是 <code>start = mid</code> 或者 <code>end = mid</code>，没有这些加1减1，如何判断？</p>
<p>答：这也是二分查找的一个难点，刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[start, end]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，如何确定下一步的搜索区间呢？</p>
<p>当然是 <code>[start, mid - 1]</code> 或者 <code>[mid + 1, end]</code> 对不对？因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除。</p>
<p>3.此算法有什么缺陷？</p>
<p>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</p>
<p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target = 2</code>，此算法返回的索引是 <code>2</code>，没错。但是如果我们想得到 <code>target</code> 的左侧边界，即索引 <code>1</code>，或者我想得到 <code>target</code> 的右侧边界，即索引 <code>3</code>，这样的话此算法是无法处理的。</p>
<p>这样的需求很常见。你也许会说，找到一个 <code>target</code>，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。</p>
<p>我们后续的算法就来讨论这两种二分查找的算法。</p>
<h2 id="第二类：寻找左侧边界的二分搜索"><a href="#第二类：寻找左侧边界的二分搜索" class="headerlink" title="第二类：寻找左侧边界的二分搜索"></a>第二类：寻找左侧边界的二分搜索</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">end</span>&gt;start)  <span class="comment">// 搜索区间左闭右开</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = start + (<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid]==target)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">end</span> = mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        start = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">end</span> = mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// start == n时说明target比所有数都大，不存在返回-1</span></span><br><span class="line">    <span class="comment">// if (nums[start]!=target || start == n) return -1;</span></span><br><span class="line">    <span class="comment">// 返回start是返回的数组中的坐标，就是小于某个数的坐标</span></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Q&amp;A:</strong></p>
<p>1.为什么 <code>while(start &lt; end)</code> 而不是 <code>&lt;=</code>?</p>
<p>答：用相同的方法分析，因为 <code>end = n</code> 而不是 <code>n - 1</code> 。因此每次循环的「搜索区间」是 <code>[start, end)</code> 左闭右开。<br><code>while(start &lt; end)</code> 终止的条件是 <code>start == end</code>，此时搜索区间 <code>[start, start)</code>或者写成<code>[end, end)</code>为空，所以可以正确终止。</p>
<p>2.如何理解左侧边界？</p>
<p>答：</p>
<p><img src="/2020/04/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1.png" alt="1"></p>
<p>对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：<code>nums</code> 中小于 2的元素有 1 个。</p>
<p>比如对于有序数组 <code>nums = [2,3,5,7]</code>, <code>target = 1</code>，算法会返回 <code>0</code>，含义是：<code>nums</code> 中小于 1 的元素有 0 个。</p>
<p>再比如说 <code>nums</code> 不变，<code>target = 8</code>，算法会返回 4，含义是：<code>nums</code> 中小于 8 的元素有 4 个。</p>
<p>综上可以看出，函数的返回值（即 <code>start</code> 变量的值）取值区间是闭区间 <code>[0, n]</code>，如果start的值为<code>n</code>或者<code>nums[start]!=target</code>说明数组中没有目标值，返回-1</p>
<p>3.为什么 <code>start = mid + 1</code>，<code>end = mid</code> ？和之前的算法不一样？</p>
<p>答：这个很好解释，因为我们的「搜索区间」是 <code>[start, end)</code> <strong>左闭右开</strong>，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 <code>[start, mid)</code> 或 <code>[mid + 1, end)</code>。</p>
<p>4.为什么该算法能够搜索左侧边界？</p>
<p>答:关键在于对于 nums[mid] == target 这种情况的处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">    <span class="built_in">end</span> = mid;</span><br></pre></td></tr></table></figure>
<p>可见，找到 <code>target</code> 时不要立即返回，而是缩小「搜索区间」的上界 <code>end</code>，在区间 <code>[start, end)</code> 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p>
<p>5.为什么返回 <code>start</code> 而不是 <code>end</code>？</p>
<p>答：都是一样的，因为 <code>while</code> 终止的条件是 <code>start == end</code>。</p>
<h2 id="第三类：寻找右侧边界的二分查找"><a href="#第三类：寻找右侧边界的二分查找" class="headerlink" title="第三类：寻找右侧边界的二分查找"></a>第三类：寻找右侧边界的二分查找</h2><p>寻找右侧边界和寻找左侧边界的代码差不多，只有两处不同，已标注：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">end</span>&gt;start)  <span class="comment">// 搜索区间左开右闭</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = start + (<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid]==target)</span><br><span class="line">      &#123;</span><br><span class="line">        start = mid + <span class="number">1</span>;  <span class="comment">// 注意 增大左边界，向右收缩</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        start = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">end</span> = mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span><span class="number">-1</span>;  <span class="comment">//注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Q&amp;A:</strong></p>
<ol>
<li>为什么这个算法能够找到右侧边界？</li>
</ol>
<p>答：类似地，关键点还是这里：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid]==target)</span><br><span class="line">    start = mid + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>当 <code>nums[mid] == target</code> 时，不要立即返回，而是增大「搜索区间」的下界 <code>start</code>，使得区间不断向右收缩，达到锁定右侧边界的目的。</p>
<p>2.为什么最后返回 <code>end - 1</code> 而不像左侧边界的函数，返回 <code>start</code>？而且我觉得这里既然是搜索右侧边界，应该返回 <code>end</code> 才对。</p>
<p>答：首先，<code>while</code> 循环的终止条件是 <code>start == end</code>，所以 <code>start</code> 和 <code>end</code> 是一样的，要体现右侧的特点，返回 <code>end - 1</code> 好了。</p>
<p>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">    start = mid + <span class="number">1</span>;<span class="comment">//等价于：mid = start - 1</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/2.png" alt="2"></p>
<p>因为我们对 <code>start</code> 的更新必须是 <code>start = mid + 1</code>，就是说 <code>while</code> 循环结束时，<code>nums[start]</code> 一定不等于 <code>target</code> 了，而 <code>nums[start-1]</code> 可能是 <code>target</code>,也就是<code>return end-1</code>。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>来梳理一下这些细节差异的因果逻辑：</p>
<p>第一个，最基本的二分查找算法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因为我们初始化 end &#x3D; nums.size() - 1</span><br><span class="line">所以决定了我们的「搜索区间」是 [start, end]</span><br><span class="line">所以决定了 while (start &lt;&#x3D; end)</span><br><span class="line">同时也决定了 start &#x3D; mid+1 和 end &#x3D; mid-1</span><br><span class="line"></span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] &#x3D;&#x3D; target 时可以立即返回</span><br></pre></td></tr></table></figure>

<p>第二个，寻找左侧边界的二分查找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因为我们初始化 end &#x3D; nums.size()</span><br><span class="line">所以决定了我们的「搜索区间」是 [start, end)</span><br><span class="line">所以决定了 while (start &lt; end)</span><br><span class="line">同时也决定了 start &#x3D; mid + 1 和 end &#x3D; mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] &#x3D;&#x3D; target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br></pre></td></tr></table></figure>

<p>第三个，寻找右侧边界的二分查找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因为我们初始化 end &#x3D; nums.size()</span><br><span class="line">所以决定了我们的「搜索区间」是 (start, end]</span><br><span class="line">所以决定了 while (start &lt; end)</span><br><span class="line">同时也决定了 start &#x3D; mid + 1 和 end &#x3D; mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] &#x3D;&#x3D; target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line"></span><br><span class="line">又因为收紧左侧边界时必须 start &#x3D; mid + 1</span><br><span class="line">所以最后无论返回 start 还是 end，必须减一</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++二维数组按行遍历和按列遍历的区别</title>
    <url>/2020/04/03/C-%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E5%92%8C%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>按行遍历的效率更高。</p>
<p>数组在内存中是按行储存的，按行遍历时可以由指向数组第一个数的指针一直往下走，就可以遍历完整个数组，而按列遍历则要获得指向每一列的第一行的元素的指针，然后每次将指针指下一行，但是指针的寻址很快，所以不会有明显的区别。</p>
<a id="more"></a>

<p>按行遍历比按列遍历效率高具体体现在以下几点</p>
<p>1、<a href="https://zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98" target="_blank" rel="noopener external nofollow noreferrer">CPU高速缓存</a></p>
<p>计算机存在Cache机制，当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在，则不经访问内存直接返回该数据；如果不存在，则要先把内存中的相应数据载入缓存，再将其返回处理器。</p>
<p>缓存从内存中抓取一般都是整个数据块，所以它的物理内存是连续的，几乎都是同行不同列的，而如果内循环以列的方式进行遍历的话，将会使整个缓存块无法被利用，而不得不从内存中读取数据，而从内存读取速度是远远小于从缓存中读取数据的。</p>
<p>2、分页调度</p>
<p>物理内存是以页的方式进行划分的，当一个二维数组很大是如 int[128][1024],假设一页的内存为4096个字节，而每一行正好占据内存的一页（int 存储是4个字节），如果以列的形式进行遍历，就会发生128*1024次的页面调度，而如果以行遍历则只有128次页面调度，而页面调度是有时间消耗的，因而调度次数越多，遍历的时间就越长。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>vector扩容原理说明</title>
    <url>/2020/04/02/vector%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h3 id="扩容原理概述"><a href="#扩容原理概述" class="headerlink" title="扩容原理概述"></a>扩容原理概述</h3><ul>
<li>新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素</li>
<li>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了</li>
<li>初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1</li>
<li>不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。<a id="more"></a>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.push_back(i);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><ul>
<li>GCC输出</li>
</ul>
<p><img src="/2020/04/02/vector%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E/1.png" alt></p>
<ul>
<li>VS2015输出</li>
</ul>
<p><img src="/2020/04/02/vector%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E/2.png" alt></p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><ul>
<li><p>可以根据输出看到，vector是以2倍的方式扩容的。有两个疑问：</p>
<ul>
<li>为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？</li>
<li>为什么是以两倍的方式扩容而不是三倍四倍，或者其他方式呢？</li>
</ul>
</li>
<li><p>第一个问题：</p>
<ul>
<li><p>以成倍方式增长</p>
<ol>
<li>假定有 n 个元素,倍增因子为 m；</li>
<li>完成这 n 个元素往一个 vector 中的 push_back​操作，需要重新分配内存的次数大约为 logm(n)；</li>
<li>第 i 次重新分配将会导致复制 m^(i) (也就是当前的vector.size() 大小)个旧空间中元素;</li>
<li>n 次 push_back 操作所花费的时间复制度为O(n):<br>$$<br>\sum_{i=1}^{\log _{n}^{n}} m^{i} \approx \frac{n m}{m-1}<br>$$</li>
<li>m / (m - 1)，这是一个常量，均摊分析的方法可知，vector 中 push_back 操作的时间复杂度为常量时间.​</li>
</ol>
</li>
<li><p>一次增加固定值大小</p>
<ol>
<li>假定有 n 个元素,每次增加k个；</li>
<li>第i次增加复制的数量为为：100i</li>
<li>n 次 push_back 操作所花费的时间复杂度为O(n^2):<br>$$\sum_{i=1}^{n / k} k i$$</li>
<li>均摊下来每次push_back 操作的时间复杂度为O(n)；</li>
</ol>
</li>
</ul>
</li>
<li><p>总结：对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。</p>
</li>
<li><p>第二个问题：</p>
<ol>
<li><p>根据查阅的资料显示，考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2二倍的方式扩容，或者以1.5倍的方式扩容。</p>
</li>
<li><p>以2倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间:</p>
<p>$$k \sum_{i=0}^{n} 2^{i}=k\left(2^{n+1}-1\right)&lt;k 2^{n+1}$$</p>
<p><a href="https://www.zhihu.com/question/36538542/answer/67929747" target="_blank" rel="noopener external nofollow noreferrer">知乎上看到一个很好的解释</a></p>
</li>
</ol>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。</p>
</li>
<li><p>为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，更好一点。</p>
</li>
</ol>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://blog.csdn.net/yangshiziping/article/details/52550291" target="_blank" rel="noopener external nofollow noreferrer">vector扩容原理说明</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ vector拷贝使用总结</title>
    <url>/2020/04/02/C-vector%E6%8B%B7%E8%B4%9D%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>一些vector拷贝使用的细节，挖过填过的坑，记录一下。</p>
<p>主要有以下几种方法</p>
<h3 id="初始化构造时拷贝（深复制）"><a href="#初始化构造时拷贝（深复制）" class="headerlink" title="初始化构造时拷贝（深复制）"></a>初始化构造时拷贝（深复制）</h3><p>这种拷贝，相当于复制了一份数据，array中的数据不变。 如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">outArray</span><span class="params">(<span class="built_in">array</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="利用拷贝赋值操作符（深复制）"><a href="#利用拷贝赋值操作符（深复制）" class="headerlink" title="利用拷贝赋值操作符（深复制）"></a>利用拷贝赋值操作符（深复制）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; outArray;</span><br><span class="line">outArray = <span class="built_in">array</span>;</span><br></pre></td></tr></table></figure>

<h3 id="利用assign-函数（清空并深复制）"><a href="#利用assign-函数（清空并深复制）" class="headerlink" title="利用assign()函数（清空并深复制）"></a>利用assign()函数（清空并深复制）</h3><p>一样的复制了一份数据，array中的数据不变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; outArray&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">outArray.assign(<span class="built_in">array</span>.<span class="built_in">begin</span>(),<span class="built_in">array</span>.<span class="built_in">end</span>());<span class="comment">//清空原数据，赋予新数据=&#123;3,5,2,6,4&#125;</span></span><br><span class="line">outArray.assign(<span class="number">5</span>, <span class="number">0</span>);<span class="comment">//5个0，清空原数据=&#123;0,0,0,0,0,&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="利用swap-函数（交换两个vector）"><a href="#利用swap-函数（交换两个vector）" class="headerlink" title="利用swap()函数（交换两个vector）"></a>利用swap()函数（交换两个vector）</h3><p>会清空原vector数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; outArray;<span class="comment">//设为空</span></span><br><span class="line">outArray.swap(<span class="built_in">array</span>);<span class="comment">//清空array数组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; outArray&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">outArray.swap(<span class="built_in">array</span>);<span class="comment">//outArray=&#123;3,5,2,6,4&#125;；array=&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++单例模式Singleton的实现</title>
    <url>/2020/04/01/C-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FSingleton%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="问题情景"><a href="#问题情景" class="headerlink" title="问题情景"></a>问题情景</h3><p>在windows下面打开任务管理器，我们会发现，你只能打开一个任务管理器。如果在已打开一个任务管理器的情况下，再次打开任务管理器，系统会调出已经打开的窗口，而不是重新打开新的窗口。在系统中，之多只能存在一个任务管理器的实例。按照一般的思路，我们需要定义一个TaskManager的类（如下）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TaskManager()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>但这存在问题，只要我们调用一次初始化函数，系统就会生成一个TaskManager的实例，不能保证系统中之多只存在一个实例的要求。于是我们需要采用设计模式中的单例模式（Singleton）来实现。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>单例模式的两个功能：仅有一个实例和全局访问点。我们通过Singleton的类图来看一下这个模式：</p>
<p><img src="/2020/04/01/C-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FSingleton%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png" alt></p>
<p>在Singleton中，类的初始化函数被设为了private，这就意味着Client是不能通过调用类的初始化函数来生成一个实例，防止Client多次调用初始化函数生成多个实例出来。如果要访问Singleton，需要通过GetInstance方法，这是一个静态的方法，主要负责创建自己的实例，返回实例的指针给Client。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)<span class="comment">//第一次调用要判断指针是否为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                p_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Singleton()&#123;&#125;; <span class="comment">//构造函数设计成私有的</span></span><br><span class="line">        <span class="keyword">static</span> Singleton *p_instance; <span class="comment">//用类的指针指向唯一的实例</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//静态数据成员是静态存储的，必须对他进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *object = Singleton::GetInstance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Singleton类封装了它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单的说就是对唯一实例的受控访问。一般的，Singleton不会定义析构函数，由于实例分配的是全局地址，在程序运行结束，被系统收回所有分配空间时，Singleton才会被销毁，如果Singleton成员数据太多的话，可能占用了大量的内存空间而不能被释放，这需要我们注意。</p>
<h3 id="Singleton与全局变量的区别"><a href="#Singleton与全局变量的区别" class="headerlink" title="Singleton与全局变量的区别"></a>Singleton与全局变量的区别</h3><p>Singleton与全局变量都有全局访问的功能，但两者之间存在一些差别，全局变量在使用的过程中会存在一些问题：</p>
<ul>
<li>变量名冲突：必须小心维护变量名，每遇到一个全局变量，都必须仔细分辨该变量属于哪个模块、哪个程序。</li>
<li>耦合度难题：使用全局变量增加了函数与模块间的耦合程度，不易维护。</li>
<li>单个实体问题：全局变量不能防止一个类生成多个实例出来。</li>
<li>多线程访问：并发访问时需要使用同步机制，小心保护全局变量，避免冲突。</li>
</ul>
<p>看起来，使用Singleton可以避免上面的这些问题，但Singleton自身也有一些弊端。</p>
<h3 id="Singleton的优缺点"><a href="#Singleton的优缺点" class="headerlink" title="Singleton的优缺点"></a>Singleton的优缺点</h3><p>Singleton的优点：</p>
<ul>
<li>跨平台：使用合适的中间件可以把Singleton扩展为跨多个计算机工作。</li>
<li>适用于任何类：只要将初始化函数设为私有，并增加相应的静态函数和变量，就能把类变成Singleton。</li>
<li>延迟性：如果Singleton从未使用，就不会创建（仅指懒汉模式）</li>
</ul>
<p>Singleton的缺点：</p>
<ul>
<li>效率问题：由于if语句的存在，调用方法的效率收到影响。</li>
<li>不变重用：在C++下需要定义模板才能实现Singleton的重用。</li>
</ul>
<h3 id="Singleton的懒汉模式与饿汉模式"><a href="#Singleton的懒汉模式与饿汉模式" class="headerlink" title="Singleton的懒汉模式与饿汉模式"></a>Singleton的懒汉模式与饿汉模式</h3><p>针对Singleton初始化函数的调用策略，有两种选择，分别是懒汉模式和饿汉模式。</p>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><p>使用懒汉模式时，Singleton在程序第一次调用的时候才会初始化自己，代码如下。使用该模式时，由于if语句的存在，会影响调用的效率。而且，在多线程环境下使用时，为了保证只能初始化一个实例，需要用锁来保证线程安全性，防止同时多个线程进入if语句中。如果遇到处理大量数据时，锁会成为整个性能的瓶颈。一般懒汉模式适用于程序一部分中需要使用Singleton，且在实例化后没有大量频繁访问或线程访问的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mtx.lock();</span><br><span class="line">                <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    p_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">                mtx.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Singleton()&#123;&#125;; <span class="comment">//构造函数设计成私有的</span></span><br><span class="line">        <span class="keyword">static</span> Singleton *p_instance; <span class="comment">//用类的指针指向唯一的实例</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//静态数据成员是静态存储的，必须对他进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *object = Singleton::GetInstance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>PS:
GCC在Linux下的std::mutex工作良好。 然而，在Windows上很遗憾，
_GLIBCXX_HAS_GTHREADS没有在Windows上定义。mutex运行时支持是不存在的。</code></pre><h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>使用饿汉模式时，Singleton在程序一开始就将自己实例化，之后的GetInstance方法仅返回实例的指针即可，这样就解决了上述提到的if语句影响效率的问题。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Singleton* p_instance = <span class="keyword">new</span> Singleton();<span class="comment">//在此直接实例化</span></span><br><span class="line">        Singleton()&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>饿汉模式适用于Singleton在程序运行过程中一直被频繁调用，这样由于预先加载了实例，访问实例时没有if语句，效率更高。但要注意到，如果Singleton的成员比较庞大、复杂，实例化Singleton会花一些时间，且这个实例一直占用着大量内存，在使用时要注意这部分的开销。使用饿汉模式用于多线程编程的话，由于线程访问之前，实例已存在，就不需要像懒汉模式中加入锁，因此饿汉模式保证了多线程安全。饿汉模式比较适用于程序整个运行过程中都需要访问、会被频繁访问或者需要被多线程访问的情况。</p>
<pre><code>PS:
类名加*，有两种作用情况：
1. 用于定义时，或用于函数参数，返回值时，表示对应变量值为类指针类型；
2. 用于变量前，以(CLASS_NAME *)var_name，形式出现时，表示将变量或
常量var_name强制转换为类指针类型。</code></pre>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++源文件到可执行文件的过程</title>
    <url>/2020/04/01/C-%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>对于C/C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤：</p>
<p>1、预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。</p>
<p>2、编译：将预处理后的文件转换成汇编语言，生成.s文件</p>
<p>3、汇编：汇编变为目标代码(机器代码)生成.o的文件</p>
<p>4、链接：连接目标代码,生成可执行程序</p>
<a id="more"></a>
<p>程序的基本流程如图：</p>
<p><img src="/2020/04/01/C-%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/1.jfif" alt></p>
<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>预处理主要包含下面的内容：</p>
<ul>
<li>对所有的“#define”进行宏展开；</li>
<li>处理所有的条件编译指令，比如“#if”,“#ifdef”，“#elif”，“#else”,“#endif”</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归的，也就是说被包含的文件可能还包含其他文件</li>
<li>删除所有的注释“//”和“/**/”</li>
<li>添加行号和文件标识</li>
<li>保留所有的“#pragma”编译器指令</li>
</ul>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>将预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后，产生相应的汇编代码文件(.s文件)。</p>
<h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p>汇编器是将汇编代码转变成机器可以执行的代码，每一个汇编语句几乎都对应一条机器指令。最终产生目标文件(.o或.obj文件)。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>连接目标代码,生成可执行程序。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针详解</title>
    <url>/2020/04/01/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>智能指针分为三种：shared_ptr, unique_ptr, weak_ptr。本文就是详细介绍一下智能指针，作为笔记，方便理解。</p>
<p>智能指针的作用是动态分配内存，避免内存泄漏。</p>
<a id="more"></a>
<pre><code>PS:
内存泄漏：
    程序没有释放已经不再使用的内存，由于设计错误，导致在释放该段内存
    之前就失去了对该段内存的控制，因此这段内存一直被占用，无法释放，造
    成空间的浪费。

内存溢出：
    要求分配的内存超过了系统所能给我的，系统不能满足需求。内存泄漏的堆
    积如果不及时处理最终会导致内存溢出。</code></pre><h2 id="shared-ptr介绍"><a href="#shared-ptr介绍" class="headerlink" title="shared_ptr介绍"></a>shared_ptr介绍</h2><p>shared_ptr是一个引用计数智能指针，用于共享对象的所有权，也就是说它允许多个指针指向同一个对象</p>
<h3 id="shared-ptr的简单使用："><a href="#shared-ptr的简单使用：" class="headerlink" title="shared_ptr的简单使用："></a>shared_ptr的简单使用：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Example() : e(<span class="number">1</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Example Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">        ~Example() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Example Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Example&gt; <span class="title">pInt</span><span class="params">(<span class="keyword">new</span> Example())</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*pInt).e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pInt引用计数: "</span> &lt;&lt; pInt.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Example&gt; pInt2 = pInt;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pInt引用计数: "</span> &lt;&lt; pInt.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pInt2引用计数: "</span> &lt;&lt; pInt2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Example Constructor...</span><br><span class="line">pInt: <span class="number">1</span></span><br><span class="line">pInt引用计数: <span class="number">1</span></span><br><span class="line">pInt引用计数: <span class="number">2</span></span><br><span class="line">pInt2引用计数: <span class="number">2</span></span><br><span class="line">Example Destructor...</span><br></pre></td></tr></table></figure>
<p>从上面这段代码中，我们对shared_ptr指针有了一些直观的了解。一方面，跟STL中大多数容器类型一样，shared_ptr也是模板类，因此在创建shared_ptr时需要指定其指向的类型。另一方面，正如其名一样，shared_ptr指针允许让多个该类型的指针共享同一堆分配对象。同时shared_ptr使用经典的“引用计数”方法来管理对象资源，每个shared_ptr对象关联一个共享的引用计数。</p>
<p>对于shared_ptr在拷贝和赋值时的行为，《C++Primer第五版》中有详细的描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个shared_ptr都有一个关联的计数值，通常称为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。</span><br><span class="line"></span><br><span class="line">例如，当用一个shared_ptr初始化另一个shred_ptr，或将它当做参数传递给一</span><br><span class="line">个函数以及作为函数的返回值时，它所关联的计数器就会递增。</span><br><span class="line"></span><br><span class="line">当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的</span><br><span class="line">shared_ptr离开其作用域）时，计数器就会递减。一旦一个shared_ptr的计数</span><br><span class="line">器变为0，它就会自动释放自己所管理的对象。</span><br></pre></td></tr></table></figure>

<p>对比我们上面的代码可以看到：当我们将一个指向Example对象的指针交给pInt管理后，其关联的引用计数为1。接下来，我们用pInt初始化pInt2，两者关联的引用计数值增加为2。随后，函数结束，pInt和PInt2相继离开函数作用于，相应的引用计数值分别自减1最后变为0，于是Example对象被自动释放（调用其析构函数）。</p>
<h3 id="shared-ptr的常见用法"><a href="#shared-ptr的常见用法" class="headerlink" title="shared_ptr的常见用法"></a>shared_ptr的常见用法</h3><h4 id="1、创建shared-ptr实例"><a href="#1、创建shared-ptr实例" class="headerlink" title="1、创建shared_ptr实例"></a>1、创建shared_ptr实例</h4><p>最安全和高效的方法是调用make_shared库函数，该函数会在堆中分配一个对象并初始化，最后返回指向此对象的share_ptr实例。如果你不想使用make_ptr，也可以先明确new出一个对象，然后把其原始指针传递给share_ptr的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递给make_shared函数的参数必须和shared_ptr所指向类型的某个构造函数相匹配</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pStr = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pStr &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//  aaaaaaaaaa</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pInt</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pInt &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、访问所指对象"><a href="#2、访问所指对象" class="headerlink" title="2、访问所指对象"></a>2、访问所指对象</h4><p>shared_ptr的使用方式与普通指针的使用方式类似，既可以使用解引用操作符*获得原始对象进而访问其各个成员，也可以使用指针访问符-&gt;来访问原始对象的各个成员。</p>
<h4 id="3、拷贝和赋值操作"><a href="#3、拷贝和赋值操作" class="headerlink" title="3、拷贝和赋值操作"></a>3、拷贝和赋值操作</h4><p>我们可以用一个shared_ptr对象来初始化另一个share_ptr实例，该操作会增加其引用计数值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pStr = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//  1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pStr2</span><span class="params">(pStr)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//  2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr2.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//  2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果shared_ptr实例p和另一个shared_ptr实例q所指向的类型相同或者可以相互转换，我们还可以进行诸如p = q这样赋值操作。该操作会递减p的引用计数值，递增q的引用计数值。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Example(<span class="built_in">string</span> n) : name(n) &#123; <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~Example() &#123; <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Example&gt; pStr = make_shared&lt;Example&gt;(<span class="string">"a object"</span>);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Example&gt; pStr2 = make_shared&lt;Example&gt;(<span class="string">"b object"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    pStr = pStr2;   <span class="comment">// 此后pStr和pStr指向相同对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr2-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a object constructor...</span><br><span class="line">b object constructor...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">a object destructor...</span><br><span class="line">b object</span><br><span class="line">b object</span><br><span class="line">b object destructor...</span><br></pre></td></tr></table></figure>

<h4 id="4、检查引用计数"><a href="#4、检查引用计数" class="headerlink" title="4、检查引用计数"></a>4、检查引用计数</h4><p>shared_ptr提供了两个函数来检查其共享的引用计数值，分别是unique()和use_count()。</p>
<p>在前面，我们已经多次使用过use_count()函数，该函数返回当前指针的引用计数值。值得注意的是use_count()函数可能效率很低，应该只把它用于测试或调试。</p>
<p>unique()函数用来测试该shared_ptr是否是原始指针唯一拥有者，也就是use_count()的返回值为1时返回true，否则返回false。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pStr = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr.unique() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pStr2</span><span class="params">(pStr)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr2.unique() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// false;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="weak-ptr介绍"><a href="#weak-ptr介绍" class="headerlink" title="weak_ptr介绍"></a>weak_ptr介绍</h2><p>在正式介绍weak_ptr之前，我们先来回忆一下shared_ptr的一些知识。我们知道shared_ptr是采用引用计数的智能指针，多个shared_ptr实例可以指向同一个动态对象，并维护了一个共享的引用计数器。对于引用计数法实现的计数，总是避免不了循环引用（或环形引用）的问题，shared_ptr也不例外。</p>
<p>我们先来看看下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassB&gt; pb;  <span class="comment">// 在A中引用B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassA&gt; pa;  <span class="comment">// 在B中引用A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassA&gt; spa = make_shared&lt;ClassA&gt;();</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassB&gt; spb = make_shared&lt;ClassB&gt;();</span><br><span class="line">    spa-&gt;pb = spb;</span><br><span class="line">    spb-&gt;pa = spa;</span><br><span class="line">    <span class="comment">// 函数结束，思考一下：spa和spb会释放资源么？</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClassA Constructor...</span><br><span class="line">ClassB Constructor...</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>从上面代码中，ClassA和ClassB间存在着循环引用，从运行结果中我们可以看到：当main函数运行结束后，spa和spb管理的动态资源并没有得到释放，产生了内存泄漏。</p>
<p>为了解决类似这样的问题，C++11引入了weak_ptr，来打破这种循环引用。</p>
<p>weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。</p>
<h3 id="weak-ptr用法"><a href="#weak-ptr用法" class="headerlink" title="weak_ptr用法"></a>weak_ptr用法</h3><h4 id="1、创建weak-ptr实例"><a href="#1、创建weak-ptr实例" class="headerlink" title="1、创建weak_ptr实例"></a>1、创建weak_ptr实例</h4><p>当我们创建一个weak_ptr时，需要用一个shared_ptr实例来初始化weak_ptr，由于是弱共享，weak_ptr的创建并不会影响shared_ptr的引用计数值。</p>
<p>示例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建前sp的引用计数："</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// use_count = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建后sp的引用计数："</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// use_count = 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、判断weak-ptr指向对象是否存在"><a href="#2、判断weak-ptr指向对象是否存在" class="headerlink" title="2、判断weak_ptr指向对象是否存在"></a>2、判断weak_ptr指向对象是否存在</h4><p>既然weak_ptr并不改变其所共享的shared_ptr实例的引用计数，那就可能存在weak_ptr指向的对象被释放掉这种情况。这时，我们就不能使用weak_ptr直接访问对象。那么我们如何判断weak_ptr指向对象是否存在呢？C++中提供了lock函数来实现该功能。如果对象存在，lock()函数返回一个指向共享对象的shared_ptr，否则返回一个空shared_ptr。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : a(<span class="number">3</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;A&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="comment">//sp.reset();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">shared_ptr</span>&lt;A&gt; pa = wp.lock())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pa-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"wp指向对象为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把sp.reset()这行的注释去掉会导致wp指向对象为空。</p>
<p>weak_ptr还提供了expired()函数来判断所指对象是否已经被销毁。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : a(<span class="number">3</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;A&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    sp.reset(); <span class="comment">// 此时sp被销毁</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; wp.expired() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// true表示已被销毁，否则为false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A Constructor...</span><br><span class="line">A Destructor...</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="3、具体使用weak-ptr"><a href="#3、具体使用weak-ptr" class="headerlink" title="3、具体使用weak_ptr"></a>3、具体使用weak_ptr</h4><p>weak_ptr并没有重载operator-&gt;和operator *操作符，因此不可直接通过weak_ptr使用对象，典型的用法是调用其lock函数来获得shared_ptr示例，进而访问原始对象.</p>
<p>下面使用weak_ptr来改造最前面的代码，打破循环引用问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    weak_ptr&lt;ClassB&gt; pb;  <span class="comment">// 在A中引用B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    weak_ptr&lt;ClassA&gt; pa;  <span class="comment">// 在B中引用A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassA&gt; spa = make_shared&lt;ClassA&gt;();</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassB&gt; spb = make_shared&lt;ClassB&gt;();</span><br><span class="line">    spa-&gt;pb = spb;</span><br><span class="line">    spb-&gt;pa = spa;</span><br><span class="line">    <span class="comment">// 函数结束，思考一下：spa和spb会释放资源么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从运行结果可以看到spa和spb指向的对象都得到释放。</p>
<h2 id="unique-ptr介绍"><a href="#unique-ptr介绍" class="headerlink" title="unique_ptr介绍"></a>unique_ptr介绍</h2><p>unique是独特的、唯一的意思，故名思议，unique_ptr可以“独占”地拥有它所指向的对象，它提供一种严格意义上的所有权。这一点和我们前面介绍的shared_ptr类型指针有很大的不同：shared_ptr允许多个指针指向同一对象，而unique_ptr在某一时刻只能有一个指针指向该对象。unique_ptr保存指向某个对象的指针，当它本身被删除或者离开其作用域时会自动释放其指向对象所占用的资源。</p>
<p>下图演示了两个 unique_ptr 实例之间的所有权转换。</p>
<p><img src="/2020/04/01/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/unique_ptr.png" alt></p>
<h3 id="unique-ptr的基本特性"><a href="#unique-ptr的基本特性" class="headerlink" title="unique_ptr的基本特性"></a>unique_ptr的基本特性</h3><h4 id="1、创建unique-ptr"><a href="#1、创建unique-ptr" class="headerlink" title="1、创建unique_ptr"></a>1、创建unique_ptr</h4><p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个unique_ptr实例</span></span><br><span class="line">    <span class="comment">// unique_ptr&lt;int&gt; pInt(new int(5));</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、无法进行复制构造和赋值操作"><a href="#2、无法进行复制构造和赋值操作" class="headerlink" title="2、无法进行复制构造和赋值操作"></a>2、无法进行复制构造和赋值操作</h4><p>unique_ptr没有copy构造函数，不支持普通的拷贝和赋值操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个unique_ptr实例</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pInt2</span><span class="params">(pInt)</span></span>;    <span class="comment">// 报错</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt3 = pInt;   <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、可以进行移动构造和移动赋值操作"><a href="#3、可以进行移动构造和移动赋值操作" class="headerlink" title="3、可以进行移动构造和移动赋值操作"></a>3、可以进行移动构造和移动赋值操作</h4><p>unique_ptr虽然没有支持普通的拷贝和赋值操作，但却提供了一种移动机制来将指针的所有权从一个unique_ptr转移给另一个unique_ptr。如果需要转移所有权，可以使用std::move()函数。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt2 = <span class="built_in">std</span>::<span class="built_in">move</span>(pInt);    <span class="comment">// 转移所有权</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *pInt &lt;&lt; endl; // 出错，pInt为空</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pInt2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pInt3</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(pInt2))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、可以返回unique-ptr"><a href="#4、可以返回unique-ptr" class="headerlink" title="4、可以返回unique_ptr"></a>4、可以返回unique_ptr</h4><p>unique_ptr不支持拷贝操作，但却有一个例外：可以从函数中返回一个unique_ptr。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> pInt;    <span class="comment">// 返回unique_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ret = clone(p);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr使用场景"><a href="#unique-ptr使用场景" class="headerlink" title="unique_ptr使用场景"></a>unique_ptr使用场景</h3><h4 id="1、为动态申请的资源提供异常安全保证"><a href="#1、为动态申请的资源提供异常安全保证" class="headerlink" title="1、为动态申请的资源提供异常安全保证"></a>1、为动态申请的资源提供异常安全保证</h4><p>我们先来看看下面这一段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（可能会抛出异常）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是我们传统的写法：当我们动态申请内存后，有可能我们接下来的代码由于抛出异常或者提前退出（if语句）而没有执行delete操作。</p>
<p>解决的方法是使用unique_ptr来管理动态内存，只要unique_ptr指针创建成功，其析构函数都会被调用。确保动态资源被释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（可能会抛出异常）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、返回函数内动态申请资源的所有权"><a href="#2、返回函数内动态申请资源的所有权" class="headerlink" title="2、返回函数内动态申请资源的所有权"></a>2、返回函数内动态申请资源的所有权</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Func</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> pInt;    <span class="comment">// 返回unique_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ret = Func(p);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 函数结束后，自动释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、在容器中保存指针"><a href="#3、在容器中保存指针" class="headerlink" title="3、在容器中保存指针"></a>3、在容器中保存指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; p= make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    vec.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(p));    <span class="comment">// 使用移动语义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、管理动态数组"><a href="#4、管理动态数组" class="headerlink" title="4、管理动态数组"></a>4、管理动态数组</h4><p>标准库提供了一个可以管理动态数组的unique_ptr版本。</p>
<p>可以使用make_unique来创建一个到数组的 unique_ptr，但不能使用 make_unique 来初始化数组元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// unique_ptr&lt;int[]&gt; p(new int[5] &#123;1, 2, 3, 4, 5&#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a unique_ptr to an array of 5 integers.</span></span><br><span class="line">    <span class="keyword">auto</span> p = make_unique&lt;<span class="keyword">int</span>[]&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the array.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        wcout &lt;&lt; p[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">// 重载了operator[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、作为auto-ptr的替代品"><a href="#5、作为auto-ptr的替代品" class="headerlink" title="5、作为auto_ptr的替代品"></a>5、作为auto_ptr的替代品</h4>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>语音识别</title>
    <url>/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>整个语音识别系统主要构成有四个部分：语音信号处理和特征的提取模块；语音识别的声学模型；语音识别的语言模型；语音识别的解码和搜索部分。系统流程图如下图所示：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/1.png" alt></p>
<a id="more"></a>
<p>整个语音识别的过程可以用贝叶斯理论来描述，假设输入的音频序列为$O={o_{1}, o_{2}, \cdots, o_{n}}$，输出为文本序列为$W={w_{1}, w_{2}, \cdots, w_{n}}$。目的是构建一个模型，使得$\prod_{n} P\left(W_{n} | O_{n}\right)$最大，也就是训练集中n个样本的后验概率最大。单独拿出一个样本的后验概率使用贝叶斯公式可以得到：</p>
<p>$$P(W | O)=\frac{P(O | W) * P(W)}{P(O)}$$</p>
<p>进一步可得:</p>
<p>$$W^{*}=\operatorname{argmax}_{W} P(O | W) * P(W)$$</p>
<p>这里$P(W)$是输出词序列的概率，用语言模型来刻画，$P(O | W)$为似然概率，使用声学模型来表达。</p>
<h3 id="数据集构建"><a href="#数据集构建" class="headerlink" title="数据集构建"></a>数据集构建</h3><p>语音数据构建主要分为两种，一是公开数据集—&gt;日常对话，二是特定数据集—&gt;控制命令。</p>
<p>所搜集的公开语音数据集是<a href="http://www.openslr.org/18/" target="_blank" rel="noopener external nofollow noreferrer">THCHS30</a>、<a href="http://cn-mirror.openslr.org/resources/38/ST-CMDS-20170001_1-OS.tar.gz" target="_blank" rel="noopener external nofollow noreferrer">ST-CMDS</a>、<a href="http://cn-mirror.openslr.org/resources/33/data_aishell.tgz" target="_blank" rel="noopener external nofollow noreferrer">AIShell</a>等数据集，这几个数据集是中文语音数据集，基本数据格式如下图所示:</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/2.png" alt></p>
<p>基本信息如下：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/3.png" alt></p>
<p>针对实际的工业控制命令，我们进行专门的语音采集和录制。环境是和实际的泵站控制室一致，安静、近场。这里使用单粒麦克风进行录制，录制的格式与上边格式一致。</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/4.png" alt></p>
<h3 id="语音信号预处理"><a href="#语音信号预处理" class="headerlink" title="语音信号预处理"></a>语音信号预处理</h3><p>语音信号预处理是为了将原始语音信号转换成CNN网络输入的语谱图。CNN的输入层是200维的特征值序列。输出拼音的表示大小是1422，即1421个拼音+1个空白块。预测结果是返回语音识别后的拼音符号列表。</p>
<p>语音信号的预处理过程用到的技术是：预加重（pre-emphasis）、<br>分帧（enframing）、加窗（windowing)</p>
<h4 id="预加重"><a href="#预加重" class="headerlink" title="预加重"></a>预加重</h4><p>预加重可以使得语音信号的频谱信号分布更加均衡。预加重一般是用<br>60db/octave数字滤波器频率特性完成的。过滤器公式给出：</p>
<p>$$H(z)=1-u z^{-1}$$</p>
<p>其中$u$是预加重系数。</p>
<h4 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a>分帧</h4><p>使用预先设计好的窗函数处理被分帧分成的多个小片段。通过这种方法在一定程度上解决语音信号帧信号之间的不连续性问题。每一个小段作为语音信的单位，称为帧（frame）。以帧为单位可以分析语音信号的短时特性，从而进一步进行频谱等处理。分帧一般相邻帧之间有交叉重叠，交叉部分叫做帧移，帧移一般定为帧长度的一半。</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/5.png" alt></p>
<h4 id="加窗"><a href="#加窗" class="headerlink" title="加窗"></a>加窗</h4><p>对语音信号增加一个窗函数（Window Function），在语音信号的给定区间内限定为一个实数，其它部分为0。使用的是汉明窗（Hamming Window）汉明窗的时间域表达给出:</p>
<p>$$w(n)=0.54-0.46 \cos \left(\frac{2 \pi n}{N-1}\right)$$</p>
<p>其中$𝑛$是时间，$w(n)$是窗函数。</p>
<h4 id="语谱图特征提取"><a href="#语谱图特征提取" class="headerlink" title="语谱图特征提取"></a>语谱图特征提取</h4><p>语谱图（Spectrogram）是语音处理的一个重要特征，是一种描述语音信号的各个频率成分随着时间变换的热力图。</p>
<p>语谱图包含着语音信号的重要信息，用一个二维矩阵表示。其中一个轴表示时间，另外一个轴表示频率。不同的点或者颜色代表对应语音信号能量的大小。</p>
<p>语谱图的提取过程一般包括：采样、傅立叶变换、连续拼接。如下图所示：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/6.jpg" alt></p>
<p>原始语音信号是符合数据格式的后缀是.wav 的原始语音数据。这里定义一个函数，读取该原始语音数据，返回声音信号的时域谱矩阵和帧速率。具体函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">一些通用函数，如wav文件读取、信号出来和测试代码</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> python_speech_features <span class="keyword">import</span> mfcc</span><br><span class="line"><span class="keyword">from</span> python_speech_features <span class="keyword">import</span> delta</span><br><span class="line"><span class="keyword">from</span> python_speech_features <span class="keyword">import</span> logfbank</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_wav_data</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	读取一个wav文件，返回声音信号的时域谱矩阵和播放时间</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	wav = wave.open(filename,<span class="string">"rb"</span>) <span class="comment"># 打开一个wav格式的声音文件流</span></span><br><span class="line">	num_frame = wav.getnframes() <span class="comment"># 获取帧数</span></span><br><span class="line">	num_channel=wav.getnchannels() <span class="comment"># 获取声道数</span></span><br><span class="line">	framerate=wav.getframerate() <span class="comment"># 获取帧速率</span></span><br><span class="line">	num_sample_width=wav.getsampwidth() <span class="comment"># 获取实例的比特宽度，即每一帧的字节数</span></span><br><span class="line">	str_data = wav.readframes(num_frame) <span class="comment"># 读取全部的帧</span></span><br><span class="line">	wav.close() <span class="comment"># 关闭流</span></span><br><span class="line">	wave_data = np.fromstring(str_data, dtype = np.short) <span class="comment"># 将声音文件数据转换为数组矩阵形式</span></span><br><span class="line">	wave_data.shape = <span class="number">-1</span>, num_channel <span class="comment"># 按照声道数将数组整形，单声道时候是一列数组，双声道时候是两列的矩阵</span></span><br><span class="line">	wave_data = wave_data.T <span class="comment"># 将矩阵转置</span></span><br><span class="line">	<span class="keyword">return</span> wave_data, framerate  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetMfccFeature</span><span class="params">(wavsignal, fs)</span>:</span></span><br><span class="line">	<span class="comment"># 获取输入特征</span></span><br><span class="line">	feat_mfcc=mfcc(wavsignal[<span class="number">0</span>],fs)</span><br><span class="line">	feat_mfcc_d=delta(feat_mfcc,<span class="number">2</span>)</span><br><span class="line">	feat_mfcc_dd=delta(feat_mfcc_d,<span class="number">2</span>)</span><br><span class="line">	<span class="comment"># 返回值分别是mfcc特征向量的矩阵及其一阶差分和二阶差分矩阵</span></span><br><span class="line">	wav_feature = np.column_stack((feat_mfcc, feat_mfcc_d, feat_mfcc_dd))</span><br><span class="line">	<span class="keyword">return</span> wav_feature</span><br><span class="line"></span><br><span class="line">x=np.linspace(<span class="number">0</span>, <span class="number">400</span> - <span class="number">1</span>, <span class="number">400</span>, dtype = np.int64)</span><br><span class="line">w = <span class="number">0.54</span> - <span class="number">0.46</span> * np.cos(<span class="number">2</span> * np.pi * (x) / (<span class="number">400</span> - <span class="number">1</span>) ) <span class="comment"># 汉明窗</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFrequencyFeature3</span><span class="params">(wavsignal, fs)</span>:</span></span><br><span class="line">	<span class="comment"># wav波形 加时间窗以及时移10ms</span></span><br><span class="line">	time_window = <span class="number">25</span> <span class="comment"># 单位ms</span></span><br><span class="line">	window_length = fs / <span class="number">1000</span> * time_window <span class="comment"># 计算窗长度的公式，目前全部为400固定值</span></span><br><span class="line">	</span><br><span class="line">	wav_arr = np.array(wavsignal)</span><br><span class="line">	<span class="comment">#wav_length = len(wavsignal[0])</span></span><br><span class="line">	wav_length = wav_arr.shape[<span class="number">1</span>]</span><br><span class="line">	</span><br><span class="line">	range0_end = int(len(wavsignal[<span class="number">0</span>])/fs*<span class="number">1000</span> - time_window) // <span class="number">10</span> <span class="comment"># 计算循环终止的位置，也就是最终生成的窗数</span></span><br><span class="line">	data_input = np.zeros((range0_end, <span class="number">200</span>), dtype = np.float) <span class="comment"># 用于存放最终的频率特征数据</span></span><br><span class="line">	data_line = np.zeros((<span class="number">1</span>, <span class="number">400</span>), dtype = np.float)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, range0_end):</span><br><span class="line">		p_start = i * <span class="number">160</span></span><br><span class="line">		p_end = p_start + <span class="number">400</span></span><br><span class="line">		</span><br><span class="line">		data_line = wav_arr[<span class="number">0</span>, p_start:p_end]</span><br><span class="line">		</span><br><span class="line">		data_line = data_line * w <span class="comment"># 加窗</span></span><br><span class="line">		</span><br><span class="line">		data_line = np.abs(fft(data_line)) / wav_length</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		data_input[i]=data_line[<span class="number">0</span>:<span class="number">200</span>] <span class="comment"># 设置为400除以2的值（即200）是取一半数据，因为是对称的</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">#print(data_input.shape)</span></span><br><span class="line">	data_input = np.log(data_input + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> data_input</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wav_scale</span><span class="params">(energy)</span>:</span></span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	语音信号能量归一化</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	means = energy.mean() <span class="comment"># 均值</span></span><br><span class="line">	var=energy.var() <span class="comment"># 方差</span></span><br><span class="line">	e=(energy-means)/math.sqrt(var) <span class="comment"># 归一化能量</span></span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wav_show</span><span class="params">(wave_data, fs)</span>:</span> <span class="comment"># 显示出来声音波形</span></span><br><span class="line">	time = np.arange(<span class="number">0</span>, len(wave_data)) * (<span class="number">1.0</span>/fs)  <span class="comment"># 计算声音的播放时间，单位为秒</span></span><br><span class="line">	<span class="comment"># 画声音波形</span></span><br><span class="line">	<span class="comment">#plt.subplot(211)  </span></span><br><span class="line">	plt.plot(time, wave_data)  </span><br><span class="line">	<span class="comment">#plt.subplot(212)  </span></span><br><span class="line">	<span class="comment">#plt.plot(time, wave_data[1], c = "g")  </span></span><br><span class="line">	plt.show()  </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_wav_list</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	读取一个wav文件列表，返回一个存储该列表的字典类型值</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	txt_obj=open(filename,<span class="string">'r'</span>) <span class="comment"># 打开文件并读入</span></span><br><span class="line">	txt_text=txt_obj.read()</span><br><span class="line">	txt_lines=txt_text.split(<span class="string">'\n'</span>) <span class="comment"># 文本分割</span></span><br><span class="line">	dic_filelist=&#123;&#125; <span class="comment"># 初始化字典</span></span><br><span class="line">	list_wavmark=[] <span class="comment"># 初始化wav列表</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> txt_lines:</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="string">''</span>):</span><br><span class="line">			txt_l=i.split(<span class="string">' '</span>)</span><br><span class="line">			dic_filelist[txt_l[<span class="number">0</span>]] = txt_l[<span class="number">1</span>]</span><br><span class="line">			list_wavmark.append(txt_l[<span class="number">0</span>])</span><br><span class="line">	txt_obj.close()</span><br><span class="line">	<span class="keyword">return</span> dic_filelist,list_wavmark</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_wav_symbol</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	读取指定数据集中，所有wav文件对应的语音符号</span></span><br><span class="line"><span class="string">	返回一个存储符号集的字典类型值</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	txt_obj=open(filename,<span class="string">'r'</span>) <span class="comment"># 打开文件并读入</span></span><br><span class="line">	txt_text=txt_obj.read()</span><br><span class="line">	txt_lines=txt_text.split(<span class="string">'\n'</span>) <span class="comment"># 文本分割</span></span><br><span class="line">	dic_symbol_list=&#123;&#125; <span class="comment"># 初始化字典</span></span><br><span class="line">	list_symbolmark=[] <span class="comment"># 初始化symbol列表</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> txt_lines:</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="string">''</span>):</span><br><span class="line">			txt_l=i.split(<span class="string">' '</span>)</span><br><span class="line">			dic_symbol_list[txt_l[<span class="number">0</span>]]=txt_l[<span class="number">1</span>:]</span><br><span class="line">			list_symbolmark.append(txt_l[<span class="number">0</span>])</span><br><span class="line">	txt_obj.close()</span><br><span class="line">	<span class="keyword">return</span> dic_symbol_list,list_symbolmark</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span>(__name__==<span class="string">'__main__'</span>):</span><br><span class="line">	</span><br><span class="line">	wave_data, fs = read_wav_data(<span class="string">"A2_0.wav"</span>)  </span><br><span class="line">	</span><br><span class="line">	wav_show(wave_data[<span class="number">0</span>],fs)</span><br><span class="line">	t0=time.time()</span><br><span class="line">	freimg = GetFrequencyFeature(wave_data,fs)</span><br><span class="line">	t1=time.time()</span><br><span class="line">	print(<span class="string">'time cost:'</span>,t1-t0)</span><br><span class="line">	</span><br><span class="line">	freimg = freimg.T</span><br><span class="line">	plt.subplot(<span class="number">111</span>)</span><br><span class="line">	</span><br><span class="line">	plt.imshow(freimg)</span><br><span class="line">	plt.colorbar(cax=<span class="literal">None</span>,ax=<span class="literal">None</span>,shrink=<span class="number">0.5</span>)  </span><br><span class="line">	 </span><br><span class="line">	plt.show()</span><br></pre></td></tr></table></figure>

<p>原始语音信号经过处理后得到帧数、声道数、帧速率。然后读取全部帧数，再经过变换后转换成数组矩阵格式，该数组按照声道数进行数组整形，整形后数组转置得到时域谱矩阵，得到帧速率和时域谱矩阵。在得到帧速率和时域谱矩阵后，经过加窗、采样后、傅里叶变换，以及最后的连续拼接。流程图如下：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/7.png" alt></p>
<p>下图是采用上述代码对中文语音数据提取的波形图和语谱图的结果。波形图的横轴是时间，纵轴可以理解为位移或者压强。语谱图的横轴是拼接的时间，纵轴是频率。</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/8.png" alt></p>
<h3 id="声学模型设计训练"><a href="#声学模型设计训练" class="headerlink" title="声学模型设计训练"></a>声学模型设计训练</h3><p>声学模型输⼊入是语谱图，输出是拼音。如下图所示：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/9.png" alt></p>
<p>声学模型设计主要基于DFCNN网络进行训练，主要设计的结构和相应的参数设置如下：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/10.png" alt></p>
<p>参数设置：</p>
<p>Adam 的参数:<br>(lr = 0.01, beta_1 = 0.9,beta_2 = 0.999, decay = 0.0, epsilon = 10e-8)</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/11.png" alt></p>
<p>CTC是一种针对序列列深度模型的损失函数。相⽐比传统交叉熵损失函数能⾃自动对⻬齐序列列标签，端到端训练模型。具体参考<a href="https://blog.ailemon.me/2019/07/18/sequence-modeling-with-ctc/" target="_blank" rel="noopener external nofollow noreferrer">这里</a></p>
<p>使用Keras搭建序贯(Sequential)模型，部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">声学模型</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> platform <span class="keyword">as</span> plat</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> general_function.file_wav <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> general_function.file_dict <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> general_function.gen_func <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> general_function.muti_gpu <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> multi_gpu_model,plot_model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> keras <span class="keyword">as</span> kr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential, Model</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Input, Reshape, BatchNormalization <span class="comment"># , Flatten</span></span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Lambda, TimeDistributed, Activation,Conv2D, MaxPooling2D <span class="comment">#, Merge</span></span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD, Adadelta, Adam, RMSprop</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ReadData <span class="keyword">import</span> DataSpeech</span><br><span class="line"></span><br><span class="line">abspath = <span class="string">''</span></span><br><span class="line">ModelName=<span class="string">'_dfcnn'</span></span><br><span class="line"><span class="comment">#NUM_GPU = 2</span></span><br><span class="line">base_count=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelSpeech</span><span class="params">()</span>:</span> <span class="comment"># 语音模型类</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, datapath)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		初始化</span></span><br><span class="line"><span class="string">		默认输出的拼音的表示大小是1434，即1433个拼音+1个空白块</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		MS_OUTPUT_SIZE = <span class="number">1434</span></span><br><span class="line">		self.MS_OUTPUT_SIZE = MS_OUTPUT_SIZE <span class="comment"># 神经网络最终输出的每一个字符向量维度的大小</span></span><br><span class="line">		<span class="comment">#self.BATCH_SIZE = BATCH_SIZE # 一次训练的batch</span></span><br><span class="line">		self.label_max_string_length = <span class="number">64</span></span><br><span class="line">		self.AUDIO_LENGTH = <span class="number">1600</span>  <span class="comment">## 16s</span></span><br><span class="line">		self.AUDIO_FEATURE_LENGTH = <span class="number">200</span></span><br><span class="line">		self._model, self.base_model = self.CreateModel() </span><br><span class="line">		</span><br><span class="line">		self.datapath = datapath</span><br><span class="line">		self.slash = <span class="string">''</span></span><br><span class="line">		system_type = plat.system() <span class="comment"># 由于不同的系统的文件路径表示不一样，需要进行判断</span></span><br><span class="line">		<span class="keyword">if</span>(system_type == <span class="string">'Windows'</span>):</span><br><span class="line">			self.slash=<span class="string">'\\'</span> <span class="comment"># 反斜杠</span></span><br><span class="line">		<span class="keyword">elif</span>(system_type == <span class="string">'Linux'</span>):</span><br><span class="line">			self.slash=<span class="string">'/'</span> <span class="comment"># 正斜杠</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			print(<span class="string">'*[Message] Unknown System\n'</span>)</span><br><span class="line">			self.slash=<span class="string">'/'</span> <span class="comment"># 正斜杠</span></span><br><span class="line">		<span class="keyword">if</span>(self.slash != self.datapath[<span class="number">-1</span>]): <span class="comment"># 在目录路径末尾增加斜杠</span></span><br><span class="line">			self.datapath = self.datapath + self.slash</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">CreateModel</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		定义DFCNN模型，使用函数式模型  </span></span><br><span class="line"><span class="string">		输入层：200维的特征值序列，一条语音数据的最大长度设为1600（大约16s）</span></span><br><span class="line"><span class="string">		隐藏层：卷积池化层，卷积核大小为3x3，池化窗口大小为2</span></span><br><span class="line"><span class="string">		隐藏层：全连接层</span></span><br><span class="line"><span class="string">		输出层：全连接层，神经元数量为self.MS_OUTPUT_SIZE，使用softmax作为激活函数，</span></span><br><span class="line"><span class="string">		CTC层：使用CTC的loss作为损失函数，实现连接性时序多输出</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		</span><br><span class="line">		input_data = Input(name=<span class="string">'the_input'</span>, shape=(self.AUDIO_LENGTH, self.AUDIO_FEATURE_LENGTH, <span class="number">1</span>))</span><br><span class="line">		</span><br><span class="line">		layer_h1 = Conv2D(<span class="number">32</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">False</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(input_data) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h1 = BatchNormalization(mode=<span class="number">0</span>,axis=<span class="number">-1</span>)(layer_h1)</span><br><span class="line">		layer_h2 = Conv2D(<span class="number">32</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h1) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h2 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h2)</span><br><span class="line">		layer_h3 = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h2) <span class="comment"># 池化层 800*100</span></span><br><span class="line">		layer_h4 = Conv2D(<span class="number">64</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h3) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h4 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h4)</span><br><span class="line">		layer_h5 = Conv2D(<span class="number">64</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h4) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h5 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h5)</span><br><span class="line">		layer_h6 = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h5) <span class="comment"># 池化层 400*50</span></span><br><span class="line">		layer_h7 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h6) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h7 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h7)</span><br><span class="line">		layer_h8 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h7) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h8 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h8)</span><br><span class="line">		layer_h9 = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h8) <span class="comment"># 池化层 200*25</span></span><br><span class="line">		layer_h10 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h9) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h10 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h10)</span><br><span class="line">		layer_h11 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h10) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h11 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h11)</span><br><span class="line">		layer_h12 = MaxPooling2D(pool_size=<span class="number">1</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h11) <span class="comment"># 池化层 200*25</span></span><br><span class="line">		</span><br><span class="line">		layer_h13 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h12) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h13 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h13)</span><br><span class="line">		layer_h14 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h13) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h14 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h14)</span><br><span class="line">		layer_h15 = MaxPooling2D(pool_size=<span class="number">1</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h14) <span class="comment"># 池化层 None*200*25*128</span></span><br><span class="line">		</span><br><span class="line">		layer_h16 = Reshape((<span class="number">200</span>, <span class="number">3200</span>))(layer_h15)</span><br><span class="line">		layer_h17 = Dense(<span class="number">128</span>, activation=<span class="string">"relu"</span>, use_bias=<span class="literal">True</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h16) <span class="comment"># 全连接层</span></span><br><span class="line">		layer_h17 = BatchNormalization(axis=<span class="number">1</span>)(layer_h17)</span><br><span class="line">		layer_h18 = Dense(self.MS_OUTPUT_SIZE, use_bias=<span class="literal">True</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h17) <span class="comment"># 全连接层</span></span><br><span class="line">		layer_h18 = BatchNormalization(axis=<span class="number">1</span>)(layer_h18)</span><br><span class="line">		y_pred = Activation(<span class="string">'softmax'</span>, name=<span class="string">'Activation0'</span>)(layer_h18)</span><br><span class="line">		model_data = Model(inputs = input_data, outputs = y_pred)</span><br><span class="line">		model_data.summary()</span><br><span class="line">		</span><br><span class="line">		labels = Input(name=<span class="string">'the_labels'</span>, shape=[self.label_max_string_length], dtype=<span class="string">'float32'</span>)</span><br><span class="line">		input_length = Input(name=<span class="string">'input_length'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)</span><br><span class="line">		label_length = Input(name=<span class="string">'label_length'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)</span><br><span class="line">		<span class="comment"># Keras doesn't currently support loss funcs with extra parameters</span></span><br><span class="line">		<span class="comment"># so CTC loss is implemented in a lambda layer</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment"># CTC</span></span><br><span class="line">		loss_out = Lambda(self.ctc_lambda_func, output_shape=(<span class="number">1</span>,), name=<span class="string">'ctc'</span>)([y_pred, labels, input_length, label_length])</span><br><span class="line">		</span><br><span class="line">		model = Model(inputs=[input_data, labels, input_length, label_length], outputs=loss_out)</span><br><span class="line">		</span><br><span class="line">		opt = Adam(lr = <span class="number">0.001</span>, beta_1 = <span class="number">0.9</span>, beta_2 = <span class="number">0.999</span>, decay = <span class="number">0.0</span>, epsilon = <span class="number">10e-8</span>)</span><br><span class="line">		<span class="comment">#model.compile(loss=&#123;'ctc': lambda y_true, y_pred: y_pred&#125;, optimizer=sgd)</span></span><br><span class="line">		model.compile(loss=&#123;<span class="string">'ctc'</span>: <span class="keyword">lambda</span> y_true, y_pred: y_pred&#125;, optimizer = opt)</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># captures output of softmax so we can decode the output during visualization</span></span><br><span class="line">		test_func = K.function([input_data], [y_pred])</span><br><span class="line">		</span><br><span class="line">		print(<span class="string">'[*提示] 创建模型成功，模型编译成功'</span>)</span><br><span class="line">		<span class="keyword">return</span> model, model_data</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">ctc_lambda_func</span><span class="params">(self, args)</span>:</span></span><br><span class="line">		y_pred, labels, input_length, label_length = args</span><br><span class="line">		</span><br><span class="line">		y_pred = y_pred[:, :, :]</span><br><span class="line">		<span class="comment">#y_pred = y_pred[:, 2:, :]</span></span><br><span class="line">		<span class="keyword">return</span> K.ctc_batch_cost(labels, y_pred, input_length, label_length)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">TrainModel</span><span class="params">(self, datapath, epoch = <span class="number">2</span>, save_step = <span class="number">1000</span>, batch_size = <span class="number">32</span>, filename = abspath + <span class="string">'model_speech/m'</span> + ModelName + <span class="string">'/speech_model'</span>+ModelName)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		训练模型</span></span><br><span class="line"><span class="string">		参数：</span></span><br><span class="line"><span class="string">			datapath: 数据保存的路径</span></span><br><span class="line"><span class="string">			epoch: 迭代轮数</span></span><br><span class="line"><span class="string">			save_step: 每多少步保存一次模型</span></span><br><span class="line"><span class="string">			filename: 默认保存文件名，不含文件后缀名</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		data=DataSpeech(datapath, <span class="string">'train'</span>)</span><br><span class="line">		</span><br><span class="line">		num_data = data.GetDataNum() <span class="comment"># 获取数据的数量</span></span><br><span class="line">		</span><br><span class="line">		yielddatas = data.data_genetator(batch_size, self.AUDIO_LENGTH)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> epoch <span class="keyword">in</span> range(epoch): <span class="comment"># 迭代轮数</span></span><br><span class="line">			print(<span class="string">'[running] train epoch %d .'</span> % epoch)</span><br><span class="line">			n_step = <span class="number">0</span> <span class="comment"># 迭代数据数</span></span><br><span class="line">			<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">				<span class="keyword">try</span>:</span><br><span class="line">					print(<span class="string">'[message] epoch %d . Have train datas %d+'</span>%(epoch, n_step*save_step))</span><br><span class="line">					<span class="comment"># data_genetator是一个生成器函数</span></span><br><span class="line">					</span><br><span class="line">					<span class="comment">#self._model.fit_generator(yielddatas, save_step, nb_worker=2)</span></span><br><span class="line">					self._model.fit_generator(yielddatas, save_step)</span><br><span class="line">					n_step += <span class="number">1</span></span><br><span class="line">				<span class="keyword">except</span> StopIteration:</span><br><span class="line">					print(<span class="string">'[error] generator error. please check data format.'</span>)</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				</span><br><span class="line">				self.SaveModel(comment=<span class="string">'_e_'</span>+str(epoch)+<span class="string">'_step_'</span>+str(n_step * save_step))</span><br><span class="line">				self.TestModel(self.datapath, str_dataset=<span class="string">'train'</span>, data_count = <span class="number">4</span>)</span><br><span class="line">				self.TestModel(self.datapath, str_dataset=<span class="string">'dev'</span>, data_count = <span class="number">4</span>)</span><br><span class="line">				</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">LoadModel</span><span class="params">(self,filename = abspath + <span class="string">'model_speech/m'</span>+ModelName+<span class="string">'/speech_model'</span>+ModelName+<span class="string">'.model'</span>)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		加载模型参数</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		self._model.load_weights(filename)</span><br><span class="line">		self.base_model.load_weights(filename + <span class="string">'.base'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">SaveModel</span><span class="params">(self,filename = abspath + <span class="string">'model_speech/m'</span>+ModelName+<span class="string">'/speech_model'</span>+ModelName,comment=<span class="string">''</span>)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		保存模型参数</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		self._model.save_weights(filename + comment + <span class="string">'.model'</span>)</span><br><span class="line">		self.base_model.save_weights(filename + comment + <span class="string">'.model.base'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">TestModel</span><span class="params">(self, datapath=<span class="string">''</span>, str_dataset=<span class="string">'dev'</span>, data_count = <span class="number">32</span>,comment = <span class="string">''</span>, out_report = False, show_ratio = True, io_step_print = <span class="number">10</span>, io_step_file = <span class="number">10</span>)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		测试检验模型效果</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		io_step_print</span></span><br><span class="line"><span class="string">			为了减少测试时标准输出的io开销，可以通过调整这个参数来实现</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		io_step_file</span></span><br><span class="line"><span class="string">			为了减少测试时文件读写的io开销，可以通过调整这个参数来实现</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		data=DataSpeech(self.datapath, str_dataset)</span><br><span class="line">		<span class="comment">#data.LoadDataList(str_dataset) </span></span><br><span class="line">		num_data = data.GetDataNum() <span class="comment"># 获取数据的数量</span></span><br><span class="line">		<span class="keyword">if</span>(data_count &lt;= <span class="number">0</span> <span class="keyword">or</span> data_count &gt; num_data): <span class="comment"># 当data_count为小于等于0或者大于测试数据量的值时，则使用全部数据来测试</span></span><br><span class="line">			data_count = num_data</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			ran_num = random.randint(<span class="number">0</span>,num_data - <span class="number">1</span>) <span class="comment"># 获取一个随机数</span></span><br><span class="line">			</span><br><span class="line">			words_num = <span class="number">0</span></span><br><span class="line">			word_error_num = <span class="number">0</span></span><br><span class="line">			</span><br><span class="line">			nowtime = time.strftime(<span class="string">'%Y%m%d_%H%M%S'</span>,time.localtime(time.time()))</span><br><span class="line">			<span class="keyword">if</span>(out_report == <span class="literal">True</span>):</span><br><span class="line">				txt_obj = open(abspath+<span class="string">'Test_Report_'</span> + str_dataset + <span class="string">'_'</span> + nowtime + <span class="string">'.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="comment"># 打开文件并读入</span></span><br><span class="line">			</span><br><span class="line">			txt = <span class="string">'测试报告\n模型编号 '</span> + ModelName + <span class="string">'\n\n'</span></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> range(data_count):</span><br><span class="line">				data_input, data_labels = data.GetData((ran_num + i) % num_data)  <span class="comment"># 从随机数开始连续向后取一定数量数据</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment"># 数据格式出错处理 开始</span></span><br><span class="line">				<span class="comment"># 当输入的wav文件长度过长时自动跳过该文件，转而使用下一个wav文件来运行</span></span><br><span class="line">				num_bias = <span class="number">0</span></span><br><span class="line">				<span class="keyword">while</span>(data_input.shape[<span class="number">0</span>] &gt; self.AUDIO_LENGTH):</span><br><span class="line">					print(<span class="string">'*[Error]'</span>,<span class="string">'wave data lenghth of num'</span>,(ran_num + i) % num_data, <span class="string">'is too long.'</span>,<span class="string">'\n A Exception raise when test Speech Model.'</span>)</span><br><span class="line">					num_bias += <span class="number">1</span></span><br><span class="line">					data_input, data_labels = data.GetData((ran_num + i + num_bias) % num_data)  <span class="comment"># 从随机数开始连续向后取一定数量数据</span></span><br><span class="line">				<span class="comment"># 数据格式出错处理 结束</span></span><br><span class="line">				</span><br><span class="line">				pre = self.Predict(data_input, data_input.shape[<span class="number">0</span>] // <span class="number">8</span>)</span><br><span class="line">				</span><br><span class="line">				words_n = data_labels.shape[<span class="number">0</span>] <span class="comment"># 获取每个句子的字数</span></span><br><span class="line">				words_num += words_n <span class="comment"># 把句子的总字数加上</span></span><br><span class="line">				edit_distance = GetEditDistance(data_labels, pre) <span class="comment"># 获取编辑距离</span></span><br><span class="line">				<span class="keyword">if</span>(edit_distance &lt;= words_n): <span class="comment"># 当编辑距离小于等于句子字数时</span></span><br><span class="line">					word_error_num += edit_distance <span class="comment"># 使用编辑距离作为错误字数</span></span><br><span class="line">				<span class="keyword">else</span>: <span class="comment"># 否则肯定是增加了一堆乱七八糟的奇奇怪怪的字</span></span><br><span class="line">					word_error_num += words_n <span class="comment"># 就直接加句子本来的总字数就好了</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>((i % io_step_print == <span class="number">0</span> <span class="keyword">or</span> i == data_count - <span class="number">1</span>) <span class="keyword">and</span> show_ratio == <span class="literal">True</span>):</span><br><span class="line">					<span class="comment">#print('测试进度：',i,'/',data_count)</span></span><br><span class="line">					print(<span class="string">'Test Count: '</span>,i,<span class="string">'/'</span>,data_count)</span><br><span class="line">				</span><br><span class="line">				txt = <span class="string">''</span></span><br><span class="line">				<span class="keyword">if</span>(out_report == <span class="literal">True</span>):</span><br><span class="line">					<span class="comment"># if(i % io_step_file == 0 or i == data_count - 1):</span></span><br><span class="line">					<span class="comment"># 	txt_obj.write(txt)</span></span><br><span class="line">					<span class="comment"># 	txt = ''</span></span><br><span class="line">					txt += str(i) + <span class="string">'\n'</span></span><br><span class="line">					txt += <span class="string">'True:\t'</span> + str(data_labels) + <span class="string">'\n'</span></span><br><span class="line">					txt += <span class="string">'Pred:\t'</span> + str(pre) + <span class="string">'\n'</span></span><br><span class="line">					txt += <span class="string">'\n'</span></span><br><span class="line">					txt_obj.write(txt)</span><br><span class="line">				</span><br><span class="line">			print(<span class="string">'*[Test Result] Speech Recognition '</span> + str_dataset + <span class="string">' set word error ratio: '</span>, word_error_num / words_num * <span class="number">100</span>, <span class="string">'%'</span>)</span><br><span class="line">			<span class="keyword">if</span>(out_report == <span class="literal">True</span>):</span><br><span class="line">				txt += <span class="string">'*[测试结果] 语音识别 '</span> + str_dataset + <span class="string">' 集语音单字错误率： '</span> + str(word_error_num / words_num * <span class="number">100</span>) + <span class="string">' %'</span></span><br><span class="line">				txt_obj.write(txt)</span><br><span class="line">				txt = <span class="string">''</span></span><br><span class="line">				txt_obj.close()</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">except</span> StopIteration:</span><br><span class="line">			print(<span class="string">'[Error] Model Test Error. please check data format.'</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">Predict</span><span class="params">(self, data_input, input_len)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		预测结果</span></span><br><span class="line"><span class="string">		返回语音识别后的拼音符号列表</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		</span><br><span class="line">		batch_size = <span class="number">1</span> </span><br><span class="line">		in_len = np.zeros((batch_size),dtype = np.int32)</span><br><span class="line">		</span><br><span class="line">		in_len[<span class="number">0</span>] = input_len</span><br><span class="line">		</span><br><span class="line">		x_in = np.zeros((batch_size, <span class="number">1600</span>, self.AUDIO_FEATURE_LENGTH, <span class="number">1</span>), dtype=np.float)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(batch_size):</span><br><span class="line">			x_in[i,<span class="number">0</span>:len(data_input)] = data_input</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		base_pred = self.base_model.predict(x = x_in)</span><br><span class="line">		</span><br><span class="line">		base_pred =base_pred[:, :, :]</span><br><span class="line">		</span><br><span class="line">		r = K.ctc_decode(base_pred, in_len, greedy = <span class="literal">True</span>, beam_width=<span class="number">100</span>, top_paths=<span class="number">1</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">#print('r', r)</span></span><br><span class="line">		</span><br><span class="line">		r1 = K.get_value(r[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">		<span class="comment">#print('r1', r1)</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">#r2 = K.get_value(r[1])</span></span><br><span class="line">		<span class="comment">#print(r2)</span></span><br><span class="line">		</span><br><span class="line">		r1=r1[<span class="number">0</span>]</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> r1</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">RecognizeSpeech</span><span class="params">(self, wavsignal, fs)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		最终做语音识别用的函数，识别一个wav序列的语音</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">#data = self.data</span></span><br><span class="line">		<span class="comment">#data = DataSpeech('E:\\语音数据集')</span></span><br><span class="line">		<span class="comment">#data.LoadDataList('dev')</span></span><br><span class="line">		<span class="comment"># 获取输入特征</span></span><br><span class="line">		<span class="comment">#data_input = GetMfccFeature(wavsignal, fs)</span></span><br><span class="line">		<span class="comment">#t0=time.time()</span></span><br><span class="line">		data_input = GetFrequencyFeature(wavsignal, fs)</span><br><span class="line">		<span class="comment">#t1=time.time()</span></span><br><span class="line">		<span class="comment">#print('time cost:',t1-t0)</span></span><br><span class="line">		</span><br><span class="line">		input_length = len(data_input)</span><br><span class="line">		input_length = input_length // <span class="number">8</span></span><br><span class="line">		</span><br><span class="line">		data_input = np.array(data_input, dtype = np.float)</span><br><span class="line">		<span class="comment">#print(data_input,data_input.shape)</span></span><br><span class="line">		data_input = data_input.reshape(data_input.shape[<span class="number">0</span>],data_input.shape[<span class="number">1</span>],<span class="number">1</span>)</span><br><span class="line">		<span class="comment">#t2=time.time()</span></span><br><span class="line">		r1 = self.Predict(data_input, input_length)</span><br><span class="line">		<span class="comment">#t3=time.time()</span></span><br><span class="line">		<span class="comment">#print('time cost:',t3-t2)</span></span><br><span class="line">		list_symbol_dic = GetSymbolList(self.datapath) <span class="comment"># 获取拼音列表</span></span><br><span class="line">		</span><br><span class="line">		r_str=[]</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> r1:</span><br><span class="line">			r_str.append(list_symbol_dic[i])</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> r_str</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">RecognizeSpeech_FromFile</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		最终做语音识别用的函数，识别指定文件名的语音</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		</span><br><span class="line">		wavsignal,fs = read_wav_data(filename)</span><br><span class="line">		</span><br><span class="line">		r = self.RecognizeSpeech(wavsignal, fs)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> r</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		返回keras model</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		<span class="keyword">return</span> self._model</span><br></pre></td></tr></table></figure>

<h3 id="语言模型设计训练"><a href="#语言模型设计训练" class="headerlink" title="语言模型设计训练"></a>语言模型设计训练</h3><h3 id="实验分析和软件设计"><a href="#实验分析和软件设计" class="headerlink" title="实验分析和软件设计"></a>实验分析和软件设计</h3>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>TPOT——一个自动化的Python机器学习工具</title>
    <url>/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="TPOT—一个自动化的Python机器学习工具"><a href="#TPOT—一个自动化的Python机器学习工具" class="headerlink" title="TPOT—一个自动化的Python机器学习工具"></a>TPOT—一个自动化的Python机器学习工具</h2><p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/1.png" alt></p>
<p>TPOT全称是基于树的pipeline优化工具(Tree-based Pipeline Optimization Tool)，这是一个非常棒Python自动机器学习工具，使用遗传编程优化机器学习pipeline。</p>
<a id="more"></a>

<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/2.png" alt></p>
<p>TPOT可以自动化许多东西，包括生命特性选择、模型选择、特性构建等等。如果你是Python机器学习者，很幸运，TPOT是构建在Scikit-learn之上的，所以它生成的所有代码看起来应该很熟悉。</p>
<p>它的作用是通过智能地探索数千种可能的pipeline来自动化机器学习中最繁琐的部分，找到最适合你的数据的pipeline，然后为你提供最佳的 Python 代码。</p>
<p>它的工作原理如下：</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/3.png" alt></p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><p>安装TPOT，可参考以下文档：<br><a href="http://epistasislab.github.io/tpot/installing/" target="_blank" rel="noopener external nofollow noreferrer">http://epistasislab.github.io/tpot/installing/</a></p>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h2><h3 id="2-1-TPOT代码"><a href="#2-1-TPOT代码" class="headerlink" title="2.1 TPOT代码"></a>2.1 TPOT代码</h3><p>TPOT的接口，与scikit-learn很类似。</p>
<p>TPOT可以像任何常规的Python模块一样导入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br></pre></td></tr></table></figure>
<p>然后创建一个TPOT实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer = TPOTClassifier()</span><br></pre></td></tr></table></figure>
<p>当然，TPOTRegressor（）也可以。</p>
<p>一些带有定制TPOT参数的示例代码可能如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, cv=<span class="number">5</span>, random_state=<span class="number">42</span>, verbosity=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>现在，可以利用fit函数来寻找最优的管道：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>fit函数初始化了遗传算法，以找到基于平均k倍交叉验证的最高评分管道，然后对整个提供的样本进行训练，TPOT实例可以作为一个合适的模型使用。</p>
<p>然后，可以使用score函数来评估测试集中的最终管道：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(pipeline_optimizer.score(X_test, y_test))</span><br></pre></td></tr></table></figure>
<p>最后，可以把TPOT将相应的Python代码导出到文本文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer.export(<span class="string">'tpot_exported_pipeline.py'</span>)</span><br></pre></td></tr></table></figure>
<p>下面是一个完整的示例脚本，使用TPOT优化管道，对其进行评分，并将最好的管道导出到文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"> </span><br><span class="line">digits = load_digits()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"> </span><br><span class="line">pipeline_optimizer = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, cv=<span class="number">5</span>,random_state=<span class="number">42</span>, verbosity=<span class="number">2</span>)</span><br><span class="line">pipeline_optimizer.fit(X_train, y_train)</span><br><span class="line">print(pipeline_optimizer.score(X_test, y_test))</span><br><span class="line">pipeline_optimizer.export(<span class="string">'tpot_exported_pipeline.py'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-2-TPOT命令行"><a href="#2-2-TPOT命令行" class="headerlink" title="2.2 TPOT命令行"></a>2.2 TPOT命令行</h3><p>TPOT可以通过命令行导入使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tpot &#x2F;path_to&#x2F;data_file.csv</span><br></pre></td></tr></table></figure>
<p>命令行导入使用TPOT的示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tpot data&#x2F;mnist.csv -is , -target class -o tpot_exported_pipeline.py -g 5 -p 20 -cv 5 -s 42 -v 2</span><br></pre></td></tr></table></figure>
<h3 id="2-3-评估函数"><a href="#2-3-评估函数" class="headerlink" title="2.3 评估函数"></a>2.3 评估函数</h3><p>TPOT允许自定义评分函数，具体例子可以参考<a href="https://epistasislab.github.io/tpot/using/#scoring-functions" target="_blank" rel="noopener external nofollow noreferrer">Scoring Functions</a><br>##2.4 内置TPOT配置<br>TPOT提供了一些默认的操作符和参数配置，它可以很好地优化机器学习管道。下面是TPOT当前内置配置的<a href="https://epistasislab.github.io/tpot/using/#built-in-tpot-configurations" target="_blank" rel="noopener external nofollow noreferrer">列表</a>。它有4种：</p>
<ul>
<li>Default TPOT：默认的参数，在一些大数据集上可能需要较长时间。</li>
<li>TPOT light：与Default TPOT相比，使用了更简单、快速运行的操作符，因此TPOT light对于查找用于分类或回归问题的快速简单的管道非常有用。</li>
<li>TPOT MDR：专门用于全基因组关联研究（GWAS）</li>
<li>TPOT sparse：带有one-hot编码，且支持稀疏矩阵。<br>如果要使用这些配置只需将配置的字符串名称传递给config_dict 参数。示例代码如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">digits = load_digits()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">tpot = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, verbosity=<span class="number">2</span>,config_dict=<span class="string">'TPOT light'</span>)</span><br><span class="line">tpot.fit(X_train, y_train)</span><br><span class="line">print(tpot.score(X_test, y_test))</span><br><span class="line">tpot.export(<span class="string">'tpot_mnist_pipeline.py'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-5-定制TPOT的操作符和参数"><a href="#2-5-定制TPOT的操作符和参数" class="headerlink" title="2.5 定制TPOT的操作符和参数"></a>2.5 定制TPOT的操作符和参数</h3>除了TPOT所带来的默认配置之外，在某些情况下，限制TPOT所考虑的算法和参数是很有用的（用于减少寻优的时间等）。出于这个原因，TPOT允许用户为TPOT提供其操作符和参数的自定义配置。<br>自定义TPOT配置必须采用嵌套字典格式，举一个例子：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"> </span><br><span class="line">digits = load_digits()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"> </span><br><span class="line">tpot_config = &#123;</span><br><span class="line">    <span class="string">'sklearn.naive_bayes.GaussianNB'</span>: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    <span class="string">'sklearn.naive_bayes.BernoulliNB'</span>: &#123;</span><br><span class="line">        <span class="string">'alpha'</span>: [<span class="number">1e-3</span>, <span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1.</span>, <span class="number">10.</span>, <span class="number">100.</span>],</span><br><span class="line">        <span class="string">'fit_prior'</span>: [<span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    <span class="string">'sklearn.naive_bayes.MultinomialNB'</span>: &#123;</span><br><span class="line">        <span class="string">'alpha'</span>: [<span class="number">1e-3</span>, <span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1.</span>, <span class="number">10.</span>, <span class="number">100.</span>],</span><br><span class="line">        <span class="string">'fit_prior'</span>: [<span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">tpot = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, verbosity=<span class="number">2</span>,</span><br><span class="line">                      config_dict=tpot_config)</span><br><span class="line">tpot.fit(X_train, y_train)</span><br><span class="line">print(tpot.score(X_test, y_test))</span><br><span class="line">tpot.export(<span class="string">'tpot_mnist_pipeline.py'</span>)</span><br></pre></td></tr></table></figure>
这样，TPOT寻找最优的pipeline，就只会在tpot_config中寻找了，无疑大大减少了时间复杂度，不过准确性可能会下降。<h3 id="2-6-Note"><a href="#2-6-Note" class="headerlink" title="2.6 Note"></a>2.6 Note</h3>搜索整个管道空间是特别耗时的。认识到原因是必要的，在默认的TPOT参数下（100 generations with 100 population size），TPOT将在完成前评估1万个管道配置。考虑一个网格搜索1万个超参数组合用于机器学习算法以及网格搜索需要多长时间。用10倍的交叉验证来评估这1万个模型，这意味着大约有10万个模型在一个网格搜索的训练数据中被匹配和评估。这是一个耗时的过程，即使对于像决策树这样的简单模型也是如此。</li>
</ul>
<p>典型的TPOT运行将需要数小时到数天才能完成（除非是一个小数据集），但是可以中断运行，并看到目前为止最好的结果。TPOT还提供warm_start参数，可以从中断的地方重新启动之前运行的TPOT。</p>
<h2 id="3-TPOT-API"><a href="#3-TPOT-API" class="headerlink" title="3. TPOT API"></a>3. TPOT API</h2><p>以TPOTRegressor为例，分类问题一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tpot</span>.<span class="title">TPOTRegressor</span><span class="params">(generations=<span class="number">100</span>, population_size=<span class="number">100</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">offspring_size=None, mutation_rate=<span class="number">0.9</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">crossover_rate=<span class="number">0.1</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">scoring=<span class="string">'neg_mean_squared_error'</span>, cv=<span class="number">5</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">subsample=<span class="number">1.0</span>, n_jobs=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">max_time_mins=None, max_eval_time_mins=<span class="number">5</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">random_state=None, config_dict=None,</span></span></span><br><span class="line"><span class="class"><span class="params">warm_start=False,</span></span></span><br><span class="line"><span class="class"><span class="params">memory=None,</span></span></span><br><span class="line"><span class="class"><span class="params">periodic_checkpoint_folder=None,</span></span></span><br><span class="line"><span class="class"><span class="params">early_stop=None,</span></span></span><br><span class="line"><span class="class"><span class="params">verbosity=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">disable_update_check=False)</span></span></span><br></pre></td></tr></table></figure>
<p>在默认情况下，TPOTRegressor将搜索广泛的监督的回归模型，包括预处理，特征选择，学习器和它们的超参数。当然，TPOTRegressor可以完全自己定制。</p>
<p>参数，属性和方法的详情可以参考<a href="https://epistasislab.github.io/tpot/api/#regression" target="_blank" rel="noopener external nofollow noreferrer">如下</a></p>
<p>下面列出主要的参数和方法：</p>
<p>参数：</p>
<ul>
<li>generations: int, optional (default=100)，运行管道优化过程的迭代次数。一定是正数,默认是100。一般来说，值越大，性能越好。</li>
</ul>
<p>TPOT将评估population_size+generations×offspring_size的规模。</p>
<ul>
<li><p>population_size: int, optional (default=100)，在每一代遗传中保留的个体数。一定是正数。一般来说，值越大，性能越好。</p>
</li>
<li><p>offspring_size: int, optional (default=100)，在每一次遗传过程中产生的后代数量。一定是正数。</p>
</li>
<li><p>mutation_rate: float, optional (default=0.9)，变异率，采用默认值即可。</p>
</li>
<li><p>crossover_rate: float, optional (default=0.1)，交叉率，采用默认值即可。</p>
</li>
<li><p>scoring: string or callable, optional (default=’neg_mean_squared_error’)，回归问题中用于评估给定管道的质量的函数。可以使用以下内置评分函数： ‘neg_median_absolute_error’, ‘neg_mean_absolute_error’, ‘neg_mean_squared_error’, ‘r2’</p>
</li>
<li><p>cv: int, cross-validation generator, or an iterable, optional (default=5)</p>
</li>
<li><p>subsample: float, optional (default=1.0)，在TPOT优化过程中使用的训练样本的比例。必须在0到1之间。</p>
</li>
<li><p>n_jobs: integer, optional (default=1)</p>
</li>
<li><p>max_time_mins: integer or None, optional (default=None)，TPOT需要多少分钟来优化管道。</p>
</li>
<li><p>max_eval_time_mins: integer, optional (default=5)，TPOT需要多少分钟来评估一个管道。</p>
</li>
<li><p>random_state: integer or None, optional (default=None)，使用这个参数来确保TPOT每次运行时都会有相同的结果。</p>
</li>
<li><p>config_dict: Python dictionary, string, or None, optional (default=None)，用于定制TPOT在优化过程中搜索的操作符和参数的配置字典。</p>
</li>
<li><p>warm_start: boolean, optional (default=False)，表明TPOT实例是否会重用以前调用fit（）的入口。</p>
</li>
<li><p>early_stop: integer, optional (default: None)</p>
</li>
<li><p>verbosity: integer, optional (default=0)，<br>0，TPOT将不会打印任何东西，<br>1，将打印很少的信息，<br>2，TPOT将会打印更多的信息并提供一个进度条<br>3，TPOT将打印所有内容，并提供一个进度条</p>
</li>
</ul>
<p>方法：</p>
<ul>
<li>fit(features, target, sample_weight=None, groups=None)，在给定的训练数据上运行TPOT优化过程。</li>
<li>predict(features)，使用优化的管道来预测测试集的目标值。</li>
<li>score(testing_features, testing_target)，使用用户指定的评分函数在给定的测试数据上返回优化的管道的得分。</li>
<li>export(output_file_name)，将优化的管道导出为Python代码。</li>
</ul>
<h2 id="4-实例"><a href="#4-实例" class="headerlink" title="4.实例"></a>4.实例</h2><h3 id="例4-1"><a href="#例4-1" class="headerlink" title="例4.1"></a>例4.1</h3><p>数据集地址：<a href="https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/" target="_blank" rel="noopener external nofollow noreferrer">https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/</a></p>
<p>使用的数据集：breast-cancer-wisconsin.data<br>直接把数据全选复制到txt中，然后直接改文件后缀为csv，把文件转换为csv格式。并加上属性名</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/4.png" alt></p>
<p>程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">使用TPOT自动选择scikit-learn机器学习模型和参数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"> </span><br><span class="line">inputfile=<span class="string">'C:/Users/bryce/Desktop/breast-cancer-wisconsin.data.csv'</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    df=pd.read_csv(inputfile)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    df.replace(<span class="string">'?'</span>,np.nan,inplace=<span class="literal">True</span>)</span><br><span class="line">    df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">    df.drop([<span class="string">'id'</span>],<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    df[<span class="string">'Bare Nuclei'</span>] = df[<span class="string">'Bare Nuclei'</span>].astype(int)</span><br><span class="line">    X=np.array(df.drop([<span class="string">'Class'</span>],<span class="number">1</span>))</span><br><span class="line">    Y=np.array(df[<span class="string">'Class'</span>])</span><br><span class="line">    x_train,x_test,y_train,y_test=model_selection.train_test_split(X,Y,test_size=<span class="number">0.2</span>)</span><br><span class="line">    tpot=TPOTClassifier(generations=<span class="number">6</span>,verbosity=<span class="number">2</span>)</span><br><span class="line">    tpot.fit(x_train,y_train)</span><br><span class="line">    tpot.score(x_test,y_test)</span><br><span class="line">    tpot.export(<span class="string">'pipeline.py'</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/5.png" alt></p>
<p>可以看到运行的最优结果是随机森林算法,并给出具体的参数。<br>再运行一下随机森林算法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">使用TPOT自动选择scikit-learn机器学习模型和参数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"> </span><br><span class="line">inputfile=<span class="string">'C:/Users/bryce/Desktop/breast-cancer-wisconsin.data.csv'</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    df=pd.read_csv(inputfile)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    df.replace(<span class="string">'?'</span>,np.nan,inplace=<span class="literal">True</span>)</span><br><span class="line">    df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">    df.drop([<span class="string">'id'</span>],<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">'Bare Nuclei'</span>] = df[<span class="string">'Bare Nuclei'</span>].astype(int)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    X=np.array(df.drop([<span class="string">'Class'</span>],<span class="number">1</span>))</span><br><span class="line">    Y=np.array(df[<span class="string">'Class'</span>])</span><br><span class="line">    x_train,x_test,y_train,y_test=model_selection.train_test_split(X,Y,test_size=<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># tpot=TPOTClassifier(generations=6,verbosity=2)</span></span><br><span class="line">    <span class="comment"># tpot.fit(x_train,y_train)</span></span><br><span class="line">    <span class="comment"># tpot.score(x_test,y_test)</span></span><br><span class="line">    <span class="comment"># tpot.export('pipeline.py')</span></span><br><span class="line"> </span><br><span class="line">    rfc=RandomForestClassifier(bootstrap=<span class="literal">True</span>, criterion=<span class="string">'entropy'</span>, max_features=<span class="number">0.05</span>, min_samples_leaf=<span class="number">3</span>, min_samples_split=<span class="number">16</span>, n_estimators=<span class="number">100</span>)</span><br><span class="line">    rfc.fit(x_train,y_train)</span><br><span class="line">    accuracy=rfc.score(x_test,y_test)</span><br><span class="line">    print(<span class="string">"accuracy:%s"</span>%accuracy)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/6.png" alt></p>
<h3 id="例4-2"><a href="#例4-2" class="headerlink" title="例4.2"></a>例4.2</h3><p>数据集：sklearn自带的波士顿房价数据集</p>
<h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h2><ol>
<li><a href="https://epistasislab.github.io/tpot/examples/" target="_blank" rel="noopener external nofollow noreferrer">TPOT官方参考文档</a></li>
<li><a href="https://github.com/EpistasisLab/tpot" target="_blank" rel="noopener external nofollow noreferrer">TPOTgithub</a></li>
<li><a href="https://blog.csdn.net/anshuai_aw1/article/details/82498947" target="_blank" rel="noopener external nofollow noreferrer">利用TPOT完成自动化机器学习</a></li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法</title>
    <url>/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>整理一些常见的六大基础排序算法： 冒泡排序、选择排序、<strong>插入排序</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong></p>
<p><img src="/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort_summary.jpg" alt></p>
<a id="more"></a>

<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span></span><br><span class="line"><span class="comment">    2. 对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</span></span><br><span class="line"><span class="comment">    3. 针对所有的元素重复以上的步骤，除了最后已经选出的元素（有序）。</span></span><br><span class="line"><span class="comment">    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定排序，平均 O(n**2)，最好 O(n), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// swap(nums[j], nums[j+1]);</span></span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt></p>
<h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</span></span><br><span class="line"><span class="comment">    2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</span></span><br><span class="line"><span class="comment">    3. 以此类推，直到所有元素均排序完毕。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定排序，平均 O(n**2)，最好 O(n**2), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = i;</span><br><span class="line">        <span class="comment">//每一趟循环比较时，idx用于存放较小元素的数组下标，</span></span><br><span class="line">        <span class="comment">//这样当前批次比较完毕最终存放的就是此趟内最小的元素</span></span><br><span class="line">        <span class="comment">//的下标，避免每次遇到较小元素都要进行交换。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] &gt; nums[j]);</span><br><span class="line">            &#123;</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (idx !=i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[idx];</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插入排序（重要）"><a href="#3-插入排序（重要）" class="headerlink" title="3. 插入排序（重要）"></a>3. 插入排序（重要）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt></p>
<h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   直接插入排序基本思想是每一步将一个待排序的记录，</span></span><br><span class="line"><span class="comment">   插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   1. 从第一个元素开始，该元素可以认为已经被排序</span></span><br><span class="line"><span class="comment">   2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</span></span><br><span class="line"><span class="comment">   3. 如果被扫描的元素（已排序）大于新元素，将该元素后移一位</span></span><br><span class="line"><span class="comment">   4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span></span><br><span class="line"><span class="comment">   5. 将新元素插入到该位置后</span></span><br><span class="line"><span class="comment">   6. 重复步骤2~5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定排序，平均 O(n**2)，最好 O(n), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 从下标为1的元素开始选择合适的位置插入，</span></span><br><span class="line">    <span class="comment">// 因为下标为0的只有一个元素，默认是有序的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 记录要插入的数据</span></span><br><span class="line">        <span class="keyword">int</span> temp  = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i- <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//与已排序的数逐一比较，大于temp时，该数移后</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span>) &amp;&amp; (nums[j] &gt; nums[j])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-归并排序（重要）"><a href="#4-归并排序（重要）" class="headerlink" title="4. 归并排序（重要）"></a>4. 归并排序（重要）</h3><p><img src="/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/guibing1.png" alt><br><img src="/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/guibing1.png" alt></p>
<h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   将已有序的子序列合并，得到完全有序的序列；</span></span><br><span class="line"><span class="comment">   即先使每个子序列有序，再使子序列段间有序。</span></span><br><span class="line"><span class="comment">   若将两个有序表合并成一个有序表，称为二路归并。</span></span><br><span class="line"><span class="comment">   归并排序是一种稳定的排序方法。</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">1、确定数组的大小，以及输入数组中的元素值；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、将输入的数组进行分组归并；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、将整个数组分成左右两个数组，左右两个数组再向下分，直至子数组的元素少于2个时，子数组将停止分割；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4、当左右子数组不能再分割，也是都是一个元素时，比较他们的大小，进行排序合并；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5、再排序合并上一级子数组为两个元素的数组，接着再排序合并上一级子数组为四个元素的数组；</span></span><br><span class="line"><span class="comment">直至到排序合并刚开始的两个子数组，最后成为排好序的数组；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定排序，平均 O(nlogn)，最好 O(nlogn), 最差 O(nlogn),辅助空间 O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp[high+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">//临时数组指针</span></span><br><span class="line">        <span class="keyword">int</span> l=low;<span class="comment">//左序列指针</span></span><br><span class="line">        <span class="keyword">int</span> r=mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid&amp;&amp;r&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]&lt;nums[r])</span><br><span class="line">                temp[i++]=nums[l++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[i++]=nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid) <span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[i++]=nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=high) <span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[i++]=nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将temp中的元素全部拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[low++]=temp[i++];</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            mergesort(nums,low,mid);  <span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">            mergesort(nums,mid+<span class="number">1</span>,high); <span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">            merge(nums,low,high); <span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-快速排序（重要）"><a href="#5-快速排序（重要）" class="headerlink" title="5. 快速排序（重要）"></a>5. 快速排序（重要）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt></p>
<h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 从数列中挑出一个元素作为基准数。</span></span><br><span class="line"><span class="comment">    2. 重新排序数列，将比基准数大的放到右边，小于或等于它的数都放到左边。</span></span><br><span class="line"><span class="comment">    3. 再对左右区间递归执行第二步，直至各区间只有一个数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定排序，平均 O(nlogn)，最好 O(nlogn), 最差 O(n**2),辅助空间 O(logn)</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">Paritition</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> pivot = nums[low];</span><br><span class="line">   <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= pivot)</span><br><span class="line">     &#123;</span><br><span class="line">       --high;</span><br><span class="line">     &#125;</span><br><span class="line">     nums[low] = nums[high];</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt; pivot)</span><br><span class="line">     &#123;</span><br><span class="line">       ++low;</span><br><span class="line">     &#125;</span><br><span class="line">     nums[high] = nums[low];</span><br><span class="line">   &#125;</span><br><span class="line">   nums[low] = pivot;</span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> <span class="comment">//快排母函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">int</span> i = Paritition(nums, low, high);</span><br><span class="line">     QuickSort(nums, low, i - <span class="number">1</span>);</span><br><span class="line">     QuickSort(nums, i + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>精简版</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> l = low, r = high, pivot = nums[low];</span><br><span class="line">		<span class="keyword">while</span>(l&lt;r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r] &gt;=pivot) <span class="comment">// 从右向左找第一个小于基准的数</span></span><br><span class="line">			&#123;</span><br><span class="line">			    r--;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[l] = nums[r];</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l] &lt; pivot) <span class="comment">// 从左向右找第一个大于等于基准的数</span></span><br><span class="line">			&#123;</span><br><span class="line">			    l++;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[r] = nums[l];</span><br><span class="line">		&#125;</span><br><span class="line">		nums[l] = pivot;</span><br><span class="line">		quick_sort(nums, low, l<span class="number">-1</span>);</span><br><span class="line">		quick_sort(nums, l+<span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-堆排序（重要）"><a href="#6-堆排序（重要）" class="headerlink" title="6. 堆排序（重要）"></a>6. 堆排序（重要）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt></p>
<h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">堆排序的基本思想是：将待排序序列构造成一个大顶堆，</span></span><br><span class="line"><span class="comment">此时，整个序列的最大值就是堆顶的根节点。将其与末</span></span><br><span class="line"><span class="comment">尾元素进行交换，此时末尾就为最大值。然后将剩余n-1</span></span><br><span class="line"><span class="comment">个元素重新构造成一个堆，这样会得到n个元素的次小值。</span></span><br><span class="line"><span class="comment">如此反复执行，便能得到一个有序序列了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  1.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　2.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与</span></span><br><span class="line"><span class="comment">  当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定排序，平均 O(nlogn)，最好 O(nlogn), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; nums[k]&lt;nums[k+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[k] &gt;temp)</span><br><span class="line">        <span class="comment">//如果子节点大于父节点，将子节点值赋给父节点</span></span><br><span class="line">        <span class="comment">//（不用进行交换）</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = nums[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[i] = temp;    <span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">        adjustHeap(nums,i,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=len<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(nums[<span class="number">0</span>],nums[j]);</span><br><span class="line">        <span class="comment">//将堆顶元素(最大值)与末尾元素进行交换，</span></span><br><span class="line">        <span class="comment">//将最大值交换到数组的最后位置保存</span></span><br><span class="line">        adjustHeap(nums,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>泵站机组故障诊断</title>
    <url>/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/</url>
    <content><![CDATA[<h3 id="故障诊断系统概述"><a href="#故障诊断系统概述" class="headerlink" title="故障诊断系统概述"></a>故障诊断系统概述</h3><p>研究的基于自动化机器学习的故障诊断系统既具有故障诊断算法训练功能，也具有算法部署功能。它会读取故障数据，进行特征提取，然后使用自动化机器学习方法找出最优机器学习流程，并将该流程训练好保存下来，最后使用Web服务器对故障诊断算法进行部署。所研究的故障诊断系统具有高度自动化、功能拓展方便、模型更新方便的特点。</p>
<a id="more"></a>
<p>本系统由以下几个子部分构成：</p>
<p>（1）系统运行日志。日志是对系统运行状态的记录，它可以帮助检验系统运行是否正常，在出现异常情况时可以帮助使用者快速查找错误。日志的记录是分级别的，一般分为DEBUG、INFO、WARNING、ERROR、CRITICAL 五个级别，这五个级别的严重程度越来越高。</p>
<p>（2）系统配置文件。系统配置文件本质上是文本文件，通过配套的文本解析方法可以提取出变量名及其对应的设定值。系统在主功能运行前读取配置文件，从而设定程序的运行模式或训练任务，达到不改变代码就可以改变程序运行的效果。</p>
<p>（3）故障样本数据库。所研究的故障诊断算法是基于机器学习的，而机器学习方法是由数据驱动的，因此一个故障样本数据库是必要的。由于本文研究对象泵站机组具有型号多、运行工况复杂的特点，故障样本数据库在设计的时候充分考虑了这些特点。</p>
<p>（4）样本平衡性检验。在用数据进行训练之前，应该对样本平衡性进行检验，样本数量比较少的做一些特殊处理，样本数量太少的应从训练集里予以剔除，更失衡严重的就终止本次训练，等待数据收集完毕后再开始。</p>
<p>（5）故障特征提取。从故障数据库获得的数据是传感器数据，而传感器数据是无法直接作为机器学习算法输入的。为了提高故障诊断算法的效果，应该先对数据库中传感器数据使用快速傅里叶变换进行预处理。</p>
<p>（6）使用TPOT进行模型训练。采用基于遗传算法的自动化机器学习方法TPOT是使用遗传算法对特征归一化、特征选择、模型和参数选择等环节组成的机器学习流程进行自动构建并寻优的方法。</p>
<p>（7）故障诊断模型工程部署。所研究的故障诊断模型工程部署方法是基于Python轻型Web服务器框架Flask通过HTTP协议实现Python环境与Java环境的交互。</p>
<p>故障诊断系统工作流程图如下所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/liucheng1.png" alt></p>
<h3 id="故障诊断系统研究"><a href="#故障诊断系统研究" class="headerlink" title="故障诊断系统研究"></a>故障诊断系统研究</h3><h4 id="故障数据库设计规范"><a href="#故障数据库设计规范" class="headerlink" title="故障数据库设计规范"></a>故障数据库设计规范</h4><p>在泵站机组型号或运行工况不一样的情况下，虽然机组发生了同一种故障类型，但同样位置的传感器数据会有所不同，这就导致提取的特征也有点不同。因此，在故障数据存储时必须要体现出故障样本的来源背景，这里用机组型号和运行工况来表示。</p>
<p>以机组某个部件有两个传感器为例设计的故障数据库规范如下表所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/shujuku1.png" alt></p>
<h4 id="故障样本不平衡处理"><a href="#故障样本不平衡处理" class="headerlink" title="故障样本不平衡处理"></a>故障样本不平衡处理</h4><h5 id="样本不平衡下的训练方法"><a href="#样本不平衡下的训练方法" class="headerlink" title="样本不平衡下的训练方法"></a>样本不平衡下的训练方法</h5><p>针对样本不平衡下的训练数据集采用简单易行的调整类的权重方法，该方法是在误差函数里添加类别权重，以达到误差平衡，带权重的误差函数为：</p>
<p>$$<br>\text { error }=\frac{\sum_{i=1}^{n} w_{i}\left(y_{i}^{\prime}-y_{i}\right)^{2}}{n}<br>$$</p>
<p>其中：</p>
<p>$𝑛$ 代表样本总数；</p>
<p>$𝑤_𝑖$ 代表第$i$个样本所在类别的权重；</p>
<p>$y_{i}^{\prime}$代表第$i$个样本的预测结果；</p>
<p>$𝑦_𝑖$代表第$i$个样本的实际结果。</p>
<h5 id="样本不平衡下的评估方法"><a href="#样本不平衡下的评估方法" class="headerlink" title="样本不平衡下的评估方法"></a>样本不平衡下的评估方法</h5><p>在统计和机器学习中，常常用AUC 来评估二分类模型的性能（多分类也可以使用，作为二分类的拓展）。AUC 的全称是Area under the curve，即曲线下的面积。通常这里的曲线指的是受试者操作曲线(Receiver Operating Characteristic,ROC)。相比于准确率、召回率、F1 值等依赖于判决阈值的评估指标，AUC则没有这个问题。</p>
<p>ROC 曲线：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/ROC.jpg" alt></p>
<p>AUC值为ROC 曲线下方所覆盖的区域面积，AUC越大, 说明曲线越靠近(0,1) 这个点，越接近理想曲线，分类效果自然更好。</p>
<p>AUC指标为什么可以作为样本不平衡情况下的模型评价指标？因为当用来验证算法效果的数据集中的样本比例发生变化时，ROC曲线的形状能够保持不变，而AUC是ROC曲线的下方面积，所以当模型一定时，AUC的值也不随正负样本分布的变化而变化，所以能够作为不平衡数据集的模型评价指标。</p>
<h4 id="故障特征提取"><a href="#故障特征提取" class="headerlink" title="故障特征提取"></a>故障特征提取</h4><p>泵轴的常见故障有油膜涡动、接触摩擦、油膜振荡、转子不平衡和转子不对中，这些故障都可以体现在泵轴的振动信号里，通常采用泵轴的摆度数值作为它的振动信号。通过利用FFT快速傅里叶变换将时域的振动信号转换为频域的能量分布。</p>
<p>下面对泵轴的转子不平衡故障数据进行特征提取实验，介绍如下：</p>
<p>（1）数据来源传感器：泵轴$Y$方向摆度信号</p>
<p>（2）数据滤波方法与窗函数：小波阈值去噪、汉宁窗</p>
<p>（3）基频$𝐹_0$、采样频率$𝐹_𝑠$和采样点数$𝑁$：$20Hz$、$2048Hz$、$2048$由上面几个数据，可得到下面几个频谱分析需要的参数：</p>
<p>（a）最高有效频率𝐹𝑚：𝐹𝑚 = 𝐹𝑠/2.56=800Hz</p>
<p>（b）频率分辨率𝛥𝐹 ：𝛥𝐹 = 𝐹𝑠/𝑁=2048/2048=1Hz</p>
<p>（c）谱线数𝑀：𝑀 = 𝑁/2.56=2048/2.56=800</p>
<p>下图为转子不平衡故障特征提取过程。</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/tezheng.jpg" alt></p>
<p>图中共有三个子图，其中最上面的图是泵轴摆度信号的时域图，表现出<br>了周期性，中间图是对摆度信号的时域数据作快速傅立叶变换得到的频谱，最下面图是从频谱提取的特征向量。</p>
<h4 id="自动化机器学习工具TPOT"><a href="#自动化机器学习工具TPOT" class="headerlink" title="自动化机器学习工具TPOT"></a>自动化机器学习工具TPOT</h4><p><a href="/TPOT——一个自动化的Python机器学习工具.md">此节具体参考这里</a></p>
<h4 id="诊断算法的部署"><a href="#诊断算法的部署" class="headerlink" title="诊断算法的部署"></a>诊断算法的部署</h4><p>设置Web服务器，通过HTTP协议进行调用。生产环境软件通过网络IP、端口将需要诊断的数据传递给Web服务器。Web服务器接受到数据后会进行诊断服务，在诊断结束后，诊断结果会原路返回给服务调用者。<br>诊断数据与Web 服务器之间使用HTTP协议进行通信，HTTP协议下有GET、POST、PUT 和DELETE 等方法，因为通信过程中需要传输传感器数据，所以这里使用可携带数据体的POST方法。</p>
<p>在故障诊断的各个环节中，诊断算法具有“一次加载、多次使用”的特点，而特征提取、算法调用等步骤随着传输数据的不同而采用不同的方法，所以故障诊断Web服务器在实现时应该按照这样的方式：加载诊断算法在创建故障诊断Web服务器时进行，数据获取、特征提取、调用诊断算法和诊断结果返回这些步骤在POST方法中实现。</p>
<h3 id="故障诊断系统具体实现"><a href="#故障诊断系统具体实现" class="headerlink" title="故障诊断系统具体实现"></a>故障诊断系统具体实现</h3><h4 id="系统开发环境"><a href="#系统开发环境" class="headerlink" title="系统开发环境"></a>系统开发环境</h4><p>故障诊断系统是在Windows 10上使用Python编程语言开发的，<br>其中数据库使用SQL Server，日志管理使用Logging，配置文件解析加载使用Configparser，频域分析工具包使用Scipy，矩阵数据处理使用Pandas 和Numpy，自动化机器学习工具使用TPOT，模型序列化保存工具使用Pickle，Web 应用框架使用Flask。</p>
<p>下表是详细的故障诊断系统开发环境。</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/environment.png" alt></p>
<h4 id="系统功能模块的实现"><a href="#系统功能模块的实现" class="headerlink" title="系统功能模块的实现"></a>系统功能模块的实现</h4><h5 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h5><p>系统日志管理工具使用Logging 模块实现，具体的是使用了Logging 下的logger 对象，使用logger 对象可以避免多个程序使用同一个日志文件时产生重复记录的问题。系统日志管理工具被打包成一个独立的文件，方便不同任务的复用。<a href="https://cuiqingcai.com/6080.html" target="_blank" rel="noopener external nofollow noreferrer">logging模块的基本用法</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_logger</span><span class="params">()</span>:</span></span><br><span class="line">    logger = logging.getLogger(__name__)</span><br><span class="line">    logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    stream_handler = logging.StreamHandler()</span><br><span class="line">    stream_handler.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    file_handler = logging.FileHandler(filename=<span class="string">'日志.log'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    file_handler.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">    formatter = logging.Formatter(fmt=<span class="string">'%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">    stream_handler.setFormatter(formatter)</span><br><span class="line">    file_handler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">    logger.addHandler(stream_handler)</span><br><span class="line">    logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logger</span><br></pre></td></tr></table></figure>

<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>配置文件的格式有ini、toml、yaml、json 和xml 等，其中ini格式的最为简单直观，这里使用的配置文件就是ini格式.部分配置如下图所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/ini.jpg" alt></p>
<h4 id="建立机组故障数据库"><a href="#建立机组故障数据库" class="headerlink" title="建立机组故障数据库"></a>建立机组故障数据库</h4><p>利用数据库SQL Server 2017 与数据库可视化管理工具Navicat Premium进行搭建，首先参考<a href="https://www.cnblogs.com/ios9/p/9527939.html" target="_blank" rel="noopener external nofollow noreferrer">Win10 SQL Server 2017安装</a>，利用Navicat进行创建一个Faults数据库，并在Faults数据库中创建Rotor表如图所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan2.png" alt></p>
<p>然后根据数据库设计规范，在表中创建相对应的字段。如图所示:</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan.png" alt></p>
<p><strong>注意：</strong> SQL Server 2017不支持数组形式，这里采用将数组转化为字符串,将他们拼接起来当做文本写入。</p>
<p>字段类型在设置的时候注意采用nvarchar(max)的类型，具体如下图：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan3.png" alt></p>
<p><a href="https://data.mendeley.com/datasets/p9bsmj4xwg/1/files/9ecd3bf8-6ed0-452b-8c84-05a4833ac803" target="_blank" rel="noopener external nofollow noreferrer">Rotor数据</a>, 数据是.mat文件，利用Python处理数据后，写入数据库CGQ1这一列中，最终如图所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan4.png" alt></p>
<h5 id="平衡性检验"><a href="#平衡性检验" class="headerlink" title="平衡性检验"></a>平衡性检验</h5><p>平衡性检验工具的实现是先使用Pandas 筛选数据，然后使用Collections模块的Counter 工具进行统计。</p>
<h5 id="故障特征提取-1"><a href="#故障特征提取-1" class="headerlink" title="故障特征提取"></a>故障特征提取</h5><p>故障特征提取工具以独立的代码文件形式进行存放，该工具是多个特征提取函数的集合，如果想使用哪个特征提取函数，只需要在配置文件里指定函数名，如果想使用的函数不存在，模仿已有的函数编辑添加即可。通过这样的设计，无需更改主函数就可改变系统功能。特征提取函数代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span><span class="params">(string)</span>:</span></span><br><span class="line">    string_arr = string.split(<span class="string">','</span>)</span><br><span class="line">    <span class="comment">#print(string_arr)</span></span><br><span class="line">    float_arr = list(map(float, string_arr))</span><br><span class="line">    <span class="keyword">return</span> float_arr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotor_simple</span><span class="params">(arr, logger, conf=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(arr,dict):<span class="comment">#如果数据来源于web,  isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。</span></span><br><span class="line">        arr = trans(arr)</span><br><span class="line">    <span class="comment">#print(arr[1])</span></span><br><span class="line">    rotation_frequency = round(float(arr[<span class="number">0</span>])/<span class="number">60</span>) <span class="comment"># 旋转频率</span></span><br><span class="line">    sample_frequency = int(arr[<span class="number">1</span>]) <span class="comment"># 采样频率</span></span><br><span class="line">    useful_bandwidth = int(sample_frequency/<span class="number">2.56</span>) <span class="comment"># 有效带宽</span></span><br><span class="line">    <span class="keyword">if</span> useful_bandwidth&lt;rotation_frequency*<span class="number">6</span>:</span><br><span class="line">        logger.warning(<span class="string">'数据采样频率过低！数据作废'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    sensor_data = transfer(arr[<span class="number">3</span>]) <span class="comment"># 将逗号拼接的传感器数据变成数组</span></span><br><span class="line">    data_length = len(sensor_data) <span class="comment"># 采样长度</span></span><br><span class="line">    sample_time = data_length/sample_frequency <span class="comment"># 采样时间</span></span><br><span class="line">    frequency_resolution = <span class="number">1</span>/sample_time <span class="comment"># 频率分辨率</span></span><br><span class="line">    <span class="keyword">if</span> (rotation_frequency&lt;<span class="number">10</span> <span class="keyword">and</span> frequency_resolution&gt;<span class="number">0.1</span>) <span class="keyword">or</span> sample_time&lt;<span class="number">1</span>:</span><br><span class="line">        logger.warning(<span class="string">'采样时间过短！数据作废'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    f0_candidates = [rotation_frequency<span class="number">-2</span>,rotation_frequency<span class="number">-1</span>,rotation_frequency,rotation_frequency+<span class="number">1</span>,rotation_frequency+<span class="number">2</span>] <span class="comment"># 基频</span></span><br><span class="line">    spectrum = abs(fft(sensor_data))[:useful_bandwidth]/len(sensor_data)  <span class="comment"># 频谱</span></span><br><span class="line">    f0 = f0_candidates[spectrum[f0_candidates].argmax()]<span class="comment"># 确定基频</span></span><br><span class="line">    segments = [[<span class="number">1</span>,int(<span class="number">0.40</span>*f0)],[int(<span class="number">0.40</span>*f0),int(<span class="number">0.50</span>*f0)],</span><br><span class="line">                [int(<span class="number">0.5</span>*f0)],[int(<span class="number">0.50</span>*f0)+<span class="number">1</span>,int(f0)],[f0],[int(<span class="number">2</span>*f0)],</span><br><span class="line">                [int(<span class="number">3</span>*f0),int(<span class="number">5</span>*f0)+<span class="number">1</span>],[int(<span class="number">6</span>*f0),useful_bandwidth]]</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> seg <span class="keyword">in</span> segments:</span><br><span class="line">        <span class="keyword">if</span> len(seg)==<span class="number">2</span>:</span><br><span class="line">            max_value = max(spectrum[seg[<span class="number">0</span>]:seg[<span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_value = spectrum[seg[<span class="number">0</span>]]</span><br><span class="line">        temp.append(max_value)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotor</span><span class="params">(data, useful_labels, conf, model_dir, logger)</span>:</span></span><br><span class="line">    djzs_field_name = conf[<span class="string">'Table'</span>][<span class="string">'djzs_field_name'</span>]</span><br><span class="line">    gzlx_field_name = conf[<span class="string">'Table'</span>][<span class="string">'gzlx_field_name'</span>]</span><br><span class="line">    cypl_field_name = conf[<span class="string">'Table'</span>][<span class="string">'cypl_field_name'</span>]</span><br><span class="line">    filtered_data = data.loc[:,[djzs_field_name,cypl_field_name,gzlx_field_name,<span class="string">'CGQ1'</span>]][data[gzlx_field_name].isin(useful_labels)]</span><br><span class="line">    </span><br><span class="line">    config_for_web = &#123;<span class="string">'mission'</span>:conf[<span class="string">'Mission'</span>][<span class="string">'table'</span>],</span><br><span class="line">                      <span class="string">'label'</span>:useful_labels,</span><br><span class="line">                     <span class="string">'function_for_web'</span>:conf[<span class="string">'Mission'</span>][<span class="string">'extract_feature_function_for_web'</span>]&#125;</span><br><span class="line">    <span class="keyword">with</span> open(model_dir+<span class="string">'\config_for_web.json'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        json.dump(config_for_web, file, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    feature_and_label = []</span><br><span class="line">    <span class="keyword">for</span> arr <span class="keyword">in</span> filtered_data.values:</span><br><span class="line">        temp = rotor_simple(arr, logger)</span><br><span class="line">        <span class="keyword">if</span> temp != <span class="literal">None</span>:<span class="comment"># 数据有效</span></span><br><span class="line">            temp.append(useful_labels.index(arr[<span class="number">2</span>]))</span><br><span class="line">            feature_and_label.append(temp)</span><br><span class="line">    feature_and_label = np.array(feature_and_label, dtype=np.float32)</span><br><span class="line">    </span><br><span class="line">    column = [<span class="string">'feature&#123;&#125;'</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(feature_and_label.shape[<span class="number">1</span>]<span class="number">-1</span>)]+[<span class="string">'label'</span>]</span><br><span class="line">    df = pd.DataFrame(data=feature_and_label, columns=column)</span><br><span class="line">    df.to_csv(model_dir+<span class="string">'\\feature_and_label.csv'</span>, index=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> feature_and_label</span><br></pre></td></tr></table></figure>

<h5 id="自动化机器学习"><a href="#自动化机器学习" class="headerlink" title="自动化机器学习"></a>自动化机器学习</h5><p>Python 的第三方包TPOT已经实现了基于遗传算法的自动化机器学习，通过在Python 环境中安装TPOT，并且调用相关方法即可实现自动化机器学习。部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger.info(<span class="string">'自动化机器学习初始化...'</span>)</span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"></span><br><span class="line">generations = int(conf[<span class="string">'Tpot'</span>][<span class="string">'generations'</span>])</span><br><span class="line">population_size = int(conf[<span class="string">'Tpot'</span>][<span class="string">'population_size'</span>])</span><br><span class="line">verbosity = int(conf[<span class="string">'Tpot'</span>][<span class="string">'verbosity'</span>])</span><br><span class="line"></span><br><span class="line">model = TPOTClassifier(generations=generations, population_size=population_size,  scoring=<span class="string">'f1_macro'</span>, cv=<span class="number">5</span>, n_jobs=<span class="number">1</span>, verbosity=verbosity)</span><br><span class="line">feature = feature_and_label[:,:<span class="number">-1</span>]</span><br><span class="line">label = feature_and_label[:,<span class="number">-1</span>]</span><br><span class="line">logger.info(<span class="string">'初始化完毕，开始寻找最优机器学习流程...'</span>)</span><br><span class="line">model.fit(feature, label)</span><br><span class="line">logger.info(<span class="string">'寻优结束，开始保存最优机器学习流程...'</span>)</span><br><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line">joblib.dump(model.fitted_pipeline_, model_dir+<span class="string">'\pipeline.pkl'</span>)</span><br><span class="line">logger.info(<span class="string">'保存成功，训练结束！'</span>)</span><br></pre></td></tr></table></figure>


<h5 id="故障诊断系统部署"><a href="#故障诊断系统部署" class="headerlink" title="故障诊断系统部署"></a>故障诊断系统部署</h5><p>利用Python轻型Web框架来进行部署构建故障诊断Web服务器。加载诊断算法和实现HTTP的POST方法。、</p>
<p>加载诊断算法并创建Web服务器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">function_for_web = &#123;&#125;</span><br><span class="line">pipeline = &#123;&#125;</span><br><span class="line">label = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> model_dirs:</span><br><span class="line">    logger.info(<span class="string">'正在读取web配置文件...'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(each+<span class="string">'\config_for_web.json'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            config_for_web = json.load(file)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        logger.error(<span class="string">'读取配置文件&#123;&#125;失败！'</span>.format(each+<span class="string">'\config.ini'</span>), exc_info=<span class="literal">True</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    logger.info(<span class="string">'web配置文件读取完成'</span>)</span><br><span class="line">    </span><br><span class="line">    mission = config_for_web[<span class="string">'mission'</span>]</span><br><span class="line">    function_for_web[mission] = config_for_web[<span class="string">'function_for_web'</span>]</span><br><span class="line">    pipeline[mission] = joblib.load(each+<span class="string">'\pipeline.pkl'</span>)</span><br><span class="line">    label[mission] = config_for_web[<span class="string">'label'</span>]</span><br><span class="line">    </span><br><span class="line">app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">5050</span>)</span><br></pre></td></tr></table></figure>

<p>POST方法实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/',methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diagnose</span><span class="params">()</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    all_data = request.json</span><br><span class="line">    missions = all_data.keys()</span><br><span class="line"><span class="comment">#     logger.info(str(missions))</span></span><br><span class="line">    <span class="keyword">for</span> mission <span class="keyword">in</span> missions:</span><br><span class="line">        exec(<span class="string">'from extract_features import &#123;0&#125; as extract_function'</span>.format(function_for_web[mission]), globals())</span><br><span class="line">        data = all_data[mission]</span><br><span class="line">        feature = extract_function(data, logger, conf)<span class="comment"># feature is a list</span></span><br><span class="line">        proba = pipeline[mission].predict_proba(np.array(feature, np.float32).reshape(<span class="number">1</span>, <span class="number">-1</span>))[<span class="number">0</span>]</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(proba):</span><br><span class="line">            result[label[mission][i]] = <span class="string">'%.1f'</span>%round(float(v)*<span class="number">100</span>,<span class="number">1</span>)</span><br><span class="line">        results[mission] = result</span><br><span class="line"><span class="comment">#     print(results)</span></span><br><span class="line">    <span class="keyword">return</span> json.dumps(results, ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h5 id="故障诊断系统测试"><a href="#故障诊断系统测试" class="headerlink" title="故障诊断系统测试"></a>故障诊断系统测试</h5><p>使用泵轴故障数据（数据类别为正常、转子不对中、转子不平衡、接触摩擦样本各45 个，来源工况单一）来简单测试一下所实现故障诊断系统，测试结果下图所示，横坐标代表机器学习流程组成的种群代数，纵坐标代表每代种群中最优机器学习流程的AUC评分。</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/res.jpg" alt></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>圆圈中最后剩下的数字</title>
    <url>/2020/03/30/62_%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>0,1，···n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<a id="more"></a>

<h2 id="本题考点："><a href="#本题考点：" class="headerlink" title="本题考点："></a>本题考点：</h2><p>  约瑟夫环问题</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h2><p>  1.) 模拟法</p>
<p>  用数组列表模拟一下。创建一个数组存储0-n-1的数组，但数组长度大于1时，就计算end位置即为(start+m-1)%len(nums) ，删除该元素后然后start再等于之前end，最后数组中剩最后一个元素，返回nums[0]</p>
<p>  时间复杂度O(n),空间复杂度O(n)</p>
<p>  2.) 数学方法：</p>
<p>  将上述问题建模为函数 f(n, m)，该函数的返回值为最终留下的元素的序号。</p>
<p>  每删除一个元素，下一个元素成为最开始的头，相当于把数组向前移动m位。若已知n-1个人时，删除下标位置位f(n−1,m)，则n个人的时候，就是往后移动m位，(因为有可能数组越界，超过的部分会被接到头上，所以还要模n)，既f(n,m) = (f(n-1,m) + m) % n</p>
<p>  递归公式为：$f(n, m)=(f(n-1, m)+m) \% n$</p>
<p>  时间复杂度O(n),空间复杂度O(n)</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="方法一：模拟法"><a href="#方法一：模拟法" class="headerlink" title="方法一：模拟法"></a>方法一：模拟法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res =<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span> || m&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">end</span> = (start+m<span class="number">-1</span>)%(nums.<span class="built_in">size</span>());</span><br><span class="line">            nums.erase(nums.<span class="built_in">begin</span>()+<span class="built_in">end</span>);  </span><br><span class="line">            <span class="comment">// vector插入删除操作时间复杂度是O(n)，可能会超时</span></span><br><span class="line">            start = <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二：数学法"><a href="#方法二：数学法" class="headerlink" title="方法二：数学法"></a>方法二：数学法</h4><p>迭代：空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归：空间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(n,m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (f(n<span class="number">-1</span>,m) + m) %n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/u011500062/article/details/72855826" target="_blank" rel="noopener external nofollow noreferrer">约瑟夫环——公式法（递推公式）</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>TPOT优化原理部分源码解读</title>
    <url>/2020/03/28/TPOT%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>TPOT的涉及到的建模过程，以TPOT light为例主要有3块：Classifiers、Preprocesssors、Selectors，TPOT的遗传算法优化是以pipeline为基础的，也就是说pipeline就相当于基因序列。通过构建初始pipeline，再经过遗传算法中的交叉、变异最终生成符合条件的模型效果较好的pipeline。我们从最优的那一代中选取其中建模效果最好的pipeline即可，TPOT是基于scikit-learn框架的，它本身不去实现我们常用的分类回归等算法。而是通过遗传算法优化pipeline。也就是从中选出最优的数据处理、特征选择、分类算法的组合。</p>
<a id="more"></a>
<p>一个简单的TPOT的使用实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"> </span><br><span class="line">iris = load_digits()</span><br><span class="line">iris.data[<span class="number">0</span>:<span class="number">5</span>], iris.target</span><br><span class="line"><span class="keyword">print</span> iris</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line">X_train.shape, X_test.shape, y_train.shape, y_test.shape</span><br><span class="line"> </span><br><span class="line">tpot = TPOTClassifier(verbosity=<span class="number">2</span>, max_time_mins=<span class="number">2</span>,config_dict=<span class="string">"TPOT light"</span>,population_size=<span class="number">10</span>,mutation_rate=<span class="number">0.9</span>,crossover_rate=<span class="number">0.1</span>)</span><br><span class="line">tpot.fit(X_train, y_train)</span><br><span class="line">print(tpot.score(X_test, y_test))</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/2020/03/28/TPOT%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/1.png" alt></p>
<h3 id="部分核心源码解读"><a href="#部分核心源码解读" class="headerlink" title="部分核心源码解读"></a>部分核心源码解读</h3><h4 id="1、初始群体的生成"><a href="#1、初始群体的生成" class="headerlink" title="1、初始群体的生成"></a>1、初始群体的生成</h4><p>这段代码可以看出，pipeline的构建是通过生成不同深度的树类构建初始pipeline的，大致过程是先确定树的深度，从Classifiers中选择一个分类器放入树的顶端，接下来构建分类器的参数，以上均为随机选取。如果树的深度大于1，则还需要从Preprocesssors、Selectors中选择算子加入到pipeline中，还要进行参数初始化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@_pre_test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate</span><span class="params">(self, pset, min_, max_, condition, type_=None)</span>:</span></span><br><span class="line">    <span class="string">"""Generate a Tree as a list of lists.</span></span><br><span class="line"><span class="string">    The tree is build from the root to the leaves, and it stop growing when</span></span><br><span class="line"><span class="string">    the condition is fulfilled.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    pset: PrimitiveSetTyped</span></span><br><span class="line"><span class="string">        Primitive set from which primitives are selected.</span></span><br><span class="line"><span class="string">    min_: int</span></span><br><span class="line"><span class="string">        Minimum height of the produced trees.</span></span><br><span class="line"><span class="string">    max_: int</span></span><br><span class="line"><span class="string">        Maximum Height of the produced trees.</span></span><br><span class="line"><span class="string">    condition: function</span></span><br><span class="line"><span class="string">        The condition is a function that takes two arguments,</span></span><br><span class="line"><span class="string">        the height of the tree to build and the current</span></span><br><span class="line"><span class="string">        depth in the tree.</span></span><br><span class="line"><span class="string">    type_: class</span></span><br><span class="line"><span class="string">        The type that should return the tree when called, when</span></span><br><span class="line"><span class="string">        :obj:None (default) no return type is enforced.</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    individual: list</span></span><br><span class="line"><span class="string">        A grown tree with leaves at possibly different depths</span></span><br><span class="line"><span class="string">        dependending on the condition function.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> type_ <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        type_ = pset.ret</span><br><span class="line">    expr = []</span><br><span class="line">    height = np.random.randint(min_, max_)</span><br><span class="line">    stack = [(<span class="number">0</span>, type_)]</span><br><span class="line">    <span class="keyword">while</span> len(stack) != <span class="number">0</span>:</span><br><span class="line">        depth, type_ = stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># We've added a type_ parameter to the condition function</span></span><br><span class="line">        <span class="keyword">if</span> condition(height, depth, type_):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                term = np.random.choice(pset.terminals[type_])</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                _, _, traceback = sys.exc_info()</span><br><span class="line">                <span class="keyword">raise</span> IndexError(</span><br><span class="line">                    <span class="string">'The gp.generate function tried to add '</span></span><br><span class="line">                    <span class="string">'a terminal of type &#123;&#125;, but there is'</span></span><br><span class="line">                    <span class="string">'none available. &#123;&#125;'</span>.format(type_, traceback)</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">if</span> inspect.isclass(term):</span><br><span class="line">                term = term()</span><br><span class="line">            expr.append(term)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                prim = np.random.choice(pset.primitives[type_])</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                _, _, traceback = sys.exc_info()</span><br><span class="line">                <span class="keyword">raise</span> IndexError(</span><br><span class="line">                    <span class="string">'The gp.generate function tried to add '</span></span><br><span class="line">                    <span class="string">'a primitive of type &#123;&#125;, but there is'</span></span><br><span class="line">                    <span class="string">'none available. &#123;&#125;'</span>.format(type_, traceback)</span><br><span class="line">                )</span><br><span class="line">            expr.append(prim)</span><br><span class="line">            <span class="keyword">for</span> arg <span class="keyword">in</span> reversed(prim.args):</span><br><span class="line">                stack.append((depth + <span class="number">1</span>, arg))</span><br><span class="line">    <span class="keyword">return</span> expr</span><br></pre></td></tr></table></figure>

<h4 id="2、适应性值评估检测"><a href="#2、适应性值评估检测" class="headerlink" title="2、适应性值评估检测"></a>2、适应性值评估检测</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_evaluate_individuals</span><span class="params">(self, individuals, features, target, sample_weight=None, groups=None)</span>:</span></span><br><span class="line">    <span class="string">"""Determine the fit of the provided individuals.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    individuals: a list of DEAP individual</span></span><br><span class="line"><span class="string">        One individual is a list of pipeline operators and model parameters that can be</span></span><br><span class="line"><span class="string">        compiled by DEAP into a callable function</span></span><br><span class="line"><span class="string">    features: numpy.ndarray &#123;n_samples, n_features&#125;</span></span><br><span class="line"><span class="string">        A numpy matrix containing the training and testing features for the individual's evaluation</span></span><br><span class="line"><span class="string">    target: numpy.ndarray &#123;n_samples&#125;</span></span><br><span class="line"><span class="string">        A numpy matrix containing the training and testing target for the individual's evaluation</span></span><br><span class="line"><span class="string">    sample_weight: array-like &#123;n_samples&#125;, optional</span></span><br><span class="line"><span class="string">        List of sample weights to balance (or un-balanace) the dataset target as needed</span></span><br><span class="line"><span class="string">    groups: array-like &#123;n_samples, &#125;, optional</span></span><br><span class="line"><span class="string">        Group labels for the samples used while splitting the dataset into train/test set</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    fitnesses_ordered: float</span></span><br><span class="line"><span class="string">        Returns a list of tuple value indicating the individual's fitness</span></span><br><span class="line"><span class="string">        according to its performance on the provided data</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"> </span><br><span class="line">    operator_counts, eval_individuals_str, sklearn_pipeline_list, stats_dicts = self._preprocess_individuals(individuals)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Make the partial function that will be called below</span></span><br><span class="line">    partial_wrapped_cross_val_score = partial(</span><br><span class="line">        _wrapped_cross_val_score,</span><br><span class="line">        features=features,</span><br><span class="line">        target=target,</span><br><span class="line">        cv=self.cv,</span><br><span class="line">        scoring_function=self.scoring_function,</span><br><span class="line">        sample_weight=sample_weight,</span><br><span class="line">        groups=groups,</span><br><span class="line">        timeout=self.max_eval_time_seconds</span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line">    result_score_list = []</span><br><span class="line">    <span class="comment"># Don't use parallelization if n_jobs==1</span></span><br><span class="line">    <span class="keyword">if</span> self.n_jobs == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> sklearn_pipeline <span class="keyword">in</span> sklearn_pipeline_list:</span><br><span class="line">            self._stop_by_max_time_mins()</span><br><span class="line">            val = partial_wrapped_cross_val_score(sklearn_pipeline=sklearn_pipeline)</span><br><span class="line">            result_score_list = self._update_val(val, result_score_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># chunk size for pbar update</span></span><br><span class="line">        <span class="comment"># chunk size is min of cpu_count * 2 and n_jobs * 4</span></span><br><span class="line">        chunk_size = min(cpu_count()*<span class="number">2</span>, self.n_jobs*<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> chunk_idx <span class="keyword">in</span> range(<span class="number">0</span>, len(sklearn_pipeline_list), chunk_size):</span><br><span class="line">            self._stop_by_max_time_mins()</span><br><span class="line">            parallel = Parallel(n_jobs=self.n_jobs, verbose=<span class="number">0</span>, pre_dispatch=<span class="string">'2*n_jobs'</span>)</span><br><span class="line">            tmp_result_scores = parallel(delayed(partial_wrapped_cross_val_score)(sklearn_pipeline=sklearn_pipeline)</span><br><span class="line">                                         <span class="keyword">for</span> sklearn_pipeline <span class="keyword">in</span> sklearn_pipeline_list[chunk_idx:chunk_idx + chunk_size])</span><br><span class="line">            <span class="comment"># update pbar</span></span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> tmp_result_scores:</span><br><span class="line">                result_score_list = self._update_val(val, result_score_list)</span><br><span class="line"> </span><br><span class="line">    self._update_evaluated_individuals_(result_score_list, eval_individuals_str, operator_counts, stats_dicts)</span><br><span class="line"> </span><br><span class="line">    <span class="string">"""Look up the operator count and cross validation score to use in the optimization"""</span></span><br><span class="line">    <span class="keyword">return</span> [(self.evaluated_individuals_[str(individual)][<span class="string">'operator_count'</span>],</span><br><span class="line">             self.evaluated_individuals_[str(individual)][<span class="string">'internal_cv_score'</span>])</span><br><span class="line">            <span class="keyword">for</span> individual <span class="keyword">in</span> individuals]</span><br></pre></td></tr></table></figure>

<h3 id="3、变异"><a href="#3、变异" class="headerlink" title="3、变异"></a>3、变异</h3><p>变异主要是增加pipeline的内容或更换其中的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_random_mutation_operator</span><span class="params">(self, individual, allow_shrink=True)</span>:</span></span><br><span class="line">    <span class="string">"""Perform a replacement, insertion, or shrink mutation on an individual.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    individual: DEAP individual</span></span><br><span class="line"><span class="string">        A list of pipeline operators and model parameters that can be</span></span><br><span class="line"><span class="string">        compiled by DEAP into a callable function</span></span><br><span class="line"><span class="string">    allow_shrink: bool (True)</span></span><br><span class="line"><span class="string">        If True the `mutShrink` operator, which randomly shrinks the pipeline,</span></span><br><span class="line"><span class="string">        is allowed to be chosen as one of the random mutation operators.</span></span><br><span class="line"><span class="string">        If False, `mutShrink`  will never be chosen as a mutation operator.</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    mut_ind: DEAP individual</span></span><br><span class="line"><span class="string">        Returns the individual with one of the mutations applied to it</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    mutation_techniques = [</span><br><span class="line">        partial(gp.mutInsert, pset=self._pset),</span><br><span class="line">        partial(mutNodeReplacement, pset=self._pset)</span><br><span class="line">    ]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># We can't shrink pipelines with only one primitive, so we only add it if we find more primitives.</span></span><br><span class="line">    number_of_primitives = sum([isinstance(node, deap.gp.Primitive) <span class="keyword">for</span> node <span class="keyword">in</span> individual])</span><br><span class="line">    <span class="keyword">if</span> number_of_primitives &gt; <span class="number">1</span> <span class="keyword">and</span> allow_shrink:</span><br><span class="line">        mutation_techniques.append(partial(gp.mutShrink))</span><br><span class="line"> </span><br><span class="line">    mutator = np.random.choice(mutation_techniques)</span><br><span class="line"> </span><br><span class="line">    unsuccesful_mutations = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(self._max_mut_loops):</span><br><span class="line">        <span class="comment"># We have to clone the individual because mutator operators work in-place.</span></span><br><span class="line">        ind = self._toolbox.clone(individual)</span><br><span class="line">        offspring, = mutator(ind)</span><br><span class="line">        <span class="keyword">if</span> str(offspring) <span class="keyword">not</span> <span class="keyword">in</span> self.evaluated_individuals_:</span><br><span class="line">            <span class="comment"># Update statistics</span></span><br><span class="line">            <span class="comment"># crossover_count is kept the same as for the predecessor</span></span><br><span class="line">            <span class="comment"># mutation count is increased by 1</span></span><br><span class="line">            <span class="comment"># predecessor is set to the string representation of the individual before mutation</span></span><br><span class="line">            <span class="comment"># generation is set to 'INVALID' such that we can recognize that it should be updated accordingly</span></span><br><span class="line">            offspring.statistics[<span class="string">'crossover_count'</span>] = individual.statistics[<span class="string">'crossover_count'</span>]</span><br><span class="line">            offspring.statistics[<span class="string">'mutation_count'</span>] = individual.statistics[<span class="string">'mutation_count'</span>] + <span class="number">1</span></span><br><span class="line">            offspring.statistics[<span class="string">'predecessor'</span>] = (str(individual),)</span><br><span class="line">            offspring.statistics[<span class="string">'generation'</span>] = <span class="string">'INVALID'</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            unsuccesful_mutations += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Sometimes you have pipelines for which every shrunk version has already been explored too.</span></span><br><span class="line">    <span class="comment"># To still mutate the individual, one of the two other mutators should be applied instead.</span></span><br><span class="line">    <span class="keyword">if</span> ((unsuccesful_mutations == <span class="number">50</span>) <span class="keyword">and</span></span><br><span class="line">            (type(mutator) <span class="keyword">is</span> partial <span class="keyword">and</span> mutator.func <span class="keyword">is</span> gp.mutShrink)):</span><br><span class="line">        offspring, = self._random_mutation_operator(individual, allow_shrink=<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> offspring,</span><br></pre></td></tr></table></figure>

<h3 id="4、交叉"><a href="#4、交叉" class="headerlink" title="4、交叉"></a>4、交叉</h3><p>选取两个pipeline，对里面的内容进行互换，但是两个pipeline的primitive要相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pick_two_individuals_eligible_for_crossover</span><span class="params">(population)</span>:</span></span><br><span class="line">    <span class="string">"""Pick two individuals from the population which can do crossover, that is, they share a primitive.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    population: array of individuals</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    tuple: (individual, individual)</span></span><br><span class="line"><span class="string">        Two individuals which are not the same, but share at least one primitive.</span></span><br><span class="line"><span class="string">        Alternatively, if no such pair exists in the population, (None, None) is returned instead.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    primitives_by_ind = [set([node.name <span class="keyword">for</span> node <span class="keyword">in</span> ind <span class="keyword">if</span> isinstance(node, gp.Primitive)])</span><br><span class="line">                         <span class="keyword">for</span> ind <span class="keyword">in</span> population]</span><br><span class="line">    pop_as_str = [str(ind) <span class="keyword">for</span> ind <span class="keyword">in</span> population]</span><br><span class="line"> </span><br><span class="line">    eligible_pairs = [(i, i+<span class="number">1</span>+j) <span class="keyword">for</span> i, ind1_prims <span class="keyword">in</span> enumerate(primitives_by_ind)</span><br><span class="line">                                 <span class="keyword">for</span> j, ind2_prims <span class="keyword">in</span> enumerate(primitives_by_ind[i+<span class="number">1</span>:])</span><br><span class="line">                                 <span class="keyword">if</span> <span class="keyword">not</span> ind1_prims.isdisjoint(ind2_prims) <span class="keyword">and</span></span><br><span class="line">                                    pop_as_str[i] != pop_as_str[i+<span class="number">1</span>+j]]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Pairs are eligible in both orders, this ensures that both orders are considered</span></span><br><span class="line">    eligible_pairs += [(j, i) <span class="keyword">for</span> (i, j) <span class="keyword">in</span> eligible_pairs]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> eligible_pairs:</span><br><span class="line">        <span class="comment"># If there are no eligible pairs, the caller should decide what to do</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    pair = np.random.randint(<span class="number">0</span>, len(eligible_pairs))</span><br><span class="line">    idx1, idx2 = eligible_pairs[pair]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> population[idx1], population[idx2]</span><br></pre></td></tr></table></figure>

<p>TPOT设置了一个阈值来决定是交叉还是变异，默认情况下变异的概率为0.9，交叉的概率为0.1.我们可以修改这个阈值。</p>
<p>具体的pipeline变换如下：</p>
<p>默认的种群数量为100，为了看源码方便，改为了5个种群数。交叉变异的概率各为0.5.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tpot = TPOTClassifier(verbosity=<span class="number">2</span>, max_time_mins=<span class="number">2</span>,config_dict=<span class="string">"TPOT light"</span>,population_size=<span class="number">5</span>,mutation_rate=<span class="number">0.5</span>,crossover_rate=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p>初始种群为5个pipeline，分别为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> = &#123;Individual&#125; KNeighborsClassifier(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), KNeighborsClassifier__n_neighbors=<span class="number">79</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br><span class="line"><span class="number">1</span> = &#123;Individual&#125; KNeighborsClassifier(Binarizer(input_matrix, Binarizer__threshold=<span class="number">0.55</span>), KNeighborsClassifier__n_neighbors=<span class="number">84</span>, KNeighborsClassifier__p=<span class="number">2</span>, KNeighborsClassifier__weights=uniform)</span><br><span class="line"><span class="number">2</span> = &#123;Individual&#125; DecisionTreeClassifier(input_matrix, DecisionTreeClassifier__criterion=gini, DecisionTreeClassifier__max_depth=<span class="number">9</span>, DecisionTreeClassifier__min_samples_leaf=<span class="number">18</span>, DecisionTreeClassifier__min_samples_split=<span class="number">20</span>)</span><br><span class="line"><span class="number">3</span> = &#123;Individual&#125; LogisticRegression(StandardScaler(input_matrix), LogisticRegression__C=<span class="number">0.0001</span>, LogisticRegression__dual=<span class="literal">True</span>, LogisticRegression__penalty=l2)</span><br><span class="line"><span class="number">4</span> = &#123;Individual&#125; GaussianNB(input_matrix)</span><br></pre></td></tr></table></figure>
<p>经过第一轮交叉、变异，结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> = &#123;Individual&#125; LogisticRegression(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), LogisticRegression__C=<span class="number">0.1</span>, LogisticRegression__dual=<span class="literal">True</span>, LogisticRegression__penalty=l2)</span><br><span class="line"><span class="number">1</span> = &#123;Individual&#125; KNeighborsClassifier(input_matrix, KNeighborsClassifier__n_neighbors=<span class="number">79</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br><span class="line"><span class="number">2</span> = &#123;Individual&#125; KNeighborsClassifier(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), KNeighborsClassifier__n_neighbors=<span class="number">79</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br><span class="line"><span class="number">3</span> = &#123;Individual&#125; GaussianNB(input_matrix)</span><br><span class="line"><span class="number">4</span> = &#123;Individual&#125; KNeighborsClassifier(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), KNeighborsClassifier__n_neighbors=<span class="number">84</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br></pre></td></tr></table></figure>

<p>然后对这几个pipeline进行打分评估，和上一轮pipeline一起选出score最高的前5个。</p>
<p>进入下一轮迭代。最后产生5个pipeline，打分，从中选出最优的那个：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Best pipeline: KNeighborsClassifier(input_matrix, n_neighbors=<span class="number">10</span>, p=<span class="number">2</span>, weights=distance)</span><br><span class="line"><span class="number">0.977777777778</span></span><br></pre></td></tr></table></figure>

<p>流程举例如下（具体流程和TPOT代码本身略有区别，但是不影响对遗传算法自动化建模的理解）</p>
<p><img src="/2020/03/28/TPOT%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/2.png" alt></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://blog.csdn.net/hgy0403/article/details/81291307" target="_blank" rel="noopener external nofollow noreferrer">TPOT遗传算法</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Github分支备份Hexo博客源文件</title>
    <url>/2020/03/21/%E5%88%A9%E7%94%A8Github%E5%88%86%E6%94%AF%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>Hexo 部署博客很方便，我的这个博客也是用 Hexo 部署在 GitHub Pages 上的，有得人可能在多台电脑上写博客，这个时候需要把博客的源文件备份在一个地方，这样只需把博客源文件复制下来就可以在另一个地方写博客并部署到 GitHub Pages上了</p>
<a id="more"></a>
<p>本篇介绍的就是利用博客的 repo 分支（ master 分支的必须用来存放你博客网站文件）托管 Hexo 源文件和配置达到备份的目的，下面开始正题</p>
<h4 id="把博客目录的源文件push到repo分支上"><a href="#把博客目录的源文件push到repo分支上" class="headerlink" title="把博客目录的源文件push到repo分支上"></a>把博客目录的源文件push到repo分支上</h4><p>cd 进入博客目录，Git 初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>完成之后，添加修改的文件，Hexo 就自带了 .gitignore 文件需要忽略的文件 都已经默认配置好了，add 全部文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>然后commit：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;commit first time&quot;</span><br></pre></td></tr></table></figure>
<p>提交成功之后，接下来就是 push 到github了，需要先把这 Hexo 源文件映射到远程 repo 上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;your-name&#x2F;your-name.github.io.git</span><br></pre></td></tr></table></figure>

<p>接下来就是把Hexo源文件 push 上去，但是关键的地方到了，master上是 Hexo 生成博客网页的代码，而我们 Hexo 源文件是要 push 到一个分支上面的，所以接下来先要在 repo 上新建一个分支</p>
<p>新建一个叫做blogSource的分支(注意：分支名要和本地hexo项目名一致，不然push会出错)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch blogSource</span><br></pre></td></tr></table></figure>

<p>查看本地分支，并且切换到 blogSource 分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git checkout blogSource</span><br></pre></td></tr></table></figure>

<p>然后拉取远程代码，再把刚才添加的 Hexo 源文件代码 push 到blogSource这个分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br><span class="line">git push -u origin blogSource</span><br></pre></td></tr></table></figure>
<p>然后就可以在 repo 上看到分支里面已经有博客的源文件了</p>
<h4 id="日常更新博客源文件"><a href="#日常更新博客源文件" class="headerlink" title="日常更新博客源文件"></a>日常更新博客源文件</h4><p>以后你本地的博客源文件的修改就可以直接用 git 命令 push 到 repo 的 blogSource 分支上了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .  &#x2F;&#x2F;添加修改内容到本地仓储</span><br><span class="line">git commit -m &#39;modify blog&#39;  &#x2F;&#x2F;提交修改内容到本地仓库</span><br><span class="line">git push --set-upstream origin blogSource  &#x2F;&#x2F;配置push，以方便后期直接git push推送</span><br><span class="line">git push  &#x2F;&#x2F;将本地分支和分支下的内容推送到远程</span><br></pre></td></tr></table></figure>

<p>注意：执行 git push –set-upstream origin blogSource 命令之后，以后修改博客源文件代码之后，直接使用 git push 不用再指定分支，就可以把代码 push 到 blogSource 分支上了</p>
<h4 id="更换地点使用-repo-分支上的博客源文件"><a href="#更换地点使用-repo-分支上的博客源文件" class="headerlink" title="更换地点使用 repo 分支上的博客源文件"></a>更换地点使用 repo 分支上的博客源文件</h4><p>换一台电脑，配置好 Hexo 的环境，<a href="https://xiaovv.me/2017/04/06/GitHub%E9%85%8D%E7%BD%AESSH-key/" target="_blank" rel="noopener external nofollow noreferrer">配置 Git SSH key</a>，把博客源文件代码克隆下来:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone xxxxxxxxx.xx (你的 github page 的 repo 地址)</span><br></pre></td></tr></table></figure>

<p>博客源文件下载下来之后，默认的分支是 master，需要切换到 blogSource 分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout origin&#x2F;blogSource</span><br></pre></td></tr></table></figure>

<p>然后cd到博客目录依次执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>接下来就可以开始愉快的写博客了，写完之后记得把源文件代码 push 到 Github 上，然后用 Hexo 部署到自己博客上面</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + NexT主题博客相关设置</title>
    <url>/2020/03/21/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="一、添加文章版权声明功能"><a href="#一、添加文章版权声明功能" class="headerlink" title="一、添加文章版权声明功能"></a>一、添加文章版权声明功能</h4><p>打开博客目录下的主题配置文件（/themes/next/_config.yml），找到Declare license on posts 标签，进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Declare license on posts</span><br><span class="line">post_copyright:</span><br><span class="line">  enable: true    #激活版权声明模块</span><br><span class="line">  license: CC BY-NC-SA 3.0     #版权许可协议</span><br><span class="line">  license_url: https:&#x2F;&#x2F;winney07.github.io&#x2F;      #声明的文章的可点击链接（域名）</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>配置完后，执行以下命令，在浏览器中访问，效果如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/next-set1.png" alt></p>
<h4 id="二、设置favicon图标"><a href="#二、设置favicon图标" class="headerlink" title="二、设置favicon图标"></a>二、设置favicon图标</h4><p>1、选择一个favicon制作网站完成制作，例如：比特虫 ，制作一个16*16，一个32*32的；</p>
<p>2、两个不同尺寸大小的文件，重名为favicon-16x16-next.png和favicon-32x32-next.png；</p>
<p>3、将重命名的两个图片文件放到博客目录下的themes/next/source/images中（覆盖原来的两个默认的）<br>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/favicon.png" alt></p>
<h3 id="三、添加友情链接"><a href="#三、添加友情链接" class="headerlink" title="三、添加友情链接"></a>三、添加友情链接</h3><p>打开主题配置文件（/themes/next/_config.yml），找到以下内容进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: 友情链接 </span><br><span class="line"># links_layout: block   &#x2F;&#x2F;块状显示（选择了行内显示，这个要注释掉，不然会报错）</span><br><span class="line">links_layout: inline    &#x2F;&#x2F;行内显示</span><br><span class="line">links:</span><br><span class="line">  小超: https:&#x2F;&#x2F;www.xiaochao.me&#x2F;</span><br><span class="line">  Github: https:&#x2F;&#x2F;www.github.com</span><br></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/friend-link.png" alt></p>
<h4 id="四、调整hexo页面宽度"><a href="#四、调整hexo页面宽度" class="headerlink" title="四、调整hexo页面宽度"></a>四、调整hexo页面宽度</h4><p>博客在浏览器上的留白太多，因此想增加文章的宽度。</p>
<p>打开/themes/next/source/css/_variables/custom.styl 添加两行代码即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$main-desktop &#x3D; 1200px </span><br><span class="line">$content-desktop &#x3D; 900px</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>在Hexo博客中发布文章</title>
    <url>/2020/03/21/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h4 id="1、新建一篇文章"><a href="#1、新建一篇文章" class="headerlink" title="1、新建一篇文章"></a>1、新建一篇文章</h4><p>（1）在hexo博客目录下，进入Git Bash命令窗口中，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;在这里&quot;</span><br></pre></td></tr></table></figure>

<p>（2）在博客目录下的/source/_posts/ 文件夹下，可以看到已经生成了标题为(在这里.md)的博客文件：<br>如图所示：<br><img src="https://winney07.github.io/2018/08/02/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/zai.png" alt></p>
<a id="more"></a>
<p>（3）在（在这里.md）文件中编辑自己的博客文章即可。<br>注意：Hexo 发布的文章是 Markdown 格式的文件， Markdown 基本语法的网址：<a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener external nofollow noreferrer">点这里前往</a></p>
<h4 id="2、给文章添加分类和标签"><a href="#2、给文章添加分类和标签" class="headerlink" title="2、给文章添加分类和标签"></a>2、给文章添加分类和标签</h4><p>(1) 在（在这里.md）文件中设置tags和categories属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 在这里</span><br><span class="line">date: 2018-08-02 11:41:10</span><br><span class="line">tags:</span><br><span class="line">- 博客           &#x2F;&#x2F;多个标签可以这样添加</span><br><span class="line">- hexo</span><br><span class="line">categories: test</span><br></pre></td></tr></table></figure>
<p>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/zai-edit.png" alt></p>
<h4 id="3、启动服务器，本地测试"><a href="#3、启动服务器，本地测试" class="headerlink" title="3、启动服务器，本地测试"></a>3、启动服务器，本地测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h4 id="4、添加“阅读全文”按钮"><a href="#4、添加“阅读全文”按钮" class="headerlink" title="4、添加“阅读全文”按钮"></a>4、添加“阅读全文”按钮</h4><p>方法一：在文章任意你想添加的位置添加即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p>方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto_excerpt进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>

<p>其中length代表显示摘要的截取字符长度。</p>
<p>注：这两种方法，在博客首页显示的效果不一样，根据自己的需要，选择自己喜欢的方法</p>
<h4 id="5、在博文中添加图片"><a href="#5、在博文中添加图片" class="headerlink" title="5、在博文中添加图片"></a>5、在博文中添加图片</h4><p>方法一：</p>
<p>(1)在blog目录下，安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>(2)在blog\source 目录下新建一个images文件夹，把图片放置在里面；</p>
<p>(3)在xxx.md文件中引用图片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![header]( images&#x2F;header.jpg)</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<p>(1)在全局配置文件（blog/_config.yml)中将post_asset_folder设置为true；</p>
<p>(2)创建文章（在创建的时候，会在blog/source/_post目录下，生成一个XXX.md文件和一个XXX的文件夹）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;XXX&quot;</span><br></pre></td></tr></table></figure>

<p>(3)把XXX这个博文需要展示的图片放在XXX文件夹目录下；</p>
<p>(4)在XXX.md文件中引入图片的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![你想输入的替代文字](XXX&#x2F;图片名.jpg)</span><br></pre></td></tr></table></figure>
<h4 id="6、发布到Github上"><a href="#6、发布到Github上" class="headerlink" title="6、发布到Github上"></a>6、发布到Github上</h4><p>（1）发表的文章在本地预览无误后，在 Git Bash 命令窗口执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>（2）在浏览器，访问自己的博客域名，即可看到刚 发布的文章</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>将Hexo博客主题更换为NexT主题</title>
    <url>/2020/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p>1、把默认主题更改成Next主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>这是将Next主题下载到blog目录的themes主题下的next文件夹中。打开站点的_config.yml配置文件，修改主题为next<br><img src="/2020/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/1.jpg" alt></p>
<a id="more"></a>
<p>打开<strong>主题theme</strong>的_config.yml配置文件，不是<strong>站点site</strong>主题文件，找到Scheme Settings<br><img src="/2020/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/2.jpg" alt><br>next主题有三个样式，我用的是Pisces，可以选择你自己喜欢的样式（只需要把行首的#去除，#是注释），选择好后，再次部署网站，hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。</p>
<p>2、在主题配置文件 _config.yml中配置博客网站底部的基本信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup.</span><br><span class="line">  # If not defined, current year will be used.</span><br><span class="line">  since: 2020      #网站起始运营年份</span><br><span class="line"></span><br><span class="line">  # Icon between year and copyright info.</span><br><span class="line">  icon: user     #声明图标</span><br><span class="line"></span><br><span class="line">  # If not defined, will be used &#96;author&#96; from Hexo main config.</span><br><span class="line">  copyright: bryceustc   #版权所有</span><br><span class="line">  # ------------------------------------------------------------</span><br><span class="line">  # Hexo link (Powered by Hexo).</span><br><span class="line">  powered: true</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">    enable: false    #是否显示主题</span><br><span class="line">    # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">    version: false     #是否显示驱动</span><br></pre></td></tr></table></figure>

<p>3、在主题配置文件 _config.yml中配置菜单按钮，找到menu属性，做以下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line"> home: &#x2F; || home     #首页，后面的表示图标</span><br><span class="line"> categories: &#x2F;categories&#x2F; || th   #分类</span><br><span class="line"> tags: &#x2F;tags&#x2F; || tags       #标签</span><br><span class="line"> archives: &#x2F;archives&#x2F; || archive     #归档</span><br><span class="line"> about: &#x2F;about&#x2F; || user       #关于</span><br><span class="line"> #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line"> #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line"> #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure>
<p>4、创建相应的页面</p>
<p>（1）执行命令hexo s，本地预览我们的博客页面，会发现，点击分类、标签、关于这几个页面的时候，会显示404。</p>
<p>（2）在Git Bash命令窗口，输入以下命令来创建相应页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &#39;categories&#39;</span><br><span class="line">hexo new page &#39;tags&#39;</span><br><span class="line">hexo new page &#39;about&#39;</span><br></pre></td></tr></table></figure>
<p>（3）可以在hexo/source目录下看到创建的3个文件夹<br><img src="https://winney07.github.io/2018/08/01/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/source.png" alt></p>
<p>5、每一个分类菜单都生成了一个 index.md 初始文件（在刚创建的文件夹目录下），默认包含了 title 和 date 字段，我们需要给每一 index.md 文件添加上 type 字段<br>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-3-20 16:28:33</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-3-20 16:28:33</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2020-3-20 16:28:33</span><br><span class="line">type: about</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>6、配置搜索菜单：<br>（1）安装 hexo-generator-searchdb ，在 Git Bash 命令窗口，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>（2）打开全局配置文件（hexo/_config.yml），新增以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>（3）打开主题配置文件（hexo/themes/next/_config.yml），找到 local_search 属性，开启本地搜索功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>
<p>7、执行命令hexo s，本地预览我们的博客页面，发现刚才的配置已经完成</p>
<p>8、在命令窗口，输入以下命令，将修改后的本地hexo项目托管到GitHub上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>9、上传成功后，可以通过自己的博客域名访问修改主题和修改相关配置后的博客页面</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + GitHub Pages 搭建个人博客</title>
    <url>/2020/03/19/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><h4 id="1、安装Node-js"><a href="#1、安装Node-js" class="headerlink" title="1、安装Node.js"></a>1、安装Node.js</h4><p>(1) 下载Node.js：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener external nofollow noreferrer">官网下载地址</a> （这里以Windows 为例）;</p>
<p><img src="/images/node.png" alt></p>
<a id="more"></a>
<p>(2) 双击下载好的.msi文件，按下一步下一步，安装好就可以；</p>
<p>(3) 在cmd命令窗口，输入下面的这个命令，如果能够显示Node.js的版本，说明安装成功了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<p><img src="/images/node_v.png" alt></p>
<h4 id="2、安装Git"><a href="#2、安装Git" class="headerlink" title="2、安装Git"></a>2、安装Git</h4><p>(1) 下载Git：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener external nofollow noreferrer">官网下载</a></p>
<p>(2) 双击下载好的Git安装包，按下一步下一步，进行安装即可；</p>
<p>(3) 在cmd命令窗口，输入下面的这个命令，如果能够显示Git的版本，说明安装成功了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p><img src="/images/git_v.png" alt></p>
<h3 id="二、Hexo搭建博客"><a href="#二、Hexo搭建博客" class="headerlink" title="二、Hexo搭建博客"></a>二、Hexo搭建博客</h3><h4 id="1、安装Hexo"><a href="#1、安装Hexo" class="headerlink" title="1、安装Hexo"></a>1、安装Hexo</h4><p>（1）在计算机中，新建一个Blog文件夹，用于存放自己的博客内容。</p>
<p>（2）在Blog文件夹内，鼠标右键，选择Git Bash,进入到命令窗口</p>
<p><img src="/images/blog.png" alt></p>
<p>（3）在命令窗口中，输入下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h4 id="2、初始化Hexo"><a href="#2、初始化Hexo" class="headerlink" title="2、初始化Hexo"></a>2、初始化Hexo</h4><p>在命令窗口中，输入下面代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<h4 id="3、配置Hexo"><a href="#3、配置Hexo" class="headerlink" title="3、配置Hexo"></a>3、配置Hexo</h4><p>(1) 安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>(2) 部署形成的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g &#x2F;&#x2F;或者 hexo generate</span><br></pre></td></tr></table></figure>

<h4 id="4、启动服务器"><a href="#4、启动服务器" class="headerlink" title="4、启动服务器"></a>4、启动服务器</h4><p>(1) 在命令窗口执行下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s  &#x2F;&#x2F;或者 hexo server</span><br></pre></td></tr></table></figure>

<p>(2) 在浏览器地址栏中输入<a href="http://localhost:4000/" target="_blank" rel="noopener external nofollow noreferrer">http://localhost:4000/</a> （默认端口是4000），如果能够看到如图所示的效果，说明初始化的Hexo博客搭建成功了。<br>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-blog.png" alt></p>
<h4 id="三、将本地的-Hexo-博客部署到-GitHub-Pages上"><a href="#三、将本地的-Hexo-博客部署到-GitHub-Pages上" class="headerlink" title="三、将本地的 Hexo 博客部署到 GitHub Pages上"></a>三、将本地的 Hexo 博客部署到 GitHub Pages上</h4><p>（1）新建一个仓库，仓库名为bryceustc.github.io（这个仓库的名称必须严格按照 username.github.io 的格式来命名）【前提是你要有一个Github账号】<br>如图所示：（因为我已经创建过这个库了，所以会显示红色警告，只是后来为了截图，重新写一个同名的）</p>
<p><img src="/images/github.png" alt></p>
<p>（2）进入已经创建好的仓库（点击自己的头像，选择Your profile，点击刚创建好的那个仓库进去仓库里面），点击settings，找到GitHub Pages 选项，点击 Choose a theme 选择一个主题（可以选择也可以不选择，根据自己的需求决定是否操作这一步）<br>如图所示：</p>
<p><img src="/images/gitpages.png" alt></p>
<p>（3）配置Git个人信息，在winneyBlog目录下，鼠标右键，选择Git Bash，进入命令窗口，输入下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Github用户名&quot;       &#x2F;&#x2F;自己Github的账号名</span><br><span class="line">git config --global user.email &quot;Github邮箱&quot;        &#x2F;&#x2F;自己注册Github的邮箱地址</span><br></pre></td></tr></table></figure>

<p>（4）生成SSH KEY,意思是生成一个公钥和密钥，因为Github需要一个密钥才能与本地相连接。在命令窗口输入下面的命令，然后需要连续按3次回车生成密钥（每按一次回车你可以看到对应的信息） 【你也可以先查看是否已经有了ssh密钥：cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C  &quot;Github邮箱&quot;        &#x2F;&#x2F;自己注册Github的邮箱地址</span><br></pre></td></tr></table></figure>

<p>如图所示：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh-key.png" alt></p>
<p>（5）生成的SSH KEY会保存到 C:/Users/电脑名用户名/.ssh 目录中（根据你自己电脑用户名，打开对应的目录）</p>
<ul>
<li>打开.ssh 这个目录，打开 id_rsa.pub 文件，复制里面的全部内容（这些内容就是密钥）<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/user-ssh.png" alt></li>
</ul>
<p>（6）在GitHub中添加SSH keys</p>
<ul>
<li><p>打开Github，点击头像，选择Settings；</p>
</li>
<li><p>选择SSH and GPG keys项,点击右上角New SSH key按钮，将刚刚复制到的密钥粘贴到key输入框中，title自己给它命一个名就好<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/add-key.png" alt></p>
</li>
<li><p>最后点击Add Key，如果显示这样的界面，说明SSH KEY 配置成功：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh-keys.png" alt></p>
</li>
</ul>
<p>（7）修改全局配置文件</p>
<ul>
<li><p>在blog文件夹下，找到_config.yml文件；如图所示：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy.png" alt></p>
</li>
<li><p>复制仓库地址：如图所示：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/git-href.png" alt></p>
</li>
<li><p>修改_config.yml文件里的deploy属性(目的是将本地hexo项目放到Github上)如图所示：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy.png" alt></p>
</li>
</ul>
<p><strong>注：</strong>【如果repository中填写的是https协议的，hexo d上传代码到Github时有下面类似错误，可以将repository改为ssh的链接】<br>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy-error.png" alt></p>
<p><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh-link.png" alt></p>
<p>（8）安装hexo-deployer-git 插件，目的是将代码快速托管到Github上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>（9）将hexo项目托管到GitHub上（命令可以分开写也可以一起写）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>备注:<br>hexo clean // 清除缓存文件 (db.json) 和已生成的静态文件 (public)</p>
<p>hexo generate // 部署之前预先生成静态文件，简写为hexo g</p>
<p>hexo deploy // 文件生成后立即部署网站，简写为hexo d</p>
<p>（10）在浏览器地址栏输入 <a href="https://username.github.io/" target="_blank" rel="noopener external nofollow noreferrer">https://username.github.io/</a> 即可访问，（username也就是你的Github账户名），如果能够正常访问，并且跟本地hexo项目显示的内容是一样的，那么说明你已经把本地hexo项目部署到Github上了。</p>
<h4 id="四、配置博客的个人信息"><a href="#四、配置博客的个人信息" class="headerlink" title="四、配置博客的个人信息"></a>四、配置博客的个人信息</h4><p>（1）在hexo目录中，找到全局配置文件_config.yml</p>
<p>（2）配置信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html</span><br><span class="line">## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: Bryce&#39;s Blog</span><br><span class="line">subtitle: Learn Everything.</span><br><span class="line">description: A Student From USTC.</span><br><span class="line">author: Bryce</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone: Asia&#x2F;Shanghai</span><br><span class="line"></span><br><span class="line"># URL 博客地址</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: https:&#x2F;&#x2F;bryceustc.github.io&#x2F;</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br><span class="line"></span><br><span class="line"># Directory 目录设置</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads&#x2F;code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link:</span><br><span class="line">  enable: true # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: &#39;&#39;</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: true</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace: &#39;&#39;</span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br><span class="line"></span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default &#x3D; &#39;&#39;)</span><br><span class="line"># per_page: Posts displayed per page. (0 &#x3D; disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#39;&#39;</span><br><span class="line">  per_page: 5 #每页文章数量</span><br><span class="line">  order_by: -date</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Metadata elements</span><br><span class="line">## https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTML&#x2F;Element&#x2F;meta</span><br><span class="line">meta_generator: true</span><br><span class="line"></span><br><span class="line"># Date &#x2F; Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F;</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">## Use post&#39;s date for updated date unless set in front-matter</span><br><span class="line">use_date_for_updated: false</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Include &#x2F; Exclude file(s)</span><br><span class="line">## include:&#x2F;exclude: options only apply to the &#39;source&#x2F;&#39; folder</span><br><span class="line">include:</span><br><span class="line">exclude:</span><br><span class="line">ignore:</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next</span><br><span class="line">plugins: hexo-generate-feed</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;bryceustc&#x2F;bryceustc.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>注意：.yml 文件有严格的格式要求，文件里所有的配置都是：冒号 空格 值，并且冒号是英文状态下的输入。想了解更多的可以前往官网。</p>
<p>（3）在博客目录下，右键点击Git Bash，进去命令窗口，输入下面的命令，即可在浏览器中看到刚刚设置的内容显示在页面中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server    &#x2F;&#x2F;简写为hexo s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/2020/03/18/3_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0~n-1范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2，3，1，0，2，5，3}，那么对应的输出是重复的数字2或者3</p>
<a id="more"></a>

<p>在一个长度为n+1的数组里的所有数字都在1~n范围内。所以数组中至少有一个数是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，输入长度为8的数组{2，3，5，4，3，2，6，7}，那么对应的输出是重复的数字2或者3。</p>
<h2 id="本题考点"><a href="#本题考点" class="headerlink" title="本题考点"></a>本题考点</h2><p>  1). 一维数组的理解，一维数组在内存中占据连续空间，可以根据下标定位对应的元素</p>
<p>  2). 二分查找算法的理解，快速正确实现二分查找</p>
<p>  3). 时间复杂度与空间复杂度的理解</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>  1). 把输入的数组进行排序，排序后再判断有无重复数字，时间复杂度为O(nlogn)</p>
<p>  2). 使用哈希表来解决，时间复杂度为O(n)，但空间复杂度也为O(n)</p>
<p>  3). 交换位置重排法，把每个数字放回对应位置的方法。如果出现一个数字无法放回（所在位置已经是对应数字了），那么说明该数字重复，时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>  4). 题目二可以依照题目一的思路来，不过由于不能修改输入数组，所以可以构建一个n+1大小的辅助数组，构建了辅助数组之后可以使用hash表也可以使用换位置的思路来做 </p>
<p>  5). 使用二分的思想来做，二分基数组，但这种方法不能找出所有重复的数字，时间复杂度为O(nlogn)，空间复杂度为O(1)，相当于用时间换取空间</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="方法一：排序后直接查找"><a href="#方法一：排序后直接查找" class="headerlink" title="方法一：排序后直接查找"></a>方法一：排序后直接查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Duplication</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums.empty()||n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> || nums[i] &gt; n - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(nums[i]);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：利用哈希表"><a href="#方法二：利用哈希表" class="headerlink" title="方法二：利用哈希表"></a>方法二：利用哈希表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Duplication</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums.empty() || n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> || nums[i] &gt; n<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                m[i]++;</span><br><span class="line">                <span class="keyword">if</span>(m[i]&gt;<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(i);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法三：交换位置重排"><a href="#方法三：交换位置重排" class="headerlink" title="方法三：交换位置重排"></a>方法三：交换位置重排</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Duplication</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums,<span class="keyword">int</span> n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//异常值检测</span></span><br><span class="line">            <span class="keyword">if</span> (nums.empty() || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//越界检测</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]&lt; <span class="number">0</span> || nums[i] &gt; n<span class="number">-1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//只要当前数值与索引不等，就要一直替换</span></span><br><span class="line">                <span class="keyword">while</span> (nums[i]!=i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//一旦遇到当前的数值与另外一个换位的值相等，就停止，说明找到了重复的数字</span></span><br><span class="line">                    <span class="keyword">if</span> (nums[i] == nums[nums[i]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(nums[i]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        flag = <span class="literal">true</span>;  <span class="comment">//return直接跳出所有循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                    nums[i] = nums[temp];</span><br><span class="line">                    nums[temp] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法四：二分法查找"><a href="#方法四：二分法查找" class="headerlink" title="方法四：二分法查找"></a>方法四：二分法查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ( nums.empty() || n &lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">end</span> = n;</span><br><span class="line">      <span class="keyword">while</span>(<span class="built_in">end</span> &gt; start)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;=start &amp;&amp; nums[i]&lt;=mid)</span><br><span class="line">            &#123;</span><br><span class="line">              m++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; mid - start+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">           start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://blog.csdn.net/hunanchenxingyu/article/details/8101795" target="_blank" rel="noopener external nofollow noreferrer">循环结构中break、continue、return和exit的区别</a></p>
</li>
<li><p><a href="https://blog.csdn.net/zolalad/article/details/11848739" target="_blank" rel="noopener external nofollow noreferrer">时间复杂度和空间复杂度</a></p>
</li>
<li><p><a href="https://github.com/bryceustc/LeetCode_Note/blob/master/cpp/Find-First-And-Last-Position-Of-Element-In-Sorted-Array/BinarySearch.md" target="_blank" rel="noopener external nofollow noreferrer">二分查找算法</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
