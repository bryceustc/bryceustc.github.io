<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++单例模式Singleton的实现</title>
    <url>/2020/04/01/C-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FSingleton%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="问题情景"><a href="#问题情景" class="headerlink" title="问题情景"></a>问题情景</h3><p>在windows下面打开任务管理器，我们会发现，你只能打开一个任务管理器。如果在已打开一个任务管理器的情况下，再次打开任务管理器，系统会调出已经打开的窗口，而不是重新打开新的窗口。在系统中，之多只能存在一个任务管理器的实例。按照一般的思路，我们需要定义一个TaskManager的类（如下）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TaskManager()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>但这存在问题，只要我们调用一次初始化函数，系统就会生成一个TaskManager的实例，不能保证系统中之多只存在一个实例的要求。于是我们需要采用设计模式中的单例模式（Singleton）来实现。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>单例模式的两个功能：仅有一个实例和全局访问点。我们通过Singleton的类图来看一下这个模式：</p>
<p><img src="/2020/04/01/C-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FSingleton%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png" alt></p>
<p>在Singleton中，类的初始化函数被设为了private，这就意味着Client是不能通过调用类的初始化函数来生成一个实例，防止Client多次调用初始化函数生成多个实例出来。如果要访问Singleton，需要通过GetInstance方法，这是一个静态的方法，主要负责创建自己的实例，返回实例的指针给Client。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)<span class="comment">//第一次调用要判断指针是否为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                p_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Singleton()&#123;&#125;; <span class="comment">//构造函数设计成私有的</span></span><br><span class="line">        <span class="keyword">static</span> Singleton *p_instance; <span class="comment">//用类的指针指向唯一的实例</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//静态数据成员是静态存储的，必须对他进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *object = Singleton::GetInstance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Singleton类封装了它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单的说就是对唯一实例的受控访问。一般的，Singleton不会定义析构函数，由于实例分配的是全局地址，在程序运行结束，被系统收回所有分配空间时，Singleton才会被销毁，如果Singleton成员数据太多的话，可能占用了大量的内存空间而不能被释放，这需要我们注意。</p>
<h3 id="Singleton与全局变量的区别"><a href="#Singleton与全局变量的区别" class="headerlink" title="Singleton与全局变量的区别"></a>Singleton与全局变量的区别</h3><p>Singleton与全局变量都有全局访问的功能，但两者之间存在一些差别，全局变量在使用的过程中会存在一些问题：</p>
<ul>
<li>变量名冲突：必须小心维护变量名，每遇到一个全局变量，都必须仔细分辨该变量属于哪个模块、哪个程序。</li>
<li>耦合度难题：使用全局变量增加了函数与模块间的耦合程度，不易维护。</li>
<li>单个实体问题：全局变量不能防止一个类生成多个实例出来。</li>
<li>多线程访问：并发访问时需要使用同步机制，小心保护全局变量，避免冲突。</li>
</ul>
<p>看起来，使用Singleton可以避免上面的这些问题，但Singleton自身也有一些弊端。</p>
<h3 id="Singleton的优缺点"><a href="#Singleton的优缺点" class="headerlink" title="Singleton的优缺点"></a>Singleton的优缺点</h3><p>Singleton的优点：</p>
<ul>
<li>跨平台：使用合适的中间件可以把Singleton扩展为跨多个计算机工作。</li>
<li>适用于任何类：只要将初始化函数设为私有，并增加相应的静态函数和变量，就能把类变成Singleton。</li>
<li>延迟性：如果Singleton从未使用，就不会创建（仅指懒汉模式）</li>
</ul>
<p>Singleton的缺点：</p>
<ul>
<li>效率问题：由于if语句的存在，调用方法的效率收到影响。</li>
<li>不变重用：在C++下需要定义模板才能实现Singleton的重用。</li>
</ul>
<h3 id="Singleton的懒汉模式与饿汉模式"><a href="#Singleton的懒汉模式与饿汉模式" class="headerlink" title="Singleton的懒汉模式与饿汉模式"></a>Singleton的懒汉模式与饿汉模式</h3><p>针对Singleton初始化函数的调用策略，有两种选择，分别是懒汉模式和饿汉模式。</p>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><p>使用懒汉模式时，Singleton在程序第一次调用的时候才会初始化自己，代码如下。使用该模式时，由于if语句的存在，会影响调用的效率。而且，在多线程环境下使用时，为了保证只能初始化一个实例，需要用锁来保证线程安全性，防止同时多个线程进入if语句中。如果遇到处理大量数据时，锁会成为整个性能的瓶颈。一般懒汉模式适用于程序一部分中需要使用Singleton，且在实例化后没有大量频繁访问或线程访问的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mtx.lock();</span><br><span class="line">                <span class="keyword">if</span> (p_instance == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    p_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">                mtx.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Singleton()&#123;&#125;; <span class="comment">//构造函数设计成私有的</span></span><br><span class="line">        <span class="keyword">static</span> Singleton *p_instance; <span class="comment">//用类的指针指向唯一的实例</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//静态数据成员是静态存储的，必须对他进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *object = Singleton::GetInstance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>PS:
GCC在Linux下的std::mutex工作良好。 然而，在Windows上很遗憾，
_GLIBCXX_HAS_GTHREADS没有在Windows上定义。mutex运行时支持是不存在的。</code></pre><h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>使用饿汉模式时，Singleton在程序一开始就将自己实例化，之后的GetInstance方法仅返回实例的指针即可，这样就解决了上述提到的if语句影响效率的问题。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Singleton* p_instance = <span class="keyword">new</span> Singleton();<span class="comment">//在此直接实例化</span></span><br><span class="line">        Singleton()&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p_instance;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>饿汉模式适用于Singleton在程序运行过程中一直被频繁调用，这样由于预先加载了实例，访问实例时没有if语句，效率更高。但要注意到，如果Singleton的成员比较庞大、复杂，实例化Singleton会花一些时间，且这个实例一直占用着大量内存，在使用时要注意这部分的开销。使用饿汉模式用于多线程编程的话，由于线程访问之前，实例已存在，就不需要像懒汉模式中加入锁，因此饿汉模式保证了多线程安全。饿汉模式比较适用于程序整个运行过程中都需要访问、会被频繁访问或者需要被多线程访问的情况。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++源文件到可执行文件的过程</title>
    <url>/2020/04/01/C-%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>对于C/C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤：</p>
<p>1、预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。</p>
<p>2、编译：将预处理后的文件转换成汇编语言，生成.s文件</p>
<p>3、汇编：汇编变为目标代码(机器代码)生成.o的文件</p>
<p>4、链接：连接目标代码,生成可执行程序</p>
<a id="more"></a>
<p>程序的基本流程如图：</p>
<p><img src="/2020/04/01/C-%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/1.jfif" alt></p>
<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>预处理主要包含下面的内容：</p>
<ul>
<li>对所有的“#define”进行宏展开；</li>
<li>处理所有的条件编译指令，比如“#if”,“#ifdef”，“#elif”，“#else”,“#endif”</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归的，也就是说被包含的文件可能还包含其他文件</li>
<li>删除所有的注释“//”和“/**/”</li>
<li>添加行号和文件标识</li>
<li>保留所有的“#pragma”编译器指令</li>
</ul>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>将预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后，产生相应的汇编代码文件(.s文件)。</p>
<h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p>汇编器是将汇编代码转变成机器可以执行的代码，每一个汇编语句几乎都对应一条机器指令。最终产生目标文件(.o或.obj文件)。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>连接目标代码,生成可执行程序。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针详解</title>
    <url>/2020/04/01/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>智能指针分为三种：shared_ptr, unique_ptr, weak_ptr。本文就是详细介绍一下智能指针，作为笔记，方便理解。</p>
<p>智能指针的作用是动态分配内存，避免内存泄漏。</p>
<a id="more"></a>
<pre><code>PS:
内存泄漏：
    程序没有释放已经不再使用的内存，由于设计错误，导致在释放该段内存
    之前就失去了对该段内存的控制，因此这段内存一直被占用，无法释放，造
    成空间的浪费。

内存溢出：
    要求分配的内存超过了系统所能给我的，系统不能满足需求。内存泄漏的堆
    积如果不及时处理最终会导致内存溢出。</code></pre><h2 id="shared-ptr介绍"><a href="#shared-ptr介绍" class="headerlink" title="shared_ptr介绍"></a>shared_ptr介绍</h2><p>shared_ptr是一个引用计数智能指针，用于共享对象的所有权，也就是说它允许多个指针指向同一个对象</p>
<h3 id="shared-ptr的简单使用："><a href="#shared-ptr的简单使用：" class="headerlink" title="shared_ptr的简单使用："></a>shared_ptr的简单使用：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Example() : e(<span class="number">1</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Example Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">        ~Example() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Example Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Example&gt; <span class="title">pInt</span><span class="params">(<span class="keyword">new</span> Example())</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*pInt).e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pInt引用计数: "</span> &lt;&lt; pInt.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Example&gt; pInt2 = pInt;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pInt引用计数: "</span> &lt;&lt; pInt.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pInt2引用计数: "</span> &lt;&lt; pInt2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Example Constructor...</span><br><span class="line">pInt: <span class="number">1</span></span><br><span class="line">pInt引用计数: <span class="number">1</span></span><br><span class="line">pInt引用计数: <span class="number">2</span></span><br><span class="line">pInt2引用计数: <span class="number">2</span></span><br><span class="line">Example Destructor...</span><br></pre></td></tr></table></figure>
<p>从上面这段代码中，我们对shared_ptr指针有了一些直观的了解。一方面，跟STL中大多数容器类型一样，shared_ptr也是模板类，因此在创建shared_ptr时需要指定其指向的类型。另一方面，正如其名一样，shared_ptr指针允许让多个该类型的指针共享同一堆分配对象。同时shared_ptr使用经典的“引用计数”方法来管理对象资源，每个shared_ptr对象关联一个共享的引用计数。</p>
<p>对于shared_ptr在拷贝和赋值时的行为，《C++Primer第五版》中有详细的描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个shared_ptr都有一个关联的计数值，通常称为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。</span><br><span class="line"></span><br><span class="line">例如，当用一个shared_ptr初始化另一个shred_ptr，或将它当做参数传递给一</span><br><span class="line">个函数以及作为函数的返回值时，它所关联的计数器就会递增。</span><br><span class="line"></span><br><span class="line">当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的</span><br><span class="line">shared_ptr离开其作用域）时，计数器就会递减。一旦一个shared_ptr的计数</span><br><span class="line">器变为0，它就会自动释放自己所管理的对象。</span><br></pre></td></tr></table></figure>

<p>对比我们上面的代码可以看到：当我们将一个指向Example对象的指针交给pInt管理后，其关联的引用计数为1。接下来，我们用pInt初始化pInt2，两者关联的引用计数值增加为2。随后，函数结束，pInt和PInt2相继离开函数作用于，相应的引用计数值分别自减1最后变为0，于是Example对象被自动释放（调用其析构函数）。</p>
<h3 id="shared-ptr的常见用法"><a href="#shared-ptr的常见用法" class="headerlink" title="shared_ptr的常见用法"></a>shared_ptr的常见用法</h3><h4 id="1、创建shared-ptr实例"><a href="#1、创建shared-ptr实例" class="headerlink" title="1、创建shared_ptr实例"></a>1、创建shared_ptr实例</h4><p>最安全和高效的方法是调用make_shared库函数，该函数会在堆中分配一个对象并初始化，最后返回指向此对象的share_ptr实例。如果你不想使用make_ptr，也可以先明确new出一个对象，然后把其原始指针传递给share_ptr的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递给make_shared函数的参数必须和shared_ptr所指向类型的某个构造函数相匹配</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pStr = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pStr &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//  aaaaaaaaaa</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pInt</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pInt &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、访问所指对象"><a href="#2、访问所指对象" class="headerlink" title="2、访问所指对象"></a>2、访问所指对象</h4><p>shared_ptr的使用方式与普通指针的使用方式类似，既可以使用解引用操作符*获得原始对象进而访问其各个成员，也可以使用指针访问符-&gt;来访问原始对象的各个成员。</p>
<h4 id="3、拷贝和赋值操作"><a href="#3、拷贝和赋值操作" class="headerlink" title="3、拷贝和赋值操作"></a>3、拷贝和赋值操作</h4><p>我们可以用一个shared_ptr对象来初始化另一个share_ptr实例，该操作会增加其引用计数值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pStr = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//  1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pStr2</span><span class="params">(pStr)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//  2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr2.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//  2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果shared_ptr实例p和另一个shared_ptr实例q所指向的类型相同或者可以相互转换，我们还可以进行诸如p = q这样赋值操作。该操作会递减p的引用计数值，递增q的引用计数值。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Example(<span class="built_in">string</span> n) : name(n) &#123; <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~Example() &#123; <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Example&gt; pStr = make_shared&lt;Example&gt;(<span class="string">"a object"</span>);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Example&gt; pStr2 = make_shared&lt;Example&gt;(<span class="string">"b object"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    pStr = pStr2;   <span class="comment">// 此后pStr和pStr指向相同对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr2-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a object constructor...</span><br><span class="line">b object constructor...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">a object destructor...</span><br><span class="line">b object</span><br><span class="line">b object</span><br><span class="line">b object destructor...</span><br></pre></td></tr></table></figure>

<h4 id="4、检查引用计数"><a href="#4、检查引用计数" class="headerlink" title="4、检查引用计数"></a>4、检查引用计数</h4><p>shared_ptr提供了两个函数来检查其共享的引用计数值，分别是unique()和use_count()。</p>
<p>在前面，我们已经多次使用过use_count()函数，该函数返回当前指针的引用计数值。值得注意的是use_count()函数可能效率很低，应该只把它用于测试或调试。</p>
<p>unique()函数用来测试该shared_ptr是否是原始指针唯一拥有者，也就是use_count()的返回值为1时返回true，否则返回false。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pStr = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr.unique() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pStr2</span><span class="params">(pStr)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr2.unique() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// false;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="weak-ptr介绍"><a href="#weak-ptr介绍" class="headerlink" title="weak_ptr介绍"></a>weak_ptr介绍</h2><p>在正式介绍weak_ptr之前，我们先来回忆一下shared_ptr的一些知识。我们知道shared_ptr是采用引用计数的智能指针，多个shared_ptr实例可以指向同一个动态对象，并维护了一个共享的引用计数器。对于引用计数法实现的计数，总是避免不了循环引用（或环形引用）的问题，shared_ptr也不例外。</p>
<p>我们先来看看下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassB&gt; pb;  <span class="comment">// 在A中引用B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassA&gt; pa;  <span class="comment">// 在B中引用A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassA&gt; spa = make_shared&lt;ClassA&gt;();</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassB&gt; spb = make_shared&lt;ClassB&gt;();</span><br><span class="line">    spa-&gt;pb = spb;</span><br><span class="line">    spb-&gt;pa = spa;</span><br><span class="line">    <span class="comment">// 函数结束，思考一下：spa和spb会释放资源么？</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClassA Constructor...</span><br><span class="line">ClassB Constructor...</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>从上面代码中，ClassA和ClassB间存在着循环引用，从运行结果中我们可以看到：当main函数运行结束后，spa和spb管理的动态资源并没有得到释放，产生了内存泄漏。</p>
<p>为了解决类似这样的问题，C++11引入了weak_ptr，来打破这种循环引用。</p>
<p>weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。</p>
<h3 id="weak-ptr用法"><a href="#weak-ptr用法" class="headerlink" title="weak_ptr用法"></a>weak_ptr用法</h3><h4 id="1、创建weak-ptr实例"><a href="#1、创建weak-ptr实例" class="headerlink" title="1、创建weak_ptr实例"></a>1、创建weak_ptr实例</h4><p>当我们创建一个weak_ptr时，需要用一个shared_ptr实例来初始化weak_ptr，由于是弱共享，weak_ptr的创建并不会影响shared_ptr的引用计数值。</p>
<p>示例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建前sp的引用计数："</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// use_count = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建后sp的引用计数："</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// use_count = 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、判断weak-ptr指向对象是否存在"><a href="#2、判断weak-ptr指向对象是否存在" class="headerlink" title="2、判断weak_ptr指向对象是否存在"></a>2、判断weak_ptr指向对象是否存在</h4><p>既然weak_ptr并不改变其所共享的shared_ptr实例的引用计数，那就可能存在weak_ptr指向的对象被释放掉这种情况。这时，我们就不能使用weak_ptr直接访问对象。那么我们如何判断weak_ptr指向对象是否存在呢？C++中提供了lock函数来实现该功能。如果对象存在，lock()函数返回一个指向共享对象的shared_ptr，否则返回一个空shared_ptr。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : a(<span class="number">3</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;A&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="comment">//sp.reset();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">shared_ptr</span>&lt;A&gt; pa = wp.lock())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pa-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"wp指向对象为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把sp.reset()这行的注释去掉会导致wp指向对象为空。</p>
<p>weak_ptr还提供了expired()函数来判断所指对象是否已经被销毁。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : a(<span class="number">3</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;A&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    sp.reset(); <span class="comment">// 此时sp被销毁</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; wp.expired() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// true表示已被销毁，否则为false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A Constructor...</span><br><span class="line">A Destructor...</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="3、具体使用weak-ptr"><a href="#3、具体使用weak-ptr" class="headerlink" title="3、具体使用weak_ptr"></a>3、具体使用weak_ptr</h4><p>weak_ptr并没有重载operator-&gt;和operator *操作符，因此不可直接通过weak_ptr使用对象，典型的用法是调用其lock函数来获得shared_ptr示例，进而访问原始对象.</p>
<p>下面使用weak_ptr来改造最前面的代码，打破循环引用问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    weak_ptr&lt;ClassB&gt; pb;  <span class="comment">// 在A中引用B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    weak_ptr&lt;ClassA&gt; pa;  <span class="comment">// 在B中引用A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassA&gt; spa = make_shared&lt;ClassA&gt;();</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ClassB&gt; spb = make_shared&lt;ClassB&gt;();</span><br><span class="line">    spa-&gt;pb = spb;</span><br><span class="line">    spb-&gt;pa = spa;</span><br><span class="line">    <span class="comment">// 函数结束，思考一下：spa和spb会释放资源么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从运行结果可以看到spa和spb指向的对象都得到释放。</p>
<h2 id="unique-ptr介绍"><a href="#unique-ptr介绍" class="headerlink" title="unique_ptr介绍"></a>unique_ptr介绍</h2><p>unique是独特的、唯一的意思，故名思议，unique_ptr可以“独占”地拥有它所指向的对象，它提供一种严格意义上的所有权。这一点和我们前面介绍的shared_ptr类型指针有很大的不同：shared_ptr允许多个指针指向同一对象，而unique_ptr在某一时刻只能有一个指针指向该对象。unique_ptr保存指向某个对象的指针，当它本身被删除或者离开其作用域时会自动释放其指向对象所占用的资源。</p>
<p>下图演示了两个 unique_ptr 实例之间的所有权转换。</p>
<p><img src="/2020/04/01/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/unique_ptr.png" alt></p>
<h3 id="unique-ptr的基本特性"><a href="#unique-ptr的基本特性" class="headerlink" title="unique_ptr的基本特性"></a>unique_ptr的基本特性</h3><h4 id="1、创建unique-ptr"><a href="#1、创建unique-ptr" class="headerlink" title="1、创建unique_ptr"></a>1、创建unique_ptr</h4><p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个unique_ptr实例</span></span><br><span class="line">    <span class="comment">// unique_ptr&lt;int&gt; pInt(new int(5));</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、无法进行复制构造和赋值操作"><a href="#2、无法进行复制构造和赋值操作" class="headerlink" title="2、无法进行复制构造和赋值操作"></a>2、无法进行复制构造和赋值操作</h4><p>unique_ptr没有copy构造函数，不支持普通的拷贝和赋值操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个unique_ptr实例</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pInt2</span><span class="params">(pInt)</span></span>;    <span class="comment">// 报错</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt3 = pInt;   <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、可以进行移动构造和移动赋值操作"><a href="#3、可以进行移动构造和移动赋值操作" class="headerlink" title="3、可以进行移动构造和移动赋值操作"></a>3、可以进行移动构造和移动赋值操作</h4><p>unique_ptr虽然没有支持普通的拷贝和赋值操作，但却提供了一种移动机制来将指针的所有权从一个unique_ptr转移给另一个unique_ptr。如果需要转移所有权，可以使用std::move()函数。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt2 = <span class="built_in">std</span>::<span class="built_in">move</span>(pInt);    <span class="comment">// 转移所有权</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *pInt &lt;&lt; endl; // 出错，pInt为空</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pInt2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pInt3</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(pInt2))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、可以返回unique-ptr"><a href="#4、可以返回unique-ptr" class="headerlink" title="4、可以返回unique_ptr"></a>4、可以返回unique_ptr</h4><p>unique_ptr不支持拷贝操作，但却有一个例外：可以从函数中返回一个unique_ptr。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> pInt;    <span class="comment">// 返回unique_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ret = clone(p);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr使用场景"><a href="#unique-ptr使用场景" class="headerlink" title="unique_ptr使用场景"></a>unique_ptr使用场景</h3><h4 id="1、为动态申请的资源提供异常安全保证"><a href="#1、为动态申请的资源提供异常安全保证" class="headerlink" title="1、为动态申请的资源提供异常安全保证"></a>1、为动态申请的资源提供异常安全保证</h4><p>我们先来看看下面这一段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（可能会抛出异常）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是我们传统的写法：当我们动态申请内存后，有可能我们接下来的代码由于抛出异常或者提前退出（if语句）而没有执行delete操作。</p>
<p>解决的方法是使用unique_ptr来管理动态内存，只要unique_ptr指针创建成功，其析构函数都会被调用。确保动态资源被释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（可能会抛出异常）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、返回函数内动态申请资源的所有权"><a href="#2、返回函数内动态申请资源的所有权" class="headerlink" title="2、返回函数内动态申请资源的所有权"></a>2、返回函数内动态申请资源的所有权</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Func</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_unique&lt;<span class="keyword">int</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> pInt;    <span class="comment">// 返回unique_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ret = Func(p);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 函数结束后，自动释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、在容器中保存指针"><a href="#3、在容器中保存指针" class="headerlink" title="3、在容器中保存指针"></a>3、在容器中保存指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; p= make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    vec.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(p));    <span class="comment">// 使用移动语义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、管理动态数组"><a href="#4、管理动态数组" class="headerlink" title="4、管理动态数组"></a>4、管理动态数组</h4><p>标准库提供了一个可以管理动态数组的unique_ptr版本。</p>
<p>可以使用make_unique来创建一个到数组的 unique_ptr，但不能使用 make_unique 来初始化数组元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// unique_ptr&lt;int[]&gt; p(new int[5] &#123;1, 2, 3, 4, 5&#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a unique_ptr to an array of 5 integers.</span></span><br><span class="line">    <span class="keyword">auto</span> p = make_unique&lt;<span class="keyword">int</span>[]&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the array.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        wcout &lt;&lt; p[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">// 重载了operator[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、作为auto-ptr的替代品"><a href="#5、作为auto-ptr的替代品" class="headerlink" title="5、作为auto_ptr的替代品"></a>5、作为auto_ptr的替代品</h4>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>语音识别</title>
    <url>/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>整个语音识别系统主要构成有四个部分：语音信号处理和特征的提取模块；语音识别的声学模型；语音识别的语言模型；语音识别的解码和搜索部分。系统流程图如下图所示：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/1.png" alt></p>
<a id="more"></a>
<p>整个语音识别的过程可以用贝叶斯理论来描述，假设输入的音频序列为$O={o_{1}, o_{2}, \cdots, o_{n}}$，输出为文本序列为$W={w_{1}, w_{2}, \cdots, w_{n}}$。目的是构建一个模型，使得$\prod_{n} P\left(W_{n} | O_{n}\right)$最大，也就是训练集中n个样本的后验概率最大。单独拿出一个样本的后验概率使用贝叶斯公式可以得到：</p>
<p>$$P(W | O)=\frac{P(O | W) * P(W)}{P(O)}$$</p>
<p>进一步可得:</p>
<p>$$W^{*}=\operatorname{argmax}_{W} P(O | W) * P(W)$$</p>
<p>这里$P(W)$是输出词序列的概率，用语言模型来刻画，$P(O | W)$为似然概率，使用声学模型来表达。</p>
<h3 id="数据集构建"><a href="#数据集构建" class="headerlink" title="数据集构建"></a>数据集构建</h3><p>语音数据构建主要分为两种，一是公开数据集—&gt;日常对话，二是特定数据集—&gt;控制命令。</p>
<p>所搜集的公开语音数据集是<a href="http://www.openslr.org/18/" target="_blank" rel="noopener external nofollow noreferrer">THCHS30</a>、<a href="http://cn-mirror.openslr.org/resources/38/ST-CMDS-20170001_1-OS.tar.gz" target="_blank" rel="noopener external nofollow noreferrer">ST-CMDS</a>、<a href="http://cn-mirror.openslr.org/resources/33/data_aishell.tgz" target="_blank" rel="noopener external nofollow noreferrer">AIShell</a>等数据集，这几个数据集是中文语音数据集，基本数据格式如下图所示:</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/2.png" alt></p>
<p>基本信息如下：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/3.png" alt></p>
<p>针对实际的工业控制命令，我们进行专门的语音采集和录制。环境是和实际的泵站控制室一致，安静、近场。这里使用单粒麦克风进行录制，录制的格式与上边格式一致。</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/4.png" alt></p>
<h3 id="语音信号预处理"><a href="#语音信号预处理" class="headerlink" title="语音信号预处理"></a>语音信号预处理</h3><p>语音信号预处理是为了将原始语音信号转换成CNN网络输入的语谱图。CNN的输入层是200维的特征值序列。输出拼音的表示大小是1422，即1421个拼音+1个空白块。预测结果是返回语音识别后的拼音符号列表。</p>
<p>语音信号的预处理过程用到的技术是：预加重（pre-emphasis）、<br>分帧（enframing）、加窗（windowing)</p>
<h4 id="预加重"><a href="#预加重" class="headerlink" title="预加重"></a>预加重</h4><p>预加重可以使得语音信号的频谱信号分布更加均衡。预加重一般是用<br>60db/octave数字滤波器频率特性完成的。过滤器公式给出：</p>
<p>$$H(z)=1-u z^{-1}$$</p>
<p>其中$u$是预加重系数。</p>
<h4 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a>分帧</h4><p>使用预先设计好的窗函数处理被分帧分成的多个小片段。通过这种方法在一定程度上解决语音信号帧信号之间的不连续性问题。每一个小段作为语音信的单位，称为帧（frame）。以帧为单位可以分析语音信号的短时特性，从而进一步进行频谱等处理。分帧一般相邻帧之间有交叉重叠，交叉部分叫做帧移，帧移一般定为帧长度的一半。</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/5.png" alt></p>
<h4 id="加窗"><a href="#加窗" class="headerlink" title="加窗"></a>加窗</h4><p>对语音信号增加一个窗函数（Window Function），在语音信号的给定区间内限定为一个实数，其它部分为0。使用的是汉明窗（Hamming Window）汉明窗的时间域表达给出:</p>
<p>$$w(n)=0.54-0.46 \cos \left(\frac{2 \pi n}{N-1}\right)$$</p>
<p>其中$𝑛$是时间，$w(n)$是窗函数。</p>
<h4 id="语谱图特征提取"><a href="#语谱图特征提取" class="headerlink" title="语谱图特征提取"></a>语谱图特征提取</h4><p>语谱图（Spectrogram）是语音处理的一个重要特征，是一种描述语音信号的各个频率成分随着时间变换的热力图。</p>
<p>语谱图包含着语音信号的重要信息，用一个二维矩阵表示。其中一个轴表示时间，另外一个轴表示频率。不同的点或者颜色代表对应语音信号能量的大小。</p>
<p>语谱图的提取过程一般包括：采样、傅立叶变换、连续拼接。如下图所示：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/6.jpg" alt></p>
<p>原始语音信号是符合数据格式的后缀是.wav 的原始语音数据。这里定义一个函数，读取该原始语音数据，返回声音信号的时域谱矩阵和帧速率。具体函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">一些通用函数，如wav文件读取、信号出来和测试代码</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> python_speech_features <span class="keyword">import</span> mfcc</span><br><span class="line"><span class="keyword">from</span> python_speech_features <span class="keyword">import</span> delta</span><br><span class="line"><span class="keyword">from</span> python_speech_features <span class="keyword">import</span> logfbank</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_wav_data</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	读取一个wav文件，返回声音信号的时域谱矩阵和播放时间</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	wav = wave.open(filename,<span class="string">"rb"</span>) <span class="comment"># 打开一个wav格式的声音文件流</span></span><br><span class="line">	num_frame = wav.getnframes() <span class="comment"># 获取帧数</span></span><br><span class="line">	num_channel=wav.getnchannels() <span class="comment"># 获取声道数</span></span><br><span class="line">	framerate=wav.getframerate() <span class="comment"># 获取帧速率</span></span><br><span class="line">	num_sample_width=wav.getsampwidth() <span class="comment"># 获取实例的比特宽度，即每一帧的字节数</span></span><br><span class="line">	str_data = wav.readframes(num_frame) <span class="comment"># 读取全部的帧</span></span><br><span class="line">	wav.close() <span class="comment"># 关闭流</span></span><br><span class="line">	wave_data = np.fromstring(str_data, dtype = np.short) <span class="comment"># 将声音文件数据转换为数组矩阵形式</span></span><br><span class="line">	wave_data.shape = <span class="number">-1</span>, num_channel <span class="comment"># 按照声道数将数组整形，单声道时候是一列数组，双声道时候是两列的矩阵</span></span><br><span class="line">	wave_data = wave_data.T <span class="comment"># 将矩阵转置</span></span><br><span class="line">	<span class="keyword">return</span> wave_data, framerate  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetMfccFeature</span><span class="params">(wavsignal, fs)</span>:</span></span><br><span class="line">	<span class="comment"># 获取输入特征</span></span><br><span class="line">	feat_mfcc=mfcc(wavsignal[<span class="number">0</span>],fs)</span><br><span class="line">	feat_mfcc_d=delta(feat_mfcc,<span class="number">2</span>)</span><br><span class="line">	feat_mfcc_dd=delta(feat_mfcc_d,<span class="number">2</span>)</span><br><span class="line">	<span class="comment"># 返回值分别是mfcc特征向量的矩阵及其一阶差分和二阶差分矩阵</span></span><br><span class="line">	wav_feature = np.column_stack((feat_mfcc, feat_mfcc_d, feat_mfcc_dd))</span><br><span class="line">	<span class="keyword">return</span> wav_feature</span><br><span class="line"></span><br><span class="line">x=np.linspace(<span class="number">0</span>, <span class="number">400</span> - <span class="number">1</span>, <span class="number">400</span>, dtype = np.int64)</span><br><span class="line">w = <span class="number">0.54</span> - <span class="number">0.46</span> * np.cos(<span class="number">2</span> * np.pi * (x) / (<span class="number">400</span> - <span class="number">1</span>) ) <span class="comment"># 汉明窗</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFrequencyFeature3</span><span class="params">(wavsignal, fs)</span>:</span></span><br><span class="line">	<span class="comment"># wav波形 加时间窗以及时移10ms</span></span><br><span class="line">	time_window = <span class="number">25</span> <span class="comment"># 单位ms</span></span><br><span class="line">	window_length = fs / <span class="number">1000</span> * time_window <span class="comment"># 计算窗长度的公式，目前全部为400固定值</span></span><br><span class="line">	</span><br><span class="line">	wav_arr = np.array(wavsignal)</span><br><span class="line">	<span class="comment">#wav_length = len(wavsignal[0])</span></span><br><span class="line">	wav_length = wav_arr.shape[<span class="number">1</span>]</span><br><span class="line">	</span><br><span class="line">	range0_end = int(len(wavsignal[<span class="number">0</span>])/fs*<span class="number">1000</span> - time_window) // <span class="number">10</span> <span class="comment"># 计算循环终止的位置，也就是最终生成的窗数</span></span><br><span class="line">	data_input = np.zeros((range0_end, <span class="number">200</span>), dtype = np.float) <span class="comment"># 用于存放最终的频率特征数据</span></span><br><span class="line">	data_line = np.zeros((<span class="number">1</span>, <span class="number">400</span>), dtype = np.float)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, range0_end):</span><br><span class="line">		p_start = i * <span class="number">160</span></span><br><span class="line">		p_end = p_start + <span class="number">400</span></span><br><span class="line">		</span><br><span class="line">		data_line = wav_arr[<span class="number">0</span>, p_start:p_end]</span><br><span class="line">		</span><br><span class="line">		data_line = data_line * w <span class="comment"># 加窗</span></span><br><span class="line">		</span><br><span class="line">		data_line = np.abs(fft(data_line)) / wav_length</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		data_input[i]=data_line[<span class="number">0</span>:<span class="number">200</span>] <span class="comment"># 设置为400除以2的值（即200）是取一半数据，因为是对称的</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">#print(data_input.shape)</span></span><br><span class="line">	data_input = np.log(data_input + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> data_input</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wav_scale</span><span class="params">(energy)</span>:</span></span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	语音信号能量归一化</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	means = energy.mean() <span class="comment"># 均值</span></span><br><span class="line">	var=energy.var() <span class="comment"># 方差</span></span><br><span class="line">	e=(energy-means)/math.sqrt(var) <span class="comment"># 归一化能量</span></span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wav_show</span><span class="params">(wave_data, fs)</span>:</span> <span class="comment"># 显示出来声音波形</span></span><br><span class="line">	time = np.arange(<span class="number">0</span>, len(wave_data)) * (<span class="number">1.0</span>/fs)  <span class="comment"># 计算声音的播放时间，单位为秒</span></span><br><span class="line">	<span class="comment"># 画声音波形</span></span><br><span class="line">	<span class="comment">#plt.subplot(211)  </span></span><br><span class="line">	plt.plot(time, wave_data)  </span><br><span class="line">	<span class="comment">#plt.subplot(212)  </span></span><br><span class="line">	<span class="comment">#plt.plot(time, wave_data[1], c = "g")  </span></span><br><span class="line">	plt.show()  </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_wav_list</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	读取一个wav文件列表，返回一个存储该列表的字典类型值</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	txt_obj=open(filename,<span class="string">'r'</span>) <span class="comment"># 打开文件并读入</span></span><br><span class="line">	txt_text=txt_obj.read()</span><br><span class="line">	txt_lines=txt_text.split(<span class="string">'\n'</span>) <span class="comment"># 文本分割</span></span><br><span class="line">	dic_filelist=&#123;&#125; <span class="comment"># 初始化字典</span></span><br><span class="line">	list_wavmark=[] <span class="comment"># 初始化wav列表</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> txt_lines:</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="string">''</span>):</span><br><span class="line">			txt_l=i.split(<span class="string">' '</span>)</span><br><span class="line">			dic_filelist[txt_l[<span class="number">0</span>]] = txt_l[<span class="number">1</span>]</span><br><span class="line">			list_wavmark.append(txt_l[<span class="number">0</span>])</span><br><span class="line">	txt_obj.close()</span><br><span class="line">	<span class="keyword">return</span> dic_filelist,list_wavmark</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_wav_symbol</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	读取指定数据集中，所有wav文件对应的语音符号</span></span><br><span class="line"><span class="string">	返回一个存储符号集的字典类型值</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	txt_obj=open(filename,<span class="string">'r'</span>) <span class="comment"># 打开文件并读入</span></span><br><span class="line">	txt_text=txt_obj.read()</span><br><span class="line">	txt_lines=txt_text.split(<span class="string">'\n'</span>) <span class="comment"># 文本分割</span></span><br><span class="line">	dic_symbol_list=&#123;&#125; <span class="comment"># 初始化字典</span></span><br><span class="line">	list_symbolmark=[] <span class="comment"># 初始化symbol列表</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> txt_lines:</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="string">''</span>):</span><br><span class="line">			txt_l=i.split(<span class="string">' '</span>)</span><br><span class="line">			dic_symbol_list[txt_l[<span class="number">0</span>]]=txt_l[<span class="number">1</span>:]</span><br><span class="line">			list_symbolmark.append(txt_l[<span class="number">0</span>])</span><br><span class="line">	txt_obj.close()</span><br><span class="line">	<span class="keyword">return</span> dic_symbol_list,list_symbolmark</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span>(__name__==<span class="string">'__main__'</span>):</span><br><span class="line">	</span><br><span class="line">	wave_data, fs = read_wav_data(<span class="string">"A2_0.wav"</span>)  </span><br><span class="line">	</span><br><span class="line">	wav_show(wave_data[<span class="number">0</span>],fs)</span><br><span class="line">	t0=time.time()</span><br><span class="line">	freimg = GetFrequencyFeature(wave_data,fs)</span><br><span class="line">	t1=time.time()</span><br><span class="line">	print(<span class="string">'time cost:'</span>,t1-t0)</span><br><span class="line">	</span><br><span class="line">	freimg = freimg.T</span><br><span class="line">	plt.subplot(<span class="number">111</span>)</span><br><span class="line">	</span><br><span class="line">	plt.imshow(freimg)</span><br><span class="line">	plt.colorbar(cax=<span class="literal">None</span>,ax=<span class="literal">None</span>,shrink=<span class="number">0.5</span>)  </span><br><span class="line">	 </span><br><span class="line">	plt.show()</span><br></pre></td></tr></table></figure>

<p>原始语音信号经过处理后得到帧数、声道数、帧速率。然后读取全部帧数，再经过变换后转换成数组矩阵格式，该数组按照声道数进行数组整形，整形后数组转置得到时域谱矩阵，得到帧速率和时域谱矩阵。在得到帧速率和时域谱矩阵后，经过加窗、采样后、傅里叶变换，以及最后的连续拼接。流程图如下：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/7.png" alt></p>
<p>下图是采用上述代码对中文语音数据提取的波形图和语谱图的结果。波形图的横轴是时间，纵轴可以理解为位移或者压强。语谱图的横轴是拼接的时间，纵轴是频率。</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/8.png" alt></p>
<h3 id="声学模型设计训练"><a href="#声学模型设计训练" class="headerlink" title="声学模型设计训练"></a>声学模型设计训练</h3><p>声学模型输⼊入是语谱图，输出是拼音。如下图所示：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/9.png" alt></p>
<p>声学模型设计主要基于DFCNN网络进行训练，主要设计的结构和相应的参数设置如下：</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/10.png" alt></p>
<p>参数设置：</p>
<p>Adam 的参数:<br>(lr = 0.01, beta_1 = 0.9,beta_2 = 0.999, decay = 0.0, epsilon = 10e-8)</p>
<p><img src="/2020/04/01/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/11.png" alt></p>
<p>CTC是一种针对序列列深度模型的损失函数。相⽐比传统交叉熵损失函数能⾃自动对⻬齐序列列标签，端到端训练模型。具体参考<a href="https://blog.ailemon.me/2019/07/18/sequence-modeling-with-ctc/" target="_blank" rel="noopener external nofollow noreferrer">这里</a></p>
<p>使用Keras搭建序贯(Sequential)模型，部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">声学模型</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> platform <span class="keyword">as</span> plat</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> general_function.file_wav <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> general_function.file_dict <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> general_function.gen_func <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> general_function.muti_gpu <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> multi_gpu_model,plot_model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> keras <span class="keyword">as</span> kr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential, Model</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Input, Reshape, BatchNormalization <span class="comment"># , Flatten</span></span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Lambda, TimeDistributed, Activation,Conv2D, MaxPooling2D <span class="comment">#, Merge</span></span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD, Adadelta, Adam, RMSprop</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ReadData <span class="keyword">import</span> DataSpeech</span><br><span class="line"></span><br><span class="line">abspath = <span class="string">''</span></span><br><span class="line">ModelName=<span class="string">'_dfcnn'</span></span><br><span class="line"><span class="comment">#NUM_GPU = 2</span></span><br><span class="line">base_count=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelSpeech</span><span class="params">()</span>:</span> <span class="comment"># 语音模型类</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, datapath)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		初始化</span></span><br><span class="line"><span class="string">		默认输出的拼音的表示大小是1434，即1433个拼音+1个空白块</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		MS_OUTPUT_SIZE = <span class="number">1434</span></span><br><span class="line">		self.MS_OUTPUT_SIZE = MS_OUTPUT_SIZE <span class="comment"># 神经网络最终输出的每一个字符向量维度的大小</span></span><br><span class="line">		<span class="comment">#self.BATCH_SIZE = BATCH_SIZE # 一次训练的batch</span></span><br><span class="line">		self.label_max_string_length = <span class="number">64</span></span><br><span class="line">		self.AUDIO_LENGTH = <span class="number">1600</span>  <span class="comment">## 16s</span></span><br><span class="line">		self.AUDIO_FEATURE_LENGTH = <span class="number">200</span></span><br><span class="line">		self._model, self.base_model = self.CreateModel() </span><br><span class="line">		</span><br><span class="line">		self.datapath = datapath</span><br><span class="line">		self.slash = <span class="string">''</span></span><br><span class="line">		system_type = plat.system() <span class="comment"># 由于不同的系统的文件路径表示不一样，需要进行判断</span></span><br><span class="line">		<span class="keyword">if</span>(system_type == <span class="string">'Windows'</span>):</span><br><span class="line">			self.slash=<span class="string">'\\'</span> <span class="comment"># 反斜杠</span></span><br><span class="line">		<span class="keyword">elif</span>(system_type == <span class="string">'Linux'</span>):</span><br><span class="line">			self.slash=<span class="string">'/'</span> <span class="comment"># 正斜杠</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			print(<span class="string">'*[Message] Unknown System\n'</span>)</span><br><span class="line">			self.slash=<span class="string">'/'</span> <span class="comment"># 正斜杠</span></span><br><span class="line">		<span class="keyword">if</span>(self.slash != self.datapath[<span class="number">-1</span>]): <span class="comment"># 在目录路径末尾增加斜杠</span></span><br><span class="line">			self.datapath = self.datapath + self.slash</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">CreateModel</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		定义DFCNN模型，使用函数式模型  </span></span><br><span class="line"><span class="string">		输入层：200维的特征值序列，一条语音数据的最大长度设为1600（大约16s）</span></span><br><span class="line"><span class="string">		隐藏层：卷积池化层，卷积核大小为3x3，池化窗口大小为2</span></span><br><span class="line"><span class="string">		隐藏层：全连接层</span></span><br><span class="line"><span class="string">		输出层：全连接层，神经元数量为self.MS_OUTPUT_SIZE，使用softmax作为激活函数，</span></span><br><span class="line"><span class="string">		CTC层：使用CTC的loss作为损失函数，实现连接性时序多输出</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		</span><br><span class="line">		input_data = Input(name=<span class="string">'the_input'</span>, shape=(self.AUDIO_LENGTH, self.AUDIO_FEATURE_LENGTH, <span class="number">1</span>))</span><br><span class="line">		</span><br><span class="line">		layer_h1 = Conv2D(<span class="number">32</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">False</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(input_data) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h1 = BatchNormalization(mode=<span class="number">0</span>,axis=<span class="number">-1</span>)(layer_h1)</span><br><span class="line">		layer_h2 = Conv2D(<span class="number">32</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h1) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h2 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h2)</span><br><span class="line">		layer_h3 = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h2) <span class="comment"># 池化层 800*100</span></span><br><span class="line">		layer_h4 = Conv2D(<span class="number">64</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h3) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h4 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h4)</span><br><span class="line">		layer_h5 = Conv2D(<span class="number">64</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h4) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h5 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h5)</span><br><span class="line">		layer_h6 = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h5) <span class="comment"># 池化层 400*50</span></span><br><span class="line">		layer_h7 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h6) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h7 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h7)</span><br><span class="line">		layer_h8 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h7) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h8 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h8)</span><br><span class="line">		layer_h9 = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h8) <span class="comment"># 池化层 200*25</span></span><br><span class="line">		layer_h10 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h9) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h10 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h10)</span><br><span class="line">		layer_h11 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h10) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h11 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h11)</span><br><span class="line">		layer_h12 = MaxPooling2D(pool_size=<span class="number">1</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h11) <span class="comment"># 池化层 200*25</span></span><br><span class="line">		</span><br><span class="line">		layer_h13 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h12) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h13 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h13)</span><br><span class="line">		layer_h14 = Conv2D(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>), use_bias=<span class="literal">True</span>, activation=<span class="string">'relu'</span>, padding=<span class="string">'same'</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h13) <span class="comment"># 卷积层</span></span><br><span class="line">		layer_h14 = BatchNormalization(axis=<span class="number">-1</span>)(layer_h14)</span><br><span class="line">		layer_h15 = MaxPooling2D(pool_size=<span class="number">1</span>, strides=<span class="literal">None</span>, padding=<span class="string">"valid"</span>)(layer_h14) <span class="comment"># 池化层 None*200*25*128</span></span><br><span class="line">		</span><br><span class="line">		layer_h16 = Reshape((<span class="number">200</span>, <span class="number">3200</span>))(layer_h15)</span><br><span class="line">		layer_h17 = Dense(<span class="number">128</span>, activation=<span class="string">"relu"</span>, use_bias=<span class="literal">True</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h16) <span class="comment"># 全连接层</span></span><br><span class="line">		layer_h17 = BatchNormalization(axis=<span class="number">1</span>)(layer_h17)</span><br><span class="line">		layer_h18 = Dense(self.MS_OUTPUT_SIZE, use_bias=<span class="literal">True</span>, kernel_initializer=<span class="string">'he_normal'</span>)(layer_h17) <span class="comment"># 全连接层</span></span><br><span class="line">		layer_h18 = BatchNormalization(axis=<span class="number">1</span>)(layer_h18)</span><br><span class="line">		y_pred = Activation(<span class="string">'softmax'</span>, name=<span class="string">'Activation0'</span>)(layer_h18)</span><br><span class="line">		model_data = Model(inputs = input_data, outputs = y_pred)</span><br><span class="line">		model_data.summary()</span><br><span class="line">		</span><br><span class="line">		labels = Input(name=<span class="string">'the_labels'</span>, shape=[self.label_max_string_length], dtype=<span class="string">'float32'</span>)</span><br><span class="line">		input_length = Input(name=<span class="string">'input_length'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)</span><br><span class="line">		label_length = Input(name=<span class="string">'label_length'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)</span><br><span class="line">		<span class="comment"># Keras doesn't currently support loss funcs with extra parameters</span></span><br><span class="line">		<span class="comment"># so CTC loss is implemented in a lambda layer</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment"># CTC</span></span><br><span class="line">		loss_out = Lambda(self.ctc_lambda_func, output_shape=(<span class="number">1</span>,), name=<span class="string">'ctc'</span>)([y_pred, labels, input_length, label_length])</span><br><span class="line">		</span><br><span class="line">		model = Model(inputs=[input_data, labels, input_length, label_length], outputs=loss_out)</span><br><span class="line">		</span><br><span class="line">		opt = Adam(lr = <span class="number">0.001</span>, beta_1 = <span class="number">0.9</span>, beta_2 = <span class="number">0.999</span>, decay = <span class="number">0.0</span>, epsilon = <span class="number">10e-8</span>)</span><br><span class="line">		<span class="comment">#model.compile(loss=&#123;'ctc': lambda y_true, y_pred: y_pred&#125;, optimizer=sgd)</span></span><br><span class="line">		model.compile(loss=&#123;<span class="string">'ctc'</span>: <span class="keyword">lambda</span> y_true, y_pred: y_pred&#125;, optimizer = opt)</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># captures output of softmax so we can decode the output during visualization</span></span><br><span class="line">		test_func = K.function([input_data], [y_pred])</span><br><span class="line">		</span><br><span class="line">		print(<span class="string">'[*提示] 创建模型成功，模型编译成功'</span>)</span><br><span class="line">		<span class="keyword">return</span> model, model_data</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">ctc_lambda_func</span><span class="params">(self, args)</span>:</span></span><br><span class="line">		y_pred, labels, input_length, label_length = args</span><br><span class="line">		</span><br><span class="line">		y_pred = y_pred[:, :, :]</span><br><span class="line">		<span class="comment">#y_pred = y_pred[:, 2:, :]</span></span><br><span class="line">		<span class="keyword">return</span> K.ctc_batch_cost(labels, y_pred, input_length, label_length)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">TrainModel</span><span class="params">(self, datapath, epoch = <span class="number">2</span>, save_step = <span class="number">1000</span>, batch_size = <span class="number">32</span>, filename = abspath + <span class="string">'model_speech/m'</span> + ModelName + <span class="string">'/speech_model'</span>+ModelName)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		训练模型</span></span><br><span class="line"><span class="string">		参数：</span></span><br><span class="line"><span class="string">			datapath: 数据保存的路径</span></span><br><span class="line"><span class="string">			epoch: 迭代轮数</span></span><br><span class="line"><span class="string">			save_step: 每多少步保存一次模型</span></span><br><span class="line"><span class="string">			filename: 默认保存文件名，不含文件后缀名</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		data=DataSpeech(datapath, <span class="string">'train'</span>)</span><br><span class="line">		</span><br><span class="line">		num_data = data.GetDataNum() <span class="comment"># 获取数据的数量</span></span><br><span class="line">		</span><br><span class="line">		yielddatas = data.data_genetator(batch_size, self.AUDIO_LENGTH)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> epoch <span class="keyword">in</span> range(epoch): <span class="comment"># 迭代轮数</span></span><br><span class="line">			print(<span class="string">'[running] train epoch %d .'</span> % epoch)</span><br><span class="line">			n_step = <span class="number">0</span> <span class="comment"># 迭代数据数</span></span><br><span class="line">			<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">				<span class="keyword">try</span>:</span><br><span class="line">					print(<span class="string">'[message] epoch %d . Have train datas %d+'</span>%(epoch, n_step*save_step))</span><br><span class="line">					<span class="comment"># data_genetator是一个生成器函数</span></span><br><span class="line">					</span><br><span class="line">					<span class="comment">#self._model.fit_generator(yielddatas, save_step, nb_worker=2)</span></span><br><span class="line">					self._model.fit_generator(yielddatas, save_step)</span><br><span class="line">					n_step += <span class="number">1</span></span><br><span class="line">				<span class="keyword">except</span> StopIteration:</span><br><span class="line">					print(<span class="string">'[error] generator error. please check data format.'</span>)</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				</span><br><span class="line">				self.SaveModel(comment=<span class="string">'_e_'</span>+str(epoch)+<span class="string">'_step_'</span>+str(n_step * save_step))</span><br><span class="line">				self.TestModel(self.datapath, str_dataset=<span class="string">'train'</span>, data_count = <span class="number">4</span>)</span><br><span class="line">				self.TestModel(self.datapath, str_dataset=<span class="string">'dev'</span>, data_count = <span class="number">4</span>)</span><br><span class="line">				</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">LoadModel</span><span class="params">(self,filename = abspath + <span class="string">'model_speech/m'</span>+ModelName+<span class="string">'/speech_model'</span>+ModelName+<span class="string">'.model'</span>)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		加载模型参数</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		self._model.load_weights(filename)</span><br><span class="line">		self.base_model.load_weights(filename + <span class="string">'.base'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">SaveModel</span><span class="params">(self,filename = abspath + <span class="string">'model_speech/m'</span>+ModelName+<span class="string">'/speech_model'</span>+ModelName,comment=<span class="string">''</span>)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		保存模型参数</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		self._model.save_weights(filename + comment + <span class="string">'.model'</span>)</span><br><span class="line">		self.base_model.save_weights(filename + comment + <span class="string">'.model.base'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">TestModel</span><span class="params">(self, datapath=<span class="string">''</span>, str_dataset=<span class="string">'dev'</span>, data_count = <span class="number">32</span>,comment = <span class="string">''</span>, out_report = False, show_ratio = True, io_step_print = <span class="number">10</span>, io_step_file = <span class="number">10</span>)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		测试检验模型效果</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		io_step_print</span></span><br><span class="line"><span class="string">			为了减少测试时标准输出的io开销，可以通过调整这个参数来实现</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		io_step_file</span></span><br><span class="line"><span class="string">			为了减少测试时文件读写的io开销，可以通过调整这个参数来实现</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		data=DataSpeech(self.datapath, str_dataset)</span><br><span class="line">		<span class="comment">#data.LoadDataList(str_dataset) </span></span><br><span class="line">		num_data = data.GetDataNum() <span class="comment"># 获取数据的数量</span></span><br><span class="line">		<span class="keyword">if</span>(data_count &lt;= <span class="number">0</span> <span class="keyword">or</span> data_count &gt; num_data): <span class="comment"># 当data_count为小于等于0或者大于测试数据量的值时，则使用全部数据来测试</span></span><br><span class="line">			data_count = num_data</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			ran_num = random.randint(<span class="number">0</span>,num_data - <span class="number">1</span>) <span class="comment"># 获取一个随机数</span></span><br><span class="line">			</span><br><span class="line">			words_num = <span class="number">0</span></span><br><span class="line">			word_error_num = <span class="number">0</span></span><br><span class="line">			</span><br><span class="line">			nowtime = time.strftime(<span class="string">'%Y%m%d_%H%M%S'</span>,time.localtime(time.time()))</span><br><span class="line">			<span class="keyword">if</span>(out_report == <span class="literal">True</span>):</span><br><span class="line">				txt_obj = open(abspath+<span class="string">'Test_Report_'</span> + str_dataset + <span class="string">'_'</span> + nowtime + <span class="string">'.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="comment"># 打开文件并读入</span></span><br><span class="line">			</span><br><span class="line">			txt = <span class="string">'测试报告\n模型编号 '</span> + ModelName + <span class="string">'\n\n'</span></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> range(data_count):</span><br><span class="line">				data_input, data_labels = data.GetData((ran_num + i) % num_data)  <span class="comment"># 从随机数开始连续向后取一定数量数据</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment"># 数据格式出错处理 开始</span></span><br><span class="line">				<span class="comment"># 当输入的wav文件长度过长时自动跳过该文件，转而使用下一个wav文件来运行</span></span><br><span class="line">				num_bias = <span class="number">0</span></span><br><span class="line">				<span class="keyword">while</span>(data_input.shape[<span class="number">0</span>] &gt; self.AUDIO_LENGTH):</span><br><span class="line">					print(<span class="string">'*[Error]'</span>,<span class="string">'wave data lenghth of num'</span>,(ran_num + i) % num_data, <span class="string">'is too long.'</span>,<span class="string">'\n A Exception raise when test Speech Model.'</span>)</span><br><span class="line">					num_bias += <span class="number">1</span></span><br><span class="line">					data_input, data_labels = data.GetData((ran_num + i + num_bias) % num_data)  <span class="comment"># 从随机数开始连续向后取一定数量数据</span></span><br><span class="line">				<span class="comment"># 数据格式出错处理 结束</span></span><br><span class="line">				</span><br><span class="line">				pre = self.Predict(data_input, data_input.shape[<span class="number">0</span>] // <span class="number">8</span>)</span><br><span class="line">				</span><br><span class="line">				words_n = data_labels.shape[<span class="number">0</span>] <span class="comment"># 获取每个句子的字数</span></span><br><span class="line">				words_num += words_n <span class="comment"># 把句子的总字数加上</span></span><br><span class="line">				edit_distance = GetEditDistance(data_labels, pre) <span class="comment"># 获取编辑距离</span></span><br><span class="line">				<span class="keyword">if</span>(edit_distance &lt;= words_n): <span class="comment"># 当编辑距离小于等于句子字数时</span></span><br><span class="line">					word_error_num += edit_distance <span class="comment"># 使用编辑距离作为错误字数</span></span><br><span class="line">				<span class="keyword">else</span>: <span class="comment"># 否则肯定是增加了一堆乱七八糟的奇奇怪怪的字</span></span><br><span class="line">					word_error_num += words_n <span class="comment"># 就直接加句子本来的总字数就好了</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>((i % io_step_print == <span class="number">0</span> <span class="keyword">or</span> i == data_count - <span class="number">1</span>) <span class="keyword">and</span> show_ratio == <span class="literal">True</span>):</span><br><span class="line">					<span class="comment">#print('测试进度：',i,'/',data_count)</span></span><br><span class="line">					print(<span class="string">'Test Count: '</span>,i,<span class="string">'/'</span>,data_count)</span><br><span class="line">				</span><br><span class="line">				txt = <span class="string">''</span></span><br><span class="line">				<span class="keyword">if</span>(out_report == <span class="literal">True</span>):</span><br><span class="line">					<span class="comment"># if(i % io_step_file == 0 or i == data_count - 1):</span></span><br><span class="line">					<span class="comment"># 	txt_obj.write(txt)</span></span><br><span class="line">					<span class="comment"># 	txt = ''</span></span><br><span class="line">					txt += str(i) + <span class="string">'\n'</span></span><br><span class="line">					txt += <span class="string">'True:\t'</span> + str(data_labels) + <span class="string">'\n'</span></span><br><span class="line">					txt += <span class="string">'Pred:\t'</span> + str(pre) + <span class="string">'\n'</span></span><br><span class="line">					txt += <span class="string">'\n'</span></span><br><span class="line">					txt_obj.write(txt)</span><br><span class="line">				</span><br><span class="line">			print(<span class="string">'*[Test Result] Speech Recognition '</span> + str_dataset + <span class="string">' set word error ratio: '</span>, word_error_num / words_num * <span class="number">100</span>, <span class="string">'%'</span>)</span><br><span class="line">			<span class="keyword">if</span>(out_report == <span class="literal">True</span>):</span><br><span class="line">				txt += <span class="string">'*[测试结果] 语音识别 '</span> + str_dataset + <span class="string">' 集语音单字错误率： '</span> + str(word_error_num / words_num * <span class="number">100</span>) + <span class="string">' %'</span></span><br><span class="line">				txt_obj.write(txt)</span><br><span class="line">				txt = <span class="string">''</span></span><br><span class="line">				txt_obj.close()</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">except</span> StopIteration:</span><br><span class="line">			print(<span class="string">'[Error] Model Test Error. please check data format.'</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">Predict</span><span class="params">(self, data_input, input_len)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		预测结果</span></span><br><span class="line"><span class="string">		返回语音识别后的拼音符号列表</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		</span><br><span class="line">		batch_size = <span class="number">1</span> </span><br><span class="line">		in_len = np.zeros((batch_size),dtype = np.int32)</span><br><span class="line">		</span><br><span class="line">		in_len[<span class="number">0</span>] = input_len</span><br><span class="line">		</span><br><span class="line">		x_in = np.zeros((batch_size, <span class="number">1600</span>, self.AUDIO_FEATURE_LENGTH, <span class="number">1</span>), dtype=np.float)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(batch_size):</span><br><span class="line">			x_in[i,<span class="number">0</span>:len(data_input)] = data_input</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		base_pred = self.base_model.predict(x = x_in)</span><br><span class="line">		</span><br><span class="line">		base_pred =base_pred[:, :, :]</span><br><span class="line">		</span><br><span class="line">		r = K.ctc_decode(base_pred, in_len, greedy = <span class="literal">True</span>, beam_width=<span class="number">100</span>, top_paths=<span class="number">1</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">#print('r', r)</span></span><br><span class="line">		</span><br><span class="line">		r1 = K.get_value(r[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">		<span class="comment">#print('r1', r1)</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">#r2 = K.get_value(r[1])</span></span><br><span class="line">		<span class="comment">#print(r2)</span></span><br><span class="line">		</span><br><span class="line">		r1=r1[<span class="number">0</span>]</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> r1</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">RecognizeSpeech</span><span class="params">(self, wavsignal, fs)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		最终做语音识别用的函数，识别一个wav序列的语音</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">#data = self.data</span></span><br><span class="line">		<span class="comment">#data = DataSpeech('E:\\语音数据集')</span></span><br><span class="line">		<span class="comment">#data.LoadDataList('dev')</span></span><br><span class="line">		<span class="comment"># 获取输入特征</span></span><br><span class="line">		<span class="comment">#data_input = GetMfccFeature(wavsignal, fs)</span></span><br><span class="line">		<span class="comment">#t0=time.time()</span></span><br><span class="line">		data_input = GetFrequencyFeature(wavsignal, fs)</span><br><span class="line">		<span class="comment">#t1=time.time()</span></span><br><span class="line">		<span class="comment">#print('time cost:',t1-t0)</span></span><br><span class="line">		</span><br><span class="line">		input_length = len(data_input)</span><br><span class="line">		input_length = input_length // <span class="number">8</span></span><br><span class="line">		</span><br><span class="line">		data_input = np.array(data_input, dtype = np.float)</span><br><span class="line">		<span class="comment">#print(data_input,data_input.shape)</span></span><br><span class="line">		data_input = data_input.reshape(data_input.shape[<span class="number">0</span>],data_input.shape[<span class="number">1</span>],<span class="number">1</span>)</span><br><span class="line">		<span class="comment">#t2=time.time()</span></span><br><span class="line">		r1 = self.Predict(data_input, input_length)</span><br><span class="line">		<span class="comment">#t3=time.time()</span></span><br><span class="line">		<span class="comment">#print('time cost:',t3-t2)</span></span><br><span class="line">		list_symbol_dic = GetSymbolList(self.datapath) <span class="comment"># 获取拼音列表</span></span><br><span class="line">		</span><br><span class="line">		r_str=[]</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> r1:</span><br><span class="line">			r_str.append(list_symbol_dic[i])</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> r_str</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">RecognizeSpeech_FromFile</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		最终做语音识别用的函数，识别指定文件名的语音</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		</span><br><span class="line">		wavsignal,fs = read_wav_data(filename)</span><br><span class="line">		</span><br><span class="line">		r = self.RecognizeSpeech(wavsignal, fs)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> r</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		返回keras model</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		<span class="keyword">return</span> self._model</span><br></pre></td></tr></table></figure>

<h3 id="语言模型设计训练"><a href="#语言模型设计训练" class="headerlink" title="语言模型设计训练"></a>语言模型设计训练</h3><h3 id="实验分析和软件设计"><a href="#实验分析和软件设计" class="headerlink" title="实验分析和软件设计"></a>实验分析和软件设计</h3>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>TPOT——一个自动化的Python机器学习工具</title>
    <url>/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="TPOT—一个自动化的Python机器学习工具"><a href="#TPOT—一个自动化的Python机器学习工具" class="headerlink" title="TPOT—一个自动化的Python机器学习工具"></a>TPOT—一个自动化的Python机器学习工具</h2><p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/1.png" alt></p>
<p>TPOT全称是基于树的pipeline优化工具(Tree-based Pipeline Optimization Tool)，这是一个非常棒Python自动机器学习工具，使用遗传编程优化机器学习pipeline。</p>
<a id="more"></a>

<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/2.png" alt></p>
<p>TPOT可以自动化许多东西，包括生命特性选择、模型选择、特性构建等等。如果你是Python机器学习者，很幸运，TPOT是构建在Scikit-learn之上的，所以它生成的所有代码看起来应该很熟悉。</p>
<p>它的作用是通过智能地探索数千种可能的pipeline来自动化机器学习中最繁琐的部分，找到最适合你的数据的pipeline，然后为你提供最佳的 Python 代码。</p>
<p>它的工作原理如下：</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/3.png" alt></p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><p>安装TPOT，可参考以下文档：<br><a href="http://epistasislab.github.io/tpot/installing/" target="_blank" rel="noopener external nofollow noreferrer">http://epistasislab.github.io/tpot/installing/</a></p>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h2><h3 id="2-1-TPOT代码"><a href="#2-1-TPOT代码" class="headerlink" title="2.1 TPOT代码"></a>2.1 TPOT代码</h3><p>TPOT的接口，与scikit-learn很类似。</p>
<p>TPOT可以像任何常规的Python模块一样导入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br></pre></td></tr></table></figure>
<p>然后创建一个TPOT实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer = TPOTClassifier()</span><br></pre></td></tr></table></figure>
<p>当然，TPOTRegressor（）也可以。</p>
<p>一些带有定制TPOT参数的示例代码可能如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, cv=<span class="number">5</span>, random_state=<span class="number">42</span>, verbosity=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>现在，可以利用fit函数来寻找最优的管道：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>fit函数初始化了遗传算法，以找到基于平均k倍交叉验证的最高评分管道，然后对整个提供的样本进行训练，TPOT实例可以作为一个合适的模型使用。</p>
<p>然后，可以使用score函数来评估测试集中的最终管道：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(pipeline_optimizer.score(X_test, y_test))</span><br></pre></td></tr></table></figure>
<p>最后，可以把TPOT将相应的Python代码导出到文本文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline_optimizer.export(<span class="string">'tpot_exported_pipeline.py'</span>)</span><br></pre></td></tr></table></figure>
<p>下面是一个完整的示例脚本，使用TPOT优化管道，对其进行评分，并将最好的管道导出到文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"> </span><br><span class="line">digits = load_digits()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"> </span><br><span class="line">pipeline_optimizer = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, cv=<span class="number">5</span>,random_state=<span class="number">42</span>, verbosity=<span class="number">2</span>)</span><br><span class="line">pipeline_optimizer.fit(X_train, y_train)</span><br><span class="line">print(pipeline_optimizer.score(X_test, y_test))</span><br><span class="line">pipeline_optimizer.export(<span class="string">'tpot_exported_pipeline.py'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-2-TPOT命令行"><a href="#2-2-TPOT命令行" class="headerlink" title="2.2 TPOT命令行"></a>2.2 TPOT命令行</h3><p>TPOT可以通过命令行导入使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tpot &#x2F;path_to&#x2F;data_file.csv</span><br></pre></td></tr></table></figure>
<p>命令行导入使用TPOT的示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tpot data&#x2F;mnist.csv -is , -target class -o tpot_exported_pipeline.py -g 5 -p 20 -cv 5 -s 42 -v 2</span><br></pre></td></tr></table></figure>
<h3 id="2-3-评估函数"><a href="#2-3-评估函数" class="headerlink" title="2.3 评估函数"></a>2.3 评估函数</h3><p>TPOT允许自定义评分函数，具体例子可以参考<a href="https://epistasislab.github.io/tpot/using/#scoring-functions" target="_blank" rel="noopener external nofollow noreferrer">Scoring Functions</a><br>##2.4 内置TPOT配置<br>TPOT提供了一些默认的操作符和参数配置，它可以很好地优化机器学习管道。下面是TPOT当前内置配置的<a href="https://epistasislab.github.io/tpot/using/#built-in-tpot-configurations" target="_blank" rel="noopener external nofollow noreferrer">列表</a>。它有4种：</p>
<ul>
<li>Default TPOT：默认的参数，在一些大数据集上可能需要较长时间。</li>
<li>TPOT light：与Default TPOT相比，使用了更简单、快速运行的操作符，因此TPOT light对于查找用于分类或回归问题的快速简单的管道非常有用。</li>
<li>TPOT MDR：专门用于全基因组关联研究（GWAS）</li>
<li>TPOT sparse：带有one-hot编码，且支持稀疏矩阵。<br>如果要使用这些配置只需将配置的字符串名称传递给config_dict 参数。示例代码如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">digits = load_digits()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">tpot = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, verbosity=<span class="number">2</span>,config_dict=<span class="string">'TPOT light'</span>)</span><br><span class="line">tpot.fit(X_train, y_train)</span><br><span class="line">print(tpot.score(X_test, y_test))</span><br><span class="line">tpot.export(<span class="string">'tpot_mnist_pipeline.py'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-5-定制TPOT的操作符和参数"><a href="#2-5-定制TPOT的操作符和参数" class="headerlink" title="2.5 定制TPOT的操作符和参数"></a>2.5 定制TPOT的操作符和参数</h3>除了TPOT所带来的默认配置之外，在某些情况下，限制TPOT所考虑的算法和参数是很有用的（用于减少寻优的时间等）。出于这个原因，TPOT允许用户为TPOT提供其操作符和参数的自定义配置。<br>自定义TPOT配置必须采用嵌套字典格式，举一个例子：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"> </span><br><span class="line">digits = load_digits()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"> </span><br><span class="line">tpot_config = &#123;</span><br><span class="line">    <span class="string">'sklearn.naive_bayes.GaussianNB'</span>: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    <span class="string">'sklearn.naive_bayes.BernoulliNB'</span>: &#123;</span><br><span class="line">        <span class="string">'alpha'</span>: [<span class="number">1e-3</span>, <span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1.</span>, <span class="number">10.</span>, <span class="number">100.</span>],</span><br><span class="line">        <span class="string">'fit_prior'</span>: [<span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    <span class="string">'sklearn.naive_bayes.MultinomialNB'</span>: &#123;</span><br><span class="line">        <span class="string">'alpha'</span>: [<span class="number">1e-3</span>, <span class="number">1e-2</span>, <span class="number">1e-1</span>, <span class="number">1.</span>, <span class="number">10.</span>, <span class="number">100.</span>],</span><br><span class="line">        <span class="string">'fit_prior'</span>: [<span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">tpot = TPOTClassifier(generations=<span class="number">5</span>, population_size=<span class="number">20</span>, verbosity=<span class="number">2</span>,</span><br><span class="line">                      config_dict=tpot_config)</span><br><span class="line">tpot.fit(X_train, y_train)</span><br><span class="line">print(tpot.score(X_test, y_test))</span><br><span class="line">tpot.export(<span class="string">'tpot_mnist_pipeline.py'</span>)</span><br></pre></td></tr></table></figure>
这样，TPOT寻找最优的pipeline，就只会在tpot_config中寻找了，无疑大大减少了时间复杂度，不过准确性可能会下降。<h3 id="2-6-Note"><a href="#2-6-Note" class="headerlink" title="2.6 Note"></a>2.6 Note</h3>搜索整个管道空间是特别耗时的。认识到原因是必要的，在默认的TPOT参数下（100 generations with 100 population size），TPOT将在完成前评估1万个管道配置。考虑一个网格搜索1万个超参数组合用于机器学习算法以及网格搜索需要多长时间。用10倍的交叉验证来评估这1万个模型，这意味着大约有10万个模型在一个网格搜索的训练数据中被匹配和评估。这是一个耗时的过程，即使对于像决策树这样的简单模型也是如此。</li>
</ul>
<p>典型的TPOT运行将需要数小时到数天才能完成（除非是一个小数据集），但是可以中断运行，并看到目前为止最好的结果。TPOT还提供warm_start参数，可以从中断的地方重新启动之前运行的TPOT。</p>
<h2 id="3-TPOT-API"><a href="#3-TPOT-API" class="headerlink" title="3. TPOT API"></a>3. TPOT API</h2><p>以TPOTRegressor为例，分类问题一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tpot</span>.<span class="title">TPOTRegressor</span><span class="params">(generations=<span class="number">100</span>, population_size=<span class="number">100</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">offspring_size=None, mutation_rate=<span class="number">0.9</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">crossover_rate=<span class="number">0.1</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">scoring=<span class="string">'neg_mean_squared_error'</span>, cv=<span class="number">5</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">subsample=<span class="number">1.0</span>, n_jobs=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">max_time_mins=None, max_eval_time_mins=<span class="number">5</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">random_state=None, config_dict=None,</span></span></span><br><span class="line"><span class="class"><span class="params">warm_start=False,</span></span></span><br><span class="line"><span class="class"><span class="params">memory=None,</span></span></span><br><span class="line"><span class="class"><span class="params">periodic_checkpoint_folder=None,</span></span></span><br><span class="line"><span class="class"><span class="params">early_stop=None,</span></span></span><br><span class="line"><span class="class"><span class="params">verbosity=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">disable_update_check=False)</span></span></span><br></pre></td></tr></table></figure>
<p>在默认情况下，TPOTRegressor将搜索广泛的监督的回归模型，包括预处理，特征选择，学习器和它们的超参数。当然，TPOTRegressor可以完全自己定制。</p>
<p>参数，属性和方法的详情可以参考<a href="https://epistasislab.github.io/tpot/api/#regression" target="_blank" rel="noopener external nofollow noreferrer">如下</a></p>
<p>下面列出主要的参数和方法：</p>
<p>参数：</p>
<ul>
<li>generations: int, optional (default=100)，运行管道优化过程的迭代次数。一定是正数,默认是100。一般来说，值越大，性能越好。</li>
</ul>
<p>TPOT将评估population_size+generations×offspring_size的规模。</p>
<ul>
<li><p>population_size: int, optional (default=100)，在每一代遗传中保留的个体数。一定是正数。一般来说，值越大，性能越好。</p>
</li>
<li><p>offspring_size: int, optional (default=100)，在每一次遗传过程中产生的后代数量。一定是正数。</p>
</li>
<li><p>mutation_rate: float, optional (default=0.9)，变异率，采用默认值即可。</p>
</li>
<li><p>crossover_rate: float, optional (default=0.1)，交叉率，采用默认值即可。</p>
</li>
<li><p>scoring: string or callable, optional (default=’neg_mean_squared_error’)，回归问题中用于评估给定管道的质量的函数。可以使用以下内置评分函数： ‘neg_median_absolute_error’, ‘neg_mean_absolute_error’, ‘neg_mean_squared_error’, ‘r2’</p>
</li>
<li><p>cv: int, cross-validation generator, or an iterable, optional (default=5)</p>
</li>
<li><p>subsample: float, optional (default=1.0)，在TPOT优化过程中使用的训练样本的比例。必须在0到1之间。</p>
</li>
<li><p>n_jobs: integer, optional (default=1)</p>
</li>
<li><p>max_time_mins: integer or None, optional (default=None)，TPOT需要多少分钟来优化管道。</p>
</li>
<li><p>max_eval_time_mins: integer, optional (default=5)，TPOT需要多少分钟来评估一个管道。</p>
</li>
<li><p>random_state: integer or None, optional (default=None)，使用这个参数来确保TPOT每次运行时都会有相同的结果。</p>
</li>
<li><p>config_dict: Python dictionary, string, or None, optional (default=None)，用于定制TPOT在优化过程中搜索的操作符和参数的配置字典。</p>
</li>
<li><p>warm_start: boolean, optional (default=False)，表明TPOT实例是否会重用以前调用fit（）的入口。</p>
</li>
<li><p>early_stop: integer, optional (default: None)</p>
</li>
<li><p>verbosity: integer, optional (default=0)，<br>0，TPOT将不会打印任何东西，<br>1，将打印很少的信息，<br>2，TPOT将会打印更多的信息并提供一个进度条<br>3，TPOT将打印所有内容，并提供一个进度条</p>
</li>
</ul>
<p>方法：</p>
<ul>
<li>fit(features, target, sample_weight=None, groups=None)，在给定的训练数据上运行TPOT优化过程。</li>
<li>predict(features)，使用优化的管道来预测测试集的目标值。</li>
<li>score(testing_features, testing_target)，使用用户指定的评分函数在给定的测试数据上返回优化的管道的得分。</li>
<li>export(output_file_name)，将优化的管道导出为Python代码。</li>
</ul>
<h2 id="4-实例"><a href="#4-实例" class="headerlink" title="4.实例"></a>4.实例</h2><h3 id="例4-1"><a href="#例4-1" class="headerlink" title="例4.1"></a>例4.1</h3><p>数据集地址：<a href="https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/" target="_blank" rel="noopener external nofollow noreferrer">https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/</a></p>
<p>使用的数据集：breast-cancer-wisconsin.data<br>直接把数据全选复制到txt中，然后直接改文件后缀为csv，把文件转换为csv格式。并加上属性名</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/4.png" alt></p>
<p>程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">使用TPOT自动选择scikit-learn机器学习模型和参数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"> </span><br><span class="line">inputfile=<span class="string">'C:/Users/bryce/Desktop/breast-cancer-wisconsin.data.csv'</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    df=pd.read_csv(inputfile)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    df.replace(<span class="string">'?'</span>,np.nan,inplace=<span class="literal">True</span>)</span><br><span class="line">    df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">    df.drop([<span class="string">'id'</span>],<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    df[<span class="string">'Bare Nuclei'</span>] = df[<span class="string">'Bare Nuclei'</span>].astype(int)</span><br><span class="line">    X=np.array(df.drop([<span class="string">'Class'</span>],<span class="number">1</span>))</span><br><span class="line">    Y=np.array(df[<span class="string">'Class'</span>])</span><br><span class="line">    x_train,x_test,y_train,y_test=model_selection.train_test_split(X,Y,test_size=<span class="number">0.2</span>)</span><br><span class="line">    tpot=TPOTClassifier(generations=<span class="number">6</span>,verbosity=<span class="number">2</span>)</span><br><span class="line">    tpot.fit(x_train,y_train)</span><br><span class="line">    tpot.score(x_test,y_test)</span><br><span class="line">    tpot.export(<span class="string">'pipeline.py'</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/5.png" alt></p>
<p>可以看到运行的最优结果是随机森林算法,并给出具体的参数。<br>再运行一下随机森林算法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">使用TPOT自动选择scikit-learn机器学习模型和参数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"> </span><br><span class="line">inputfile=<span class="string">'C:/Users/bryce/Desktop/breast-cancer-wisconsin.data.csv'</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    df=pd.read_csv(inputfile)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    df.replace(<span class="string">'?'</span>,np.nan,inplace=<span class="literal">True</span>)</span><br><span class="line">    df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">    df.drop([<span class="string">'id'</span>],<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">'Bare Nuclei'</span>] = df[<span class="string">'Bare Nuclei'</span>].astype(int)</span><br><span class="line">    <span class="comment">#print(df.head())</span></span><br><span class="line">    X=np.array(df.drop([<span class="string">'Class'</span>],<span class="number">1</span>))</span><br><span class="line">    Y=np.array(df[<span class="string">'Class'</span>])</span><br><span class="line">    x_train,x_test,y_train,y_test=model_selection.train_test_split(X,Y,test_size=<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># tpot=TPOTClassifier(generations=6,verbosity=2)</span></span><br><span class="line">    <span class="comment"># tpot.fit(x_train,y_train)</span></span><br><span class="line">    <span class="comment"># tpot.score(x_test,y_test)</span></span><br><span class="line">    <span class="comment"># tpot.export('pipeline.py')</span></span><br><span class="line"> </span><br><span class="line">    rfc=RandomForestClassifier(bootstrap=<span class="literal">True</span>, criterion=<span class="string">'entropy'</span>, max_features=<span class="number">0.05</span>, min_samples_leaf=<span class="number">3</span>, min_samples_split=<span class="number">16</span>, n_estimators=<span class="number">100</span>)</span><br><span class="line">    rfc.fit(x_train,y_train)</span><br><span class="line">    accuracy=rfc.score(x_test,y_test)</span><br><span class="line">    print(<span class="string">"accuracy:%s"</span>%accuracy)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2020/03/31/TPOT%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/6.png" alt></p>
<h3 id="例4-2"><a href="#例4-2" class="headerlink" title="例4.2"></a>例4.2</h3><p>数据集：sklearn自带的波士顿房价数据集</p>
<h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h2><ol>
<li><a href="https://epistasislab.github.io/tpot/examples/" target="_blank" rel="noopener external nofollow noreferrer">TPOT官方参考文档</a></li>
<li><a href="https://github.com/EpistasisLab/tpot" target="_blank" rel="noopener external nofollow noreferrer">TPOTgithub</a></li>
<li><a href="https://blog.csdn.net/anshuai_aw1/article/details/82498947" target="_blank" rel="noopener external nofollow noreferrer">利用TPOT完成自动化机器学习</a></li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法</title>
    <url>/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>整理一些常见的六大基础排序算法： 冒泡排序、选择排序、<strong>插入排序</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong></p>
<p><img src="/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort_summary.jpg" alt></p>
<a id="more"></a>

<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span></span><br><span class="line"><span class="comment">    2. 对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</span></span><br><span class="line"><span class="comment">    3. 针对所有的元素重复以上的步骤，除了最后已经选出的元素（有序）。</span></span><br><span class="line"><span class="comment">    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定排序，平均 O(n**2)，最好 O(n), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// swap(nums[j], nums[j+1]);</span></span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt></p>
<h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</span></span><br><span class="line"><span class="comment">    2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</span></span><br><span class="line"><span class="comment">    3. 以此类推，直到所有元素均排序完毕。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定排序，平均 O(n**2)，最好 O(n**2), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = i;</span><br><span class="line">        <span class="comment">//每一趟循环比较时，idx用于存放较小元素的数组下标，</span></span><br><span class="line">        <span class="comment">//这样当前批次比较完毕最终存放的就是此趟内最小的元素</span></span><br><span class="line">        <span class="comment">//的下标，避免每次遇到较小元素都要进行交换。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] &gt; nums[j]);</span><br><span class="line">            &#123;</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (idx !=i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[idx];</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插入排序（重要）"><a href="#3-插入排序（重要）" class="headerlink" title="3. 插入排序（重要）"></a>3. 插入排序（重要）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt></p>
<h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   直接插入排序基本思想是每一步将一个待排序的记录，</span></span><br><span class="line"><span class="comment">   插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   1. 从第一个元素开始，该元素可以认为已经被排序</span></span><br><span class="line"><span class="comment">   2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</span></span><br><span class="line"><span class="comment">   3. 如果被扫描的元素（已排序）大于新元素，将该元素后移一位</span></span><br><span class="line"><span class="comment">   4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span></span><br><span class="line"><span class="comment">   5. 将新元素插入到该位置后</span></span><br><span class="line"><span class="comment">   6. 重复步骤2~5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定排序，平均 O(n**2)，最好 O(n), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 从下标为1的元素开始选择合适的位置插入，</span></span><br><span class="line">    <span class="comment">// 因为下标为0的只有一个元素，默认是有序的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 记录要插入的数据</span></span><br><span class="line">        <span class="keyword">int</span> temp  = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i- <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//与已排序的数逐一比较，大于temp时，该数移后</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span>) &amp;&amp; (nums[j] &gt; nums[j])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-归并排序（重要）"><a href="#4-归并排序（重要）" class="headerlink" title="4. 归并排序（重要）"></a>4. 归并排序（重要）</h3><p><img src="/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/guibing1.png" alt><br><img src="/2020/03/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/guibing1.png" alt></p>
<h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   将已有序的子序列合并，得到完全有序的序列；</span></span><br><span class="line"><span class="comment">   即先使每个子序列有序，再使子序列段间有序。</span></span><br><span class="line"><span class="comment">   若将两个有序表合并成一个有序表，称为二路归并。</span></span><br><span class="line"><span class="comment">   归并排序是一种稳定的排序方法。</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">1、确定数组的大小，以及输入数组中的元素值；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、将输入的数组进行分组归并；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、将整个数组分成左右两个数组，左右两个数组再向下分，直至子数组的元素少于2个时，子数组将停止分割；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4、当左右子数组不能再分割，也是都是一个元素时，比较他们的大小，进行排序合并；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5、再排序合并上一级子数组为两个元素的数组，接着再排序合并上一级子数组为四个元素的数组；</span></span><br><span class="line"><span class="comment">直至到排序合并刚开始的两个子数组，最后成为排好序的数组；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定排序，平均 O(nlogn)，最好 O(nlogn), 最差 O(nlogn),辅助空间 O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp[high+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">//临时数组指针</span></span><br><span class="line">        <span class="keyword">int</span> l=low;<span class="comment">//左序列指针</span></span><br><span class="line">        <span class="keyword">int</span> r=mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid&amp;&amp;r&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]&lt;nums[r])</span><br><span class="line">                temp[i++]=nums[l++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[i++]=nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid) <span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[i++]=nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=high) <span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[i++]=nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将temp中的元素全部拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[low++]=temp[i++];</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            mergesort(nums,low,mid);  <span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">            mergesort(nums,mid+<span class="number">1</span>,high); <span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">            merge(nums,low,high); <span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-快速排序（重要）"><a href="#5-快速排序（重要）" class="headerlink" title="5. 快速排序（重要）"></a>5. 快速排序（重要）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt></p>
<h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 从数列中挑出一个元素作为基准数。</span></span><br><span class="line"><span class="comment">    2. 重新排序数列，将比基准数大的放到右边，小于或等于它的数都放到左边。</span></span><br><span class="line"><span class="comment">    3. 再对左右区间递归执行第二步，直至各区间只有一个数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定排序，平均 O(nlogn)，最好 O(nlogn), 最差 O(n**2),辅助空间 O(logn)</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">Paritition</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> pivot = nums[low];</span><br><span class="line">   <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= pivot)</span><br><span class="line">     &#123;</span><br><span class="line">       --high;</span><br><span class="line">     &#125;</span><br><span class="line">     nums[low] = nums[high];</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt; pivot)</span><br><span class="line">     &#123;</span><br><span class="line">       ++low;</span><br><span class="line">     &#125;</span><br><span class="line">     nums[high] = nums[low];</span><br><span class="line">   &#125;</span><br><span class="line">   nums[low] = pivot;</span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> <span class="comment">//快排母函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">int</span> i = Paritition(nums, low, high);</span><br><span class="line">     QuickSort(nums, low, i - <span class="number">1</span>);</span><br><span class="line">     QuickSort(nums, i + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>精简版</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> l = low, r = high, pivot = nums[low];</span><br><span class="line">		<span class="keyword">while</span>(l&lt;r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r] &gt;=pivot) <span class="comment">// 从右向左找第一个小于基准的数</span></span><br><span class="line">			&#123;</span><br><span class="line">			    r--;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[l] = nums[r];</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l] &lt; pivot) <span class="comment">// 从左向右找第一个大于等于基准的数</span></span><br><span class="line">			&#123;</span><br><span class="line">			    l++;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[r] = nums[l];</span><br><span class="line">		&#125;</span><br><span class="line">		nums[l] = pivot;</span><br><span class="line">		quick_sort(nums, low, l<span class="number">-1</span>);</span><br><span class="line">		quick_sort(nums, l+<span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-堆排序（重要）"><a href="#6-堆排序（重要）" class="headerlink" title="6. 堆排序（重要）"></a>6. 堆排序（重要）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt></p>
<h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">堆排序的基本思想是：将待排序序列构造成一个大顶堆，</span></span><br><span class="line"><span class="comment">此时，整个序列的最大值就是堆顶的根节点。将其与末</span></span><br><span class="line"><span class="comment">尾元素进行交换，此时末尾就为最大值。然后将剩余n-1</span></span><br><span class="line"><span class="comment">个元素重新构造成一个堆，这样会得到n个元素的次小值。</span></span><br><span class="line"><span class="comment">如此反复执行，便能得到一个有序序列了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  1.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　2.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与</span></span><br><span class="line"><span class="comment">  当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定排序，平均 O(nlogn)，最好 O(nlogn), 最差 O(n**2),辅助空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; nums[k]&lt;nums[k+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[k] &gt;temp)</span><br><span class="line">        <span class="comment">//如果子节点大于父节点，将子节点值赋给父节点</span></span><br><span class="line">        <span class="comment">//（不用进行交换）</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = nums[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[i] = temp;    <span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">        adjustHeap(nums,i,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=len<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(nums[<span class="number">0</span>],nums[j]);</span><br><span class="line">        <span class="comment">//将堆顶元素(最大值)与末尾元素进行交换，</span></span><br><span class="line">        <span class="comment">//将最大值交换到数组的最后位置保存</span></span><br><span class="line">        adjustHeap(nums,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>泵站机组故障诊断</title>
    <url>/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/</url>
    <content><![CDATA[<h3 id="故障诊断系统概述"><a href="#故障诊断系统概述" class="headerlink" title="故障诊断系统概述"></a>故障诊断系统概述</h3><p>研究的基于自动化机器学习的故障诊断系统既具有故障诊断算法训练功能，也具有算法部署功能。它会读取故障数据，进行特征提取，然后使用自动化机器学习方法找出最优机器学习流程，并将该流程训练好保存下来，最后使用Web服务器对故障诊断算法进行部署。所研究的故障诊断系统具有高度自动化、功能拓展方便、模型更新方便的特点。</p>
<a id="more"></a>
<p>本系统由以下几个子部分构成：</p>
<p>（1）系统运行日志。日志是对系统运行状态的记录，它可以帮助检验系统运行是否正常，在出现异常情况时可以帮助使用者快速查找错误。日志的记录是分级别的，一般分为DEBUG、INFO、WARNING、ERROR、CRITICAL 五个级别，这五个级别的严重程度越来越高。</p>
<p>（2）系统配置文件。系统配置文件本质上是文本文件，通过配套的文本解析方法可以提取出变量名及其对应的设定值。系统在主功能运行前读取配置文件，从而设定程序的运行模式或训练任务，达到不改变代码就可以改变程序运行的效果。</p>
<p>（3）故障样本数据库。所研究的故障诊断算法是基于机器学习的，而机器学习方法是由数据驱动的，因此一个故障样本数据库是必要的。由于本文研究对象泵站机组具有型号多、运行工况复杂的特点，故障样本数据库在设计的时候充分考虑了这些特点。</p>
<p>（4）样本平衡性检验。在用数据进行训练之前，应该对样本平衡性进行检验，样本数量比较少的做一些特殊处理，样本数量太少的应从训练集里予以剔除，更失衡严重的就终止本次训练，等待数据收集完毕后再开始。</p>
<p>（5）故障特征提取。从故障数据库获得的数据是传感器数据，而传感器数据是无法直接作为机器学习算法输入的。为了提高故障诊断算法的效果，应该先对数据库中传感器数据使用快速傅里叶变换进行预处理。</p>
<p>（6）使用TPOT进行模型训练。采用基于遗传算法的自动化机器学习方法TPOT是使用遗传算法对特征归一化、特征选择、模型和参数选择等环节组成的机器学习流程进行自动构建并寻优的方法。</p>
<p>（7）故障诊断模型工程部署。所研究的故障诊断模型工程部署方法是基于Python轻型Web服务器框架Flask通过HTTP协议实现Python环境与Java环境的交互。</p>
<p>故障诊断系统工作流程图如下所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/liucheng1.png" alt></p>
<h3 id="故障诊断系统研究"><a href="#故障诊断系统研究" class="headerlink" title="故障诊断系统研究"></a>故障诊断系统研究</h3><h4 id="故障数据库设计规范"><a href="#故障数据库设计规范" class="headerlink" title="故障数据库设计规范"></a>故障数据库设计规范</h4><p>在泵站机组型号或运行工况不一样的情况下，虽然机组发生了同一种故障类型，但同样位置的传感器数据会有所不同，这就导致提取的特征也有点不同。因此，在故障数据存储时必须要体现出故障样本的来源背景，这里用机组型号和运行工况来表示。</p>
<p>以机组某个部件有两个传感器为例设计的故障数据库规范如下表所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/shujuku1.png" alt></p>
<h4 id="故障样本不平衡处理"><a href="#故障样本不平衡处理" class="headerlink" title="故障样本不平衡处理"></a>故障样本不平衡处理</h4><h5 id="样本不平衡下的训练方法"><a href="#样本不平衡下的训练方法" class="headerlink" title="样本不平衡下的训练方法"></a>样本不平衡下的训练方法</h5><p>针对样本不平衡下的训练数据集采用简单易行的调整类的权重方法，该方法是在误差函数里添加类别权重，以达到误差平衡，带权重的误差函数为：</p>
<p>$$<br>\text { error }=\frac{\sum_{i=1}^{n} w_{i}\left(y_{i}^{\prime}-y_{i}\right)^{2}}{n}<br>$$</p>
<p>其中：</p>
<p>$𝑛$ 代表样本总数；</p>
<p>$𝑤_𝑖$ 代表第$i$个样本所在类别的权重；</p>
<p>$y_{i}^{\prime}$代表第$i$个样本的预测结果；</p>
<p>$𝑦_𝑖$代表第$i$个样本的实际结果。</p>
<h5 id="样本不平衡下的评估方法"><a href="#样本不平衡下的评估方法" class="headerlink" title="样本不平衡下的评估方法"></a>样本不平衡下的评估方法</h5><p>在统计和机器学习中，常常用AUC 来评估二分类模型的性能（多分类也可以使用，作为二分类的拓展）。AUC 的全称是Area under the curve，即曲线下的面积。通常这里的曲线指的是受试者操作曲线(Receiver Operating Characteristic,ROC)。相比于准确率、召回率、F1 值等依赖于判决阈值的评估指标，AUC则没有这个问题。</p>
<p>ROC 曲线：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/ROC.jpg" alt></p>
<p>AUC值为ROC 曲线下方所覆盖的区域面积，AUC越大, 说明曲线越靠近(0,1) 这个点，越接近理想曲线，分类效果自然更好。</p>
<p>AUC指标为什么可以作为样本不平衡情况下的模型评价指标？因为当用来验证算法效果的数据集中的样本比例发生变化时，ROC曲线的形状能够保持不变，而AUC是ROC曲线的下方面积，所以当模型一定时，AUC的值也不随正负样本分布的变化而变化，所以能够作为不平衡数据集的模型评价指标。</p>
<h4 id="故障特征提取"><a href="#故障特征提取" class="headerlink" title="故障特征提取"></a>故障特征提取</h4><p>泵轴的常见故障有油膜涡动、接触摩擦、油膜振荡、转子不平衡和转子不对中，这些故障都可以体现在泵轴的振动信号里，通常采用泵轴的摆度数值作为它的振动信号。通过利用FFT快速傅里叶变换将时域的振动信号转换为频域的能量分布。</p>
<p>下面对泵轴的转子不平衡故障数据进行特征提取实验，介绍如下：</p>
<p>（1）数据来源传感器：泵轴$Y$方向摆度信号</p>
<p>（2）数据滤波方法与窗函数：小波阈值去噪、汉宁窗</p>
<p>（3）基频$𝐹_0$、采样频率$𝐹_𝑠$和采样点数$𝑁$：$20Hz$、$2048Hz$、$2048$由上面几个数据，可得到下面几个频谱分析需要的参数：</p>
<p>（a）最高有效频率𝐹𝑚：𝐹𝑚 = 𝐹𝑠/2.56=800Hz</p>
<p>（b）频率分辨率𝛥𝐹 ：𝛥𝐹 = 𝐹𝑠/𝑁=2048/2048=1Hz</p>
<p>（c）谱线数𝑀：𝑀 = 𝑁/2.56=2048/2.56=800</p>
<p>下图为转子不平衡故障特征提取过程。</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/tezheng.jpg" alt></p>
<p>图中共有三个子图，其中最上面的图是泵轴摆度信号的时域图，表现出<br>了周期性，中间图是对摆度信号的时域数据作快速傅立叶变换得到的频谱，最下面图是从频谱提取的特征向量。</p>
<h4 id="自动化机器学习工具TPOT"><a href="#自动化机器学习工具TPOT" class="headerlink" title="自动化机器学习工具TPOT"></a>自动化机器学习工具TPOT</h4><p><a href="/TPOT——一个自动化的Python机器学习工具.md">此节具体参考这里</a></p>
<h4 id="诊断算法的部署"><a href="#诊断算法的部署" class="headerlink" title="诊断算法的部署"></a>诊断算法的部署</h4><p>设置Web服务器，通过HTTP协议进行调用。生产环境软件通过网络IP、端口将需要诊断的数据传递给Web服务器。Web服务器接受到数据后会进行诊断服务，在诊断结束后，诊断结果会原路返回给服务调用者。<br>诊断数据与Web 服务器之间使用HTTP协议进行通信，HTTP协议下有GET、POST、PUT 和DELETE 等方法，因为通信过程中需要传输传感器数据，所以这里使用可携带数据体的POST方法。</p>
<p>在故障诊断的各个环节中，诊断算法具有“一次加载、多次使用”的特点，而特征提取、算法调用等步骤随着传输数据的不同而采用不同的方法，所以故障诊断Web服务器在实现时应该按照这样的方式：加载诊断算法在创建故障诊断Web服务器时进行，数据获取、特征提取、调用诊断算法和诊断结果返回这些步骤在POST方法中实现。</p>
<h3 id="故障诊断系统具体实现"><a href="#故障诊断系统具体实现" class="headerlink" title="故障诊断系统具体实现"></a>故障诊断系统具体实现</h3><h4 id="系统开发环境"><a href="#系统开发环境" class="headerlink" title="系统开发环境"></a>系统开发环境</h4><p>故障诊断系统是在Windows 10上使用Python编程语言开发的，<br>其中数据库使用SQL Server，日志管理使用Logging，配置文件解析加载使用Configparser，频域分析工具包使用Scipy，矩阵数据处理使用Pandas 和Numpy，自动化机器学习工具使用TPOT，模型序列化保存工具使用Pickle，Web 应用框架使用Flask。</p>
<p>下表是详细的故障诊断系统开发环境。</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/environment.png" alt></p>
<h4 id="系统功能模块的实现"><a href="#系统功能模块的实现" class="headerlink" title="系统功能模块的实现"></a>系统功能模块的实现</h4><h5 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h5><p>系统日志管理工具使用Logging 模块实现，具体的是使用了Logging 下的logger 对象，使用logger 对象可以避免多个程序使用同一个日志文件时产生重复记录的问题。系统日志管理工具被打包成一个独立的文件，方便不同任务的复用。<a href="https://cuiqingcai.com/6080.html" target="_blank" rel="noopener external nofollow noreferrer">logging模块的基本用法</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_logger</span><span class="params">()</span>:</span></span><br><span class="line">    logger = logging.getLogger(__name__)</span><br><span class="line">    logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    stream_handler = logging.StreamHandler()</span><br><span class="line">    stream_handler.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    file_handler = logging.FileHandler(filename=<span class="string">'日志.log'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    file_handler.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">    formatter = logging.Formatter(fmt=<span class="string">'%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">    stream_handler.setFormatter(formatter)</span><br><span class="line">    file_handler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">    logger.addHandler(stream_handler)</span><br><span class="line">    logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logger</span><br></pre></td></tr></table></figure>

<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>配置文件的格式有ini、toml、yaml、json 和xml 等，其中ini格式的最为简单直观，这里使用的配置文件就是ini格式.部分配置如下图所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/ini.jpg" alt></p>
<h4 id="建立机组故障数据库"><a href="#建立机组故障数据库" class="headerlink" title="建立机组故障数据库"></a>建立机组故障数据库</h4><p>利用数据库SQL Server 2017 与数据库可视化管理工具Navicat Premium进行搭建，首先参考<a href="https://www.cnblogs.com/ios9/p/9527939.html" target="_blank" rel="noopener external nofollow noreferrer">Win10 SQL Server 2017安装</a>，利用Navicat进行创建一个Faults数据库，并在Faults数据库中创建Rotor表如图所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan2.png" alt></p>
<p>然后根据数据库设计规范，在表中创建相对应的字段。如图所示:</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan.png" alt></p>
<p><strong>注意：</strong> SQL Server 2017不支持数组形式，这里采用将数组转化为字符串,将他们拼接起来当做文本写入。</p>
<p>字段类型在设置的时候注意采用nvarchar(max)的类型，具体如下图：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan3.png" alt></p>
<p><a href="https://data.mendeley.com/datasets/p9bsmj4xwg/1/files/9ecd3bf8-6ed0-452b-8c84-05a4833ac803" target="_blank" rel="noopener external nofollow noreferrer">Rotor数据</a>, 数据是.mat文件，利用Python处理数据后，写入数据库CGQ1这一列中，最终如图所示：</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/guifan4.png" alt></p>
<h5 id="平衡性检验"><a href="#平衡性检验" class="headerlink" title="平衡性检验"></a>平衡性检验</h5><p>平衡性检验工具的实现是先使用Pandas 筛选数据，然后使用Collections模块的Counter 工具进行统计。</p>
<h5 id="故障特征提取-1"><a href="#故障特征提取-1" class="headerlink" title="故障特征提取"></a>故障特征提取</h5><p>故障特征提取工具以独立的代码文件形式进行存放，该工具是多个特征提取函数的集合，如果想使用哪个特征提取函数，只需要在配置文件里指定函数名，如果想使用的函数不存在，模仿已有的函数编辑添加即可。通过这样的设计，无需更改主函数就可改变系统功能。特征提取函数代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span><span class="params">(string)</span>:</span></span><br><span class="line">    string_arr = string.split(<span class="string">','</span>)</span><br><span class="line">    <span class="comment">#print(string_arr)</span></span><br><span class="line">    float_arr = list(map(float, string_arr))</span><br><span class="line">    <span class="keyword">return</span> float_arr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotor_simple</span><span class="params">(arr, logger, conf=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(arr,dict):<span class="comment">#如果数据来源于web,  isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。</span></span><br><span class="line">        arr = trans(arr)</span><br><span class="line">    <span class="comment">#print(arr[1])</span></span><br><span class="line">    rotation_frequency = round(float(arr[<span class="number">0</span>])/<span class="number">60</span>) <span class="comment"># 旋转频率</span></span><br><span class="line">    sample_frequency = int(arr[<span class="number">1</span>]) <span class="comment"># 采样频率</span></span><br><span class="line">    useful_bandwidth = int(sample_frequency/<span class="number">2.56</span>) <span class="comment"># 有效带宽</span></span><br><span class="line">    <span class="keyword">if</span> useful_bandwidth&lt;rotation_frequency*<span class="number">6</span>:</span><br><span class="line">        logger.warning(<span class="string">'数据采样频率过低！数据作废'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    sensor_data = transfer(arr[<span class="number">3</span>]) <span class="comment"># 将逗号拼接的传感器数据变成数组</span></span><br><span class="line">    data_length = len(sensor_data) <span class="comment"># 采样长度</span></span><br><span class="line">    sample_time = data_length/sample_frequency <span class="comment"># 采样时间</span></span><br><span class="line">    frequency_resolution = <span class="number">1</span>/sample_time <span class="comment"># 频率分辨率</span></span><br><span class="line">    <span class="keyword">if</span> (rotation_frequency&lt;<span class="number">10</span> <span class="keyword">and</span> frequency_resolution&gt;<span class="number">0.1</span>) <span class="keyword">or</span> sample_time&lt;<span class="number">1</span>:</span><br><span class="line">        logger.warning(<span class="string">'采样时间过短！数据作废'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    f0_candidates = [rotation_frequency<span class="number">-2</span>,rotation_frequency<span class="number">-1</span>,rotation_frequency,rotation_frequency+<span class="number">1</span>,rotation_frequency+<span class="number">2</span>] <span class="comment"># 基频</span></span><br><span class="line">    spectrum = abs(fft(sensor_data))[:useful_bandwidth]/len(sensor_data)  <span class="comment"># 频谱</span></span><br><span class="line">    f0 = f0_candidates[spectrum[f0_candidates].argmax()]<span class="comment"># 确定基频</span></span><br><span class="line">    segments = [[<span class="number">1</span>,int(<span class="number">0.40</span>*f0)],[int(<span class="number">0.40</span>*f0),int(<span class="number">0.50</span>*f0)],</span><br><span class="line">                [int(<span class="number">0.5</span>*f0)],[int(<span class="number">0.50</span>*f0)+<span class="number">1</span>,int(f0)],[f0],[int(<span class="number">2</span>*f0)],</span><br><span class="line">                [int(<span class="number">3</span>*f0),int(<span class="number">5</span>*f0)+<span class="number">1</span>],[int(<span class="number">6</span>*f0),useful_bandwidth]]</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> seg <span class="keyword">in</span> segments:</span><br><span class="line">        <span class="keyword">if</span> len(seg)==<span class="number">2</span>:</span><br><span class="line">            max_value = max(spectrum[seg[<span class="number">0</span>]:seg[<span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_value = spectrum[seg[<span class="number">0</span>]]</span><br><span class="line">        temp.append(max_value)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotor</span><span class="params">(data, useful_labels, conf, model_dir, logger)</span>:</span></span><br><span class="line">    djzs_field_name = conf[<span class="string">'Table'</span>][<span class="string">'djzs_field_name'</span>]</span><br><span class="line">    gzlx_field_name = conf[<span class="string">'Table'</span>][<span class="string">'gzlx_field_name'</span>]</span><br><span class="line">    cypl_field_name = conf[<span class="string">'Table'</span>][<span class="string">'cypl_field_name'</span>]</span><br><span class="line">    filtered_data = data.loc[:,[djzs_field_name,cypl_field_name,gzlx_field_name,<span class="string">'CGQ1'</span>]][data[gzlx_field_name].isin(useful_labels)]</span><br><span class="line">    </span><br><span class="line">    config_for_web = &#123;<span class="string">'mission'</span>:conf[<span class="string">'Mission'</span>][<span class="string">'table'</span>],</span><br><span class="line">                      <span class="string">'label'</span>:useful_labels,</span><br><span class="line">                     <span class="string">'function_for_web'</span>:conf[<span class="string">'Mission'</span>][<span class="string">'extract_feature_function_for_web'</span>]&#125;</span><br><span class="line">    <span class="keyword">with</span> open(model_dir+<span class="string">'\config_for_web.json'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        json.dump(config_for_web, file, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    feature_and_label = []</span><br><span class="line">    <span class="keyword">for</span> arr <span class="keyword">in</span> filtered_data.values:</span><br><span class="line">        temp = rotor_simple(arr, logger)</span><br><span class="line">        <span class="keyword">if</span> temp != <span class="literal">None</span>:<span class="comment"># 数据有效</span></span><br><span class="line">            temp.append(useful_labels.index(arr[<span class="number">2</span>]))</span><br><span class="line">            feature_and_label.append(temp)</span><br><span class="line">    feature_and_label = np.array(feature_and_label, dtype=np.float32)</span><br><span class="line">    </span><br><span class="line">    column = [<span class="string">'feature&#123;&#125;'</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(feature_and_label.shape[<span class="number">1</span>]<span class="number">-1</span>)]+[<span class="string">'label'</span>]</span><br><span class="line">    df = pd.DataFrame(data=feature_and_label, columns=column)</span><br><span class="line">    df.to_csv(model_dir+<span class="string">'\\feature_and_label.csv'</span>, index=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> feature_and_label</span><br></pre></td></tr></table></figure>

<h5 id="自动化机器学习"><a href="#自动化机器学习" class="headerlink" title="自动化机器学习"></a>自动化机器学习</h5><p>Python 的第三方包TPOT已经实现了基于遗传算法的自动化机器学习，通过在Python 环境中安装TPOT，并且调用相关方法即可实现自动化机器学习。部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger.info(<span class="string">'自动化机器学习初始化...'</span>)</span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"></span><br><span class="line">generations = int(conf[<span class="string">'Tpot'</span>][<span class="string">'generations'</span>])</span><br><span class="line">population_size = int(conf[<span class="string">'Tpot'</span>][<span class="string">'population_size'</span>])</span><br><span class="line">verbosity = int(conf[<span class="string">'Tpot'</span>][<span class="string">'verbosity'</span>])</span><br><span class="line"></span><br><span class="line">model = TPOTClassifier(generations=generations, population_size=population_size,  scoring=<span class="string">'f1_macro'</span>, cv=<span class="number">5</span>, n_jobs=<span class="number">1</span>, verbosity=verbosity)</span><br><span class="line">feature = feature_and_label[:,:<span class="number">-1</span>]</span><br><span class="line">label = feature_and_label[:,<span class="number">-1</span>]</span><br><span class="line">logger.info(<span class="string">'初始化完毕，开始寻找最优机器学习流程...'</span>)</span><br><span class="line">model.fit(feature, label)</span><br><span class="line">logger.info(<span class="string">'寻优结束，开始保存最优机器学习流程...'</span>)</span><br><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line">joblib.dump(model.fitted_pipeline_, model_dir+<span class="string">'\pipeline.pkl'</span>)</span><br><span class="line">logger.info(<span class="string">'保存成功，训练结束！'</span>)</span><br></pre></td></tr></table></figure>


<h5 id="故障诊断系统部署"><a href="#故障诊断系统部署" class="headerlink" title="故障诊断系统部署"></a>故障诊断系统部署</h5><p>利用Python轻型Web框架来进行部署构建故障诊断Web服务器。加载诊断算法和实现HTTP的POST方法。、</p>
<p>加载诊断算法并创建Web服务器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">function_for_web = &#123;&#125;</span><br><span class="line">pipeline = &#123;&#125;</span><br><span class="line">label = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> model_dirs:</span><br><span class="line">    logger.info(<span class="string">'正在读取web配置文件...'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(each+<span class="string">'\config_for_web.json'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            config_for_web = json.load(file)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        logger.error(<span class="string">'读取配置文件&#123;&#125;失败！'</span>.format(each+<span class="string">'\config.ini'</span>), exc_info=<span class="literal">True</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    logger.info(<span class="string">'web配置文件读取完成'</span>)</span><br><span class="line">    </span><br><span class="line">    mission = config_for_web[<span class="string">'mission'</span>]</span><br><span class="line">    function_for_web[mission] = config_for_web[<span class="string">'function_for_web'</span>]</span><br><span class="line">    pipeline[mission] = joblib.load(each+<span class="string">'\pipeline.pkl'</span>)</span><br><span class="line">    label[mission] = config_for_web[<span class="string">'label'</span>]</span><br><span class="line">    </span><br><span class="line">app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">5050</span>)</span><br></pre></td></tr></table></figure>

<p>POST方法实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/',methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diagnose</span><span class="params">()</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    all_data = request.json</span><br><span class="line">    missions = all_data.keys()</span><br><span class="line"><span class="comment">#     logger.info(str(missions))</span></span><br><span class="line">    <span class="keyword">for</span> mission <span class="keyword">in</span> missions:</span><br><span class="line">        exec(<span class="string">'from extract_features import &#123;0&#125; as extract_function'</span>.format(function_for_web[mission]), globals())</span><br><span class="line">        data = all_data[mission]</span><br><span class="line">        feature = extract_function(data, logger, conf)<span class="comment"># feature is a list</span></span><br><span class="line">        proba = pipeline[mission].predict_proba(np.array(feature, np.float32).reshape(<span class="number">1</span>, <span class="number">-1</span>))[<span class="number">0</span>]</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(proba):</span><br><span class="line">            result[label[mission][i]] = <span class="string">'%.1f'</span>%round(float(v)*<span class="number">100</span>,<span class="number">1</span>)</span><br><span class="line">        results[mission] = result</span><br><span class="line"><span class="comment">#     print(results)</span></span><br><span class="line">    <span class="keyword">return</span> json.dumps(results, ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h5 id="故障诊断系统测试"><a href="#故障诊断系统测试" class="headerlink" title="故障诊断系统测试"></a>故障诊断系统测试</h5><p>使用泵轴故障数据（数据类别为正常、转子不对中、转子不平衡、接触摩擦样本各45 个，来源工况单一）来简单测试一下所实现故障诊断系统，测试结果下图所示，横坐标代表机器学习流程组成的种群代数，纵坐标代表每代种群中最优机器学习流程的AUC评分。</p>
<p><img src="/2020/03/30/%E6%B3%B5%E7%AB%99%E6%9C%BA%E7%BB%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/res.jpg" alt></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>圆圈中最后剩下的数字</title>
    <url>/2020/03/30/62_%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>0,1，···n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<a id="more"></a>

<h2 id="本题考点："><a href="#本题考点：" class="headerlink" title="本题考点："></a>本题考点：</h2><p>  约瑟夫环问题</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h2><p>  1.) 模拟法</p>
<p>  用数组列表模拟一下。创建一个数组存储0-n-1的数组，但数组长度大于1时，就计算end位置即为(start+m-1)%len(nums) ，删除该元素后然后start再等于之前end，最后数组中剩最后一个元素，返回nums[0]</p>
<p>  时间复杂度O(n),空间复杂度O(n)</p>
<p>  2.) 数学方法：</p>
<p>  将上述问题建模为函数 f(n, m)，该函数的返回值为最终留下的元素的序号。</p>
<p>  每删除一个元素，下一个元素成为最开始的头，相当于把数组向前移动m位。若已知n-1个人时，删除下标位置位f(n−1,m)，则n个人的时候，就是往后移动m位，(因为有可能数组越界，超过的部分会被接到头上，所以还要模n)，既f(n,m) = (f(n-1,m) + m) % n</p>
<p>  递归公式为：$f(n, m)=(f(n-1, m)+m) \% n$</p>
<p>  时间复杂度O(n),空间复杂度O(n)</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="方法一：模拟法"><a href="#方法一：模拟法" class="headerlink" title="方法一：模拟法"></a>方法一：模拟法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res =<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span> || m&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">end</span> = (start+m<span class="number">-1</span>)%(nums.<span class="built_in">size</span>());</span><br><span class="line">            nums.erase(nums.<span class="built_in">begin</span>()+<span class="built_in">end</span>);  </span><br><span class="line">            <span class="comment">// vector插入删除操作时间复杂度是O(n)，可能会超时</span></span><br><span class="line">            start = <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二：数学法"><a href="#方法二：数学法" class="headerlink" title="方法二：数学法"></a>方法二：数学法</h4><p>迭代：空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归：空间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(n,m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (f(n<span class="number">-1</span>,m) + m) %n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/u011500062/article/details/72855826" target="_blank" rel="noopener external nofollow noreferrer">约瑟夫环——公式法（递推公式）</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>TPOT优化原理部分源码解读</title>
    <url>/2020/03/28/TPOT%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>TPOT的涉及到的建模过程，以TPOT light为例主要有3块：Classifiers、Preprocesssors、Selectors，TPOT的遗传算法优化是以pipeline为基础的，也就是说pipeline就相当于基因序列。通过构建初始pipeline，再经过遗传算法中的交叉、变异最终生成符合条件的模型效果较好的pipeline。我们从最优的那一代中选取其中建模效果最好的pipeline即可，TPOT是基于scikit-learn框架的，它本身不去实现我们常用的分类回归等算法。而是通过遗传算法优化pipeline。也就是从中选出最优的数据处理、特征选择、分类算法的组合。</p>
<a id="more"></a>
<p>一个简单的TPOT的使用实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"> </span><br><span class="line">iris = load_digits()</span><br><span class="line">iris.data[<span class="number">0</span>:<span class="number">5</span>], iris.target</span><br><span class="line"><span class="keyword">print</span> iris</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target,train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line">X_train.shape, X_test.shape, y_train.shape, y_test.shape</span><br><span class="line"> </span><br><span class="line">tpot = TPOTClassifier(verbosity=<span class="number">2</span>, max_time_mins=<span class="number">2</span>,config_dict=<span class="string">"TPOT light"</span>,population_size=<span class="number">10</span>,mutation_rate=<span class="number">0.9</span>,crossover_rate=<span class="number">0.1</span>)</span><br><span class="line">tpot.fit(X_train, y_train)</span><br><span class="line">print(tpot.score(X_test, y_test))</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/2020/03/28/TPOT%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/1.png" alt></p>
<h3 id="部分核心源码解读"><a href="#部分核心源码解读" class="headerlink" title="部分核心源码解读"></a>部分核心源码解读</h3><h4 id="1、初始群体的生成"><a href="#1、初始群体的生成" class="headerlink" title="1、初始群体的生成"></a>1、初始群体的生成</h4><p>这段代码可以看出，pipeline的构建是通过生成不同深度的树类构建初始pipeline的，大致过程是先确定树的深度，从Classifiers中选择一个分类器放入树的顶端，接下来构建分类器的参数，以上均为随机选取。如果树的深度大于1，则还需要从Preprocesssors、Selectors中选择算子加入到pipeline中，还要进行参数初始化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@_pre_test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate</span><span class="params">(self, pset, min_, max_, condition, type_=None)</span>:</span></span><br><span class="line">    <span class="string">"""Generate a Tree as a list of lists.</span></span><br><span class="line"><span class="string">    The tree is build from the root to the leaves, and it stop growing when</span></span><br><span class="line"><span class="string">    the condition is fulfilled.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    pset: PrimitiveSetTyped</span></span><br><span class="line"><span class="string">        Primitive set from which primitives are selected.</span></span><br><span class="line"><span class="string">    min_: int</span></span><br><span class="line"><span class="string">        Minimum height of the produced trees.</span></span><br><span class="line"><span class="string">    max_: int</span></span><br><span class="line"><span class="string">        Maximum Height of the produced trees.</span></span><br><span class="line"><span class="string">    condition: function</span></span><br><span class="line"><span class="string">        The condition is a function that takes two arguments,</span></span><br><span class="line"><span class="string">        the height of the tree to build and the current</span></span><br><span class="line"><span class="string">        depth in the tree.</span></span><br><span class="line"><span class="string">    type_: class</span></span><br><span class="line"><span class="string">        The type that should return the tree when called, when</span></span><br><span class="line"><span class="string">        :obj:None (default) no return type is enforced.</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    individual: list</span></span><br><span class="line"><span class="string">        A grown tree with leaves at possibly different depths</span></span><br><span class="line"><span class="string">        dependending on the condition function.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> type_ <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        type_ = pset.ret</span><br><span class="line">    expr = []</span><br><span class="line">    height = np.random.randint(min_, max_)</span><br><span class="line">    stack = [(<span class="number">0</span>, type_)]</span><br><span class="line">    <span class="keyword">while</span> len(stack) != <span class="number">0</span>:</span><br><span class="line">        depth, type_ = stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># We've added a type_ parameter to the condition function</span></span><br><span class="line">        <span class="keyword">if</span> condition(height, depth, type_):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                term = np.random.choice(pset.terminals[type_])</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                _, _, traceback = sys.exc_info()</span><br><span class="line">                <span class="keyword">raise</span> IndexError(</span><br><span class="line">                    <span class="string">'The gp.generate function tried to add '</span></span><br><span class="line">                    <span class="string">'a terminal of type &#123;&#125;, but there is'</span></span><br><span class="line">                    <span class="string">'none available. &#123;&#125;'</span>.format(type_, traceback)</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">if</span> inspect.isclass(term):</span><br><span class="line">                term = term()</span><br><span class="line">            expr.append(term)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                prim = np.random.choice(pset.primitives[type_])</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                _, _, traceback = sys.exc_info()</span><br><span class="line">                <span class="keyword">raise</span> IndexError(</span><br><span class="line">                    <span class="string">'The gp.generate function tried to add '</span></span><br><span class="line">                    <span class="string">'a primitive of type &#123;&#125;, but there is'</span></span><br><span class="line">                    <span class="string">'none available. &#123;&#125;'</span>.format(type_, traceback)</span><br><span class="line">                )</span><br><span class="line">            expr.append(prim)</span><br><span class="line">            <span class="keyword">for</span> arg <span class="keyword">in</span> reversed(prim.args):</span><br><span class="line">                stack.append((depth + <span class="number">1</span>, arg))</span><br><span class="line">    <span class="keyword">return</span> expr</span><br></pre></td></tr></table></figure>

<h4 id="2、适应性值评估检测"><a href="#2、适应性值评估检测" class="headerlink" title="2、适应性值评估检测"></a>2、适应性值评估检测</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_evaluate_individuals</span><span class="params">(self, individuals, features, target, sample_weight=None, groups=None)</span>:</span></span><br><span class="line">    <span class="string">"""Determine the fit of the provided individuals.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    individuals: a list of DEAP individual</span></span><br><span class="line"><span class="string">        One individual is a list of pipeline operators and model parameters that can be</span></span><br><span class="line"><span class="string">        compiled by DEAP into a callable function</span></span><br><span class="line"><span class="string">    features: numpy.ndarray &#123;n_samples, n_features&#125;</span></span><br><span class="line"><span class="string">        A numpy matrix containing the training and testing features for the individual's evaluation</span></span><br><span class="line"><span class="string">    target: numpy.ndarray &#123;n_samples&#125;</span></span><br><span class="line"><span class="string">        A numpy matrix containing the training and testing target for the individual's evaluation</span></span><br><span class="line"><span class="string">    sample_weight: array-like &#123;n_samples&#125;, optional</span></span><br><span class="line"><span class="string">        List of sample weights to balance (or un-balanace) the dataset target as needed</span></span><br><span class="line"><span class="string">    groups: array-like &#123;n_samples, &#125;, optional</span></span><br><span class="line"><span class="string">        Group labels for the samples used while splitting the dataset into train/test set</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    fitnesses_ordered: float</span></span><br><span class="line"><span class="string">        Returns a list of tuple value indicating the individual's fitness</span></span><br><span class="line"><span class="string">        according to its performance on the provided data</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"> </span><br><span class="line">    operator_counts, eval_individuals_str, sklearn_pipeline_list, stats_dicts = self._preprocess_individuals(individuals)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Make the partial function that will be called below</span></span><br><span class="line">    partial_wrapped_cross_val_score = partial(</span><br><span class="line">        _wrapped_cross_val_score,</span><br><span class="line">        features=features,</span><br><span class="line">        target=target,</span><br><span class="line">        cv=self.cv,</span><br><span class="line">        scoring_function=self.scoring_function,</span><br><span class="line">        sample_weight=sample_weight,</span><br><span class="line">        groups=groups,</span><br><span class="line">        timeout=self.max_eval_time_seconds</span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line">    result_score_list = []</span><br><span class="line">    <span class="comment"># Don't use parallelization if n_jobs==1</span></span><br><span class="line">    <span class="keyword">if</span> self.n_jobs == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> sklearn_pipeline <span class="keyword">in</span> sklearn_pipeline_list:</span><br><span class="line">            self._stop_by_max_time_mins()</span><br><span class="line">            val = partial_wrapped_cross_val_score(sklearn_pipeline=sklearn_pipeline)</span><br><span class="line">            result_score_list = self._update_val(val, result_score_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># chunk size for pbar update</span></span><br><span class="line">        <span class="comment"># chunk size is min of cpu_count * 2 and n_jobs * 4</span></span><br><span class="line">        chunk_size = min(cpu_count()*<span class="number">2</span>, self.n_jobs*<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> chunk_idx <span class="keyword">in</span> range(<span class="number">0</span>, len(sklearn_pipeline_list), chunk_size):</span><br><span class="line">            self._stop_by_max_time_mins()</span><br><span class="line">            parallel = Parallel(n_jobs=self.n_jobs, verbose=<span class="number">0</span>, pre_dispatch=<span class="string">'2*n_jobs'</span>)</span><br><span class="line">            tmp_result_scores = parallel(delayed(partial_wrapped_cross_val_score)(sklearn_pipeline=sklearn_pipeline)</span><br><span class="line">                                         <span class="keyword">for</span> sklearn_pipeline <span class="keyword">in</span> sklearn_pipeline_list[chunk_idx:chunk_idx + chunk_size])</span><br><span class="line">            <span class="comment"># update pbar</span></span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> tmp_result_scores:</span><br><span class="line">                result_score_list = self._update_val(val, result_score_list)</span><br><span class="line"> </span><br><span class="line">    self._update_evaluated_individuals_(result_score_list, eval_individuals_str, operator_counts, stats_dicts)</span><br><span class="line"> </span><br><span class="line">    <span class="string">"""Look up the operator count and cross validation score to use in the optimization"""</span></span><br><span class="line">    <span class="keyword">return</span> [(self.evaluated_individuals_[str(individual)][<span class="string">'operator_count'</span>],</span><br><span class="line">             self.evaluated_individuals_[str(individual)][<span class="string">'internal_cv_score'</span>])</span><br><span class="line">            <span class="keyword">for</span> individual <span class="keyword">in</span> individuals]</span><br></pre></td></tr></table></figure>

<h3 id="3、变异"><a href="#3、变异" class="headerlink" title="3、变异"></a>3、变异</h3><p>变异主要是增加pipeline的内容或更换其中的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_random_mutation_operator</span><span class="params">(self, individual, allow_shrink=True)</span>:</span></span><br><span class="line">    <span class="string">"""Perform a replacement, insertion, or shrink mutation on an individual.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    individual: DEAP individual</span></span><br><span class="line"><span class="string">        A list of pipeline operators and model parameters that can be</span></span><br><span class="line"><span class="string">        compiled by DEAP into a callable function</span></span><br><span class="line"><span class="string">    allow_shrink: bool (True)</span></span><br><span class="line"><span class="string">        If True the `mutShrink` operator, which randomly shrinks the pipeline,</span></span><br><span class="line"><span class="string">        is allowed to be chosen as one of the random mutation operators.</span></span><br><span class="line"><span class="string">        If False, `mutShrink`  will never be chosen as a mutation operator.</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    mut_ind: DEAP individual</span></span><br><span class="line"><span class="string">        Returns the individual with one of the mutations applied to it</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    mutation_techniques = [</span><br><span class="line">        partial(gp.mutInsert, pset=self._pset),</span><br><span class="line">        partial(mutNodeReplacement, pset=self._pset)</span><br><span class="line">    ]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># We can't shrink pipelines with only one primitive, so we only add it if we find more primitives.</span></span><br><span class="line">    number_of_primitives = sum([isinstance(node, deap.gp.Primitive) <span class="keyword">for</span> node <span class="keyword">in</span> individual])</span><br><span class="line">    <span class="keyword">if</span> number_of_primitives &gt; <span class="number">1</span> <span class="keyword">and</span> allow_shrink:</span><br><span class="line">        mutation_techniques.append(partial(gp.mutShrink))</span><br><span class="line"> </span><br><span class="line">    mutator = np.random.choice(mutation_techniques)</span><br><span class="line"> </span><br><span class="line">    unsuccesful_mutations = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(self._max_mut_loops):</span><br><span class="line">        <span class="comment"># We have to clone the individual because mutator operators work in-place.</span></span><br><span class="line">        ind = self._toolbox.clone(individual)</span><br><span class="line">        offspring, = mutator(ind)</span><br><span class="line">        <span class="keyword">if</span> str(offspring) <span class="keyword">not</span> <span class="keyword">in</span> self.evaluated_individuals_:</span><br><span class="line">            <span class="comment"># Update statistics</span></span><br><span class="line">            <span class="comment"># crossover_count is kept the same as for the predecessor</span></span><br><span class="line">            <span class="comment"># mutation count is increased by 1</span></span><br><span class="line">            <span class="comment"># predecessor is set to the string representation of the individual before mutation</span></span><br><span class="line">            <span class="comment"># generation is set to 'INVALID' such that we can recognize that it should be updated accordingly</span></span><br><span class="line">            offspring.statistics[<span class="string">'crossover_count'</span>] = individual.statistics[<span class="string">'crossover_count'</span>]</span><br><span class="line">            offspring.statistics[<span class="string">'mutation_count'</span>] = individual.statistics[<span class="string">'mutation_count'</span>] + <span class="number">1</span></span><br><span class="line">            offspring.statistics[<span class="string">'predecessor'</span>] = (str(individual),)</span><br><span class="line">            offspring.statistics[<span class="string">'generation'</span>] = <span class="string">'INVALID'</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            unsuccesful_mutations += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Sometimes you have pipelines for which every shrunk version has already been explored too.</span></span><br><span class="line">    <span class="comment"># To still mutate the individual, one of the two other mutators should be applied instead.</span></span><br><span class="line">    <span class="keyword">if</span> ((unsuccesful_mutations == <span class="number">50</span>) <span class="keyword">and</span></span><br><span class="line">            (type(mutator) <span class="keyword">is</span> partial <span class="keyword">and</span> mutator.func <span class="keyword">is</span> gp.mutShrink)):</span><br><span class="line">        offspring, = self._random_mutation_operator(individual, allow_shrink=<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> offspring,</span><br></pre></td></tr></table></figure>

<h3 id="4、交叉"><a href="#4、交叉" class="headerlink" title="4、交叉"></a>4、交叉</h3><p>选取两个pipeline，对里面的内容进行互换，但是两个pipeline的primitive要相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pick_two_individuals_eligible_for_crossover</span><span class="params">(population)</span>:</span></span><br><span class="line">    <span class="string">"""Pick two individuals from the population which can do crossover, that is, they share a primitive.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    population: array of individuals</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    tuple: (individual, individual)</span></span><br><span class="line"><span class="string">        Two individuals which are not the same, but share at least one primitive.</span></span><br><span class="line"><span class="string">        Alternatively, if no such pair exists in the population, (None, None) is returned instead.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    primitives_by_ind = [set([node.name <span class="keyword">for</span> node <span class="keyword">in</span> ind <span class="keyword">if</span> isinstance(node, gp.Primitive)])</span><br><span class="line">                         <span class="keyword">for</span> ind <span class="keyword">in</span> population]</span><br><span class="line">    pop_as_str = [str(ind) <span class="keyword">for</span> ind <span class="keyword">in</span> population]</span><br><span class="line"> </span><br><span class="line">    eligible_pairs = [(i, i+<span class="number">1</span>+j) <span class="keyword">for</span> i, ind1_prims <span class="keyword">in</span> enumerate(primitives_by_ind)</span><br><span class="line">                                 <span class="keyword">for</span> j, ind2_prims <span class="keyword">in</span> enumerate(primitives_by_ind[i+<span class="number">1</span>:])</span><br><span class="line">                                 <span class="keyword">if</span> <span class="keyword">not</span> ind1_prims.isdisjoint(ind2_prims) <span class="keyword">and</span></span><br><span class="line">                                    pop_as_str[i] != pop_as_str[i+<span class="number">1</span>+j]]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Pairs are eligible in both orders, this ensures that both orders are considered</span></span><br><span class="line">    eligible_pairs += [(j, i) <span class="keyword">for</span> (i, j) <span class="keyword">in</span> eligible_pairs]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> eligible_pairs:</span><br><span class="line">        <span class="comment"># If there are no eligible pairs, the caller should decide what to do</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    pair = np.random.randint(<span class="number">0</span>, len(eligible_pairs))</span><br><span class="line">    idx1, idx2 = eligible_pairs[pair]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> population[idx1], population[idx2]</span><br></pre></td></tr></table></figure>

<p>TPOT设置了一个阈值来决定是交叉还是变异，默认情况下变异的概率为0.9，交叉的概率为0.1.我们可以修改这个阈值。</p>
<p>具体的pipeline变换如下：</p>
<p>默认的种群数量为100，为了看源码方便，改为了5个种群数。交叉变异的概率各为0.5.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tpot = TPOTClassifier(verbosity=<span class="number">2</span>, max_time_mins=<span class="number">2</span>,config_dict=<span class="string">"TPOT light"</span>,population_size=<span class="number">5</span>,mutation_rate=<span class="number">0.5</span>,crossover_rate=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p>初始种群为5个pipeline，分别为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> = &#123;Individual&#125; KNeighborsClassifier(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), KNeighborsClassifier__n_neighbors=<span class="number">79</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br><span class="line"><span class="number">1</span> = &#123;Individual&#125; KNeighborsClassifier(Binarizer(input_matrix, Binarizer__threshold=<span class="number">0.55</span>), KNeighborsClassifier__n_neighbors=<span class="number">84</span>, KNeighborsClassifier__p=<span class="number">2</span>, KNeighborsClassifier__weights=uniform)</span><br><span class="line"><span class="number">2</span> = &#123;Individual&#125; DecisionTreeClassifier(input_matrix, DecisionTreeClassifier__criterion=gini, DecisionTreeClassifier__max_depth=<span class="number">9</span>, DecisionTreeClassifier__min_samples_leaf=<span class="number">18</span>, DecisionTreeClassifier__min_samples_split=<span class="number">20</span>)</span><br><span class="line"><span class="number">3</span> = &#123;Individual&#125; LogisticRegression(StandardScaler(input_matrix), LogisticRegression__C=<span class="number">0.0001</span>, LogisticRegression__dual=<span class="literal">True</span>, LogisticRegression__penalty=l2)</span><br><span class="line"><span class="number">4</span> = &#123;Individual&#125; GaussianNB(input_matrix)</span><br></pre></td></tr></table></figure>
<p>经过第一轮交叉、变异，结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> = &#123;Individual&#125; LogisticRegression(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), LogisticRegression__C=<span class="number">0.1</span>, LogisticRegression__dual=<span class="literal">True</span>, LogisticRegression__penalty=l2)</span><br><span class="line"><span class="number">1</span> = &#123;Individual&#125; KNeighborsClassifier(input_matrix, KNeighborsClassifier__n_neighbors=<span class="number">79</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br><span class="line"><span class="number">2</span> = &#123;Individual&#125; KNeighborsClassifier(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), KNeighborsClassifier__n_neighbors=<span class="number">79</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br><span class="line"><span class="number">3</span> = &#123;Individual&#125; GaussianNB(input_matrix)</span><br><span class="line"><span class="number">4</span> = &#123;Individual&#125; KNeighborsClassifier(PCA(input_matrix, PCA__iterated_power=<span class="number">6</span>, PCA__svd_solver=randomized), KNeighborsClassifier__n_neighbors=<span class="number">84</span>, KNeighborsClassifier__p=<span class="number">1</span>, KNeighborsClassifier__weights=distance)</span><br></pre></td></tr></table></figure>

<p>然后对这几个pipeline进行打分评估，和上一轮pipeline一起选出score最高的前5个。</p>
<p>进入下一轮迭代。最后产生5个pipeline，打分，从中选出最优的那个：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Best pipeline: KNeighborsClassifier(input_matrix, n_neighbors=<span class="number">10</span>, p=<span class="number">2</span>, weights=distance)</span><br><span class="line"><span class="number">0.977777777778</span></span><br></pre></td></tr></table></figure>

<p>流程举例如下（具体流程和TPOT代码本身略有区别，但是不影响对遗传算法自动化建模的理解）</p>
<p><img src="/2020/03/28/TPOT%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/2.png" alt></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://blog.csdn.net/hgy0403/article/details/81291307" target="_blank" rel="noopener external nofollow noreferrer">TPOT遗传算法</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Github分支备份Hexo博客源文件</title>
    <url>/2020/03/21/%E5%88%A9%E7%94%A8Github%E5%88%86%E6%94%AF%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>Hexo 部署博客很方便，我的这个博客也是用 Hexo 部署在 GitHub Pages 上的，有得人可能在多台电脑上写博客，这个时候需要把博客的源文件备份在一个地方，这样只需把博客源文件复制下来就可以在另一个地方写博客并部署到 GitHub Pages上了</p>
<a id="more"></a>
<p>本篇介绍的就是利用博客的 repo 分支（ master 分支的必须用来存放你博客网站文件）托管 Hexo 源文件和配置达到备份的目的，下面开始正题</p>
<h4 id="把博客目录的源文件push到repo分支上"><a href="#把博客目录的源文件push到repo分支上" class="headerlink" title="把博客目录的源文件push到repo分支上"></a>把博客目录的源文件push到repo分支上</h4><p>cd 进入博客目录，Git 初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>完成之后，添加修改的文件，Hexo 就自带了 .gitignore 文件需要忽略的文件 都已经默认配置好了，add 全部文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>然后commit：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;commit first time&quot;</span><br></pre></td></tr></table></figure>
<p>提交成功之后，接下来就是 push 到github了，需要先把这 Hexo 源文件映射到远程 repo 上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;your-name&#x2F;your-name.github.io.git</span><br></pre></td></tr></table></figure>

<p>接下来就是把Hexo源文件 push 上去，但是关键的地方到了，master上是 Hexo 生成博客网页的代码，而我们 Hexo 源文件是要 push 到一个分支上面的，所以接下来先要在 repo 上新建一个分支</p>
<p>新建一个叫做blogSource的分支(注意：分支名要和本地hexo项目名一致，不然push会出错)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch blogSource</span><br></pre></td></tr></table></figure>

<p>查看本地分支，并且切换到 blogSource 分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git checkout blogSource</span><br></pre></td></tr></table></figure>

<p>然后拉取远程代码，再把刚才添加的 Hexo 源文件代码 push 到blogSource这个分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br><span class="line">git push -u origin blogSource</span><br></pre></td></tr></table></figure>
<p>然后就可以在 repo 上看到分支里面已经有博客的源文件了</p>
<h4 id="日常更新博客源文件"><a href="#日常更新博客源文件" class="headerlink" title="日常更新博客源文件"></a>日常更新博客源文件</h4><p>以后你本地的博客源文件的修改就可以直接用 git 命令 push 到 repo 的 blogSource 分支上了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .  &#x2F;&#x2F;添加修改内容到本地仓储</span><br><span class="line">git commit -m &#39;modify blog&#39;  &#x2F;&#x2F;提交修改内容到本地仓库</span><br><span class="line">git push --set-upstream origin blogSource  &#x2F;&#x2F;配置push，以方便后期直接git push推送</span><br><span class="line">git push  &#x2F;&#x2F;将本地分支和分支下的内容推送到远程</span><br></pre></td></tr></table></figure>

<p>注意：执行 git push –set-upstream origin blogSource 命令之后，以后修改博客源文件代码之后，直接使用 git push 不用再指定分支，就可以把代码 push 到 blogSource 分支上了</p>
<h4 id="更换地点使用-repo-分支上的博客源文件"><a href="#更换地点使用-repo-分支上的博客源文件" class="headerlink" title="更换地点使用 repo 分支上的博客源文件"></a>更换地点使用 repo 分支上的博客源文件</h4><p>换一台电脑，配置好 Hexo 的环境，<a href="https://xiaovv.me/2017/04/06/GitHub%E9%85%8D%E7%BD%AESSH-key/" target="_blank" rel="noopener external nofollow noreferrer">配置 Git SSH key</a>，把博客源文件代码克隆下来:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone xxxxxxxxx.xx (你的 github page 的 repo 地址)</span><br></pre></td></tr></table></figure>

<p>博客源文件下载下来之后，默认的分支是 master，需要切换到 blogSource 分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout origin&#x2F;blogSource</span><br></pre></td></tr></table></figure>

<p>然后cd到博客目录依次执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>接下来就可以开始愉快的写博客了，写完之后记得把源文件代码 push 到 Github 上，然后用 Hexo 部署到自己博客上面</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + NexT主题博客相关设置</title>
    <url>/2020/03/21/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="一、添加文章版权声明功能"><a href="#一、添加文章版权声明功能" class="headerlink" title="一、添加文章版权声明功能"></a>一、添加文章版权声明功能</h4><p>打开博客目录下的主题配置文件（/themes/next/_config.yml），找到Declare license on posts 标签，进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Declare license on posts</span><br><span class="line">post_copyright:</span><br><span class="line">  enable: true    #激活版权声明模块</span><br><span class="line">  license: CC BY-NC-SA 3.0     #版权许可协议</span><br><span class="line">  license_url: https:&#x2F;&#x2F;winney07.github.io&#x2F;      #声明的文章的可点击链接（域名）</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>配置完后，执行以下命令，在浏览器中访问，效果如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/next-set1.png" alt></p>
<h4 id="二、设置favicon图标"><a href="#二、设置favicon图标" class="headerlink" title="二、设置favicon图标"></a>二、设置favicon图标</h4><p>1、选择一个favicon制作网站完成制作，例如：比特虫 ，制作一个16*16，一个32*32的；</p>
<p>2、两个不同尺寸大小的文件，重名为favicon-16x16-next.png和favicon-32x32-next.png；</p>
<p>3、将重命名的两个图片文件放到博客目录下的themes/next/source/images中（覆盖原来的两个默认的）<br>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/favicon.png" alt></p>
<h3 id="三、添加友情链接"><a href="#三、添加友情链接" class="headerlink" title="三、添加友情链接"></a>三、添加友情链接</h3><p>打开主题配置文件（/themes/next/_config.yml），找到以下内容进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: 友情链接 </span><br><span class="line"># links_layout: block   &#x2F;&#x2F;块状显示（选择了行内显示，这个要注释掉，不然会报错）</span><br><span class="line">links_layout: inline    &#x2F;&#x2F;行内显示</span><br><span class="line">links:</span><br><span class="line">  小超: https:&#x2F;&#x2F;www.xiaochao.me&#x2F;</span><br><span class="line">  Github: https:&#x2F;&#x2F;www.github.com</span><br></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/Hexo-NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/friend-link.png" alt></p>
<h4 id="四、调整hexo页面宽度"><a href="#四、调整hexo页面宽度" class="headerlink" title="四、调整hexo页面宽度"></a>四、调整hexo页面宽度</h4><p>博客在浏览器上的留白太多，因此想增加文章的宽度。</p>
<p>打开/themes/next/source/css/_variables/custom.styl 添加两行代码即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$main-desktop &#x3D; 1200px </span><br><span class="line">$content-desktop &#x3D; 900px</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>在Hexo博客中发布文章</title>
    <url>/2020/03/21/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h4 id="1、新建一篇文章"><a href="#1、新建一篇文章" class="headerlink" title="1、新建一篇文章"></a>1、新建一篇文章</h4><p>（1）在hexo博客目录下，进入Git Bash命令窗口中，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;在这里&quot;</span><br></pre></td></tr></table></figure>

<p>（2）在博客目录下的/source/_posts/ 文件夹下，可以看到已经生成了标题为(在这里.md)的博客文件：<br>如图所示：<br><img src="https://winney07.github.io/2018/08/02/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/zai.png" alt></p>
<a id="more"></a>
<p>（3）在（在这里.md）文件中编辑自己的博客文章即可。<br>注意：Hexo 发布的文章是 Markdown 格式的文件， Markdown 基本语法的网址：<a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener external nofollow noreferrer">点这里前往</a></p>
<h4 id="2、给文章添加分类和标签"><a href="#2、给文章添加分类和标签" class="headerlink" title="2、给文章添加分类和标签"></a>2、给文章添加分类和标签</h4><p>(1) 在（在这里.md）文件中设置tags和categories属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 在这里</span><br><span class="line">date: 2018-08-02 11:41:10</span><br><span class="line">tags:</span><br><span class="line">- 博客           &#x2F;&#x2F;多个标签可以这样添加</span><br><span class="line">- hexo</span><br><span class="line">categories: test</span><br></pre></td></tr></table></figure>
<p>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/02/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/zai-edit.png" alt></p>
<h4 id="3、启动服务器，本地测试"><a href="#3、启动服务器，本地测试" class="headerlink" title="3、启动服务器，本地测试"></a>3、启动服务器，本地测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h4 id="4、添加“阅读全文”按钮"><a href="#4、添加“阅读全文”按钮" class="headerlink" title="4、添加“阅读全文”按钮"></a>4、添加“阅读全文”按钮</h4><p>方法一：在文章任意你想添加的位置添加即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p>方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto_excerpt进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>

<p>其中length代表显示摘要的截取字符长度。</p>
<p>注：这两种方法，在博客首页显示的效果不一样，根据自己的需要，选择自己喜欢的方法</p>
<h4 id="5、在博文中添加图片"><a href="#5、在博文中添加图片" class="headerlink" title="5、在博文中添加图片"></a>5、在博文中添加图片</h4><p>方法一：</p>
<p>(1)在blog目录下，安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>(2)在blog\source 目录下新建一个images文件夹，把图片放置在里面；</p>
<p>(3)在xxx.md文件中引用图片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![header]( images&#x2F;header.jpg)</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<p>(1)在全局配置文件（blog/_config.yml)中将post_asset_folder设置为true；</p>
<p>(2)创建文章（在创建的时候，会在blog/source/_post目录下，生成一个XXX.md文件和一个XXX的文件夹）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;XXX&quot;</span><br></pre></td></tr></table></figure>

<p>(3)把XXX这个博文需要展示的图片放在XXX文件夹目录下；</p>
<p>(4)在XXX.md文件中引入图片的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![你想输入的替代文字](XXX&#x2F;图片名.jpg)</span><br></pre></td></tr></table></figure>
<h4 id="6、发布到Github上"><a href="#6、发布到Github上" class="headerlink" title="6、发布到Github上"></a>6、发布到Github上</h4><p>（1）发表的文章在本地预览无误后，在 Git Bash 命令窗口执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>（2）在浏览器，访问自己的博客域名，即可看到刚 发布的文章</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>将Hexo博客主题更换为NexT主题</title>
    <url>/2020/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p>1、把默认主题更改成Next主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>这是将Next主题下载到blog目录的themes主题下的next文件夹中。打开站点的_config.yml配置文件，修改主题为next<br><img src="/2020/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/1.jpg" alt></p>
<a id="more"></a>
<p>打开<strong>主题theme</strong>的_config.yml配置文件，不是<strong>站点site</strong>主题文件，找到Scheme Settings<br><img src="/2020/03/20/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/2.jpg" alt><br>next主题有三个样式，我用的是Pisces，可以选择你自己喜欢的样式（只需要把行首的#去除，#是注释），选择好后，再次部署网站，hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。</p>
<p>2、在主题配置文件 _config.yml中配置博客网站底部的基本信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup.</span><br><span class="line">  # If not defined, current year will be used.</span><br><span class="line">  since: 2020      #网站起始运营年份</span><br><span class="line"></span><br><span class="line">  # Icon between year and copyright info.</span><br><span class="line">  icon: user     #声明图标</span><br><span class="line"></span><br><span class="line">  # If not defined, will be used &#96;author&#96; from Hexo main config.</span><br><span class="line">  copyright: bryceustc   #版权所有</span><br><span class="line">  # ------------------------------------------------------------</span><br><span class="line">  # Hexo link (Powered by Hexo).</span><br><span class="line">  powered: true</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">    enable: false    #是否显示主题</span><br><span class="line">    # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">    version: false     #是否显示驱动</span><br></pre></td></tr></table></figure>

<p>3、在主题配置文件 _config.yml中配置菜单按钮，找到menu属性，做以下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line"> home: &#x2F; || home     #首页，后面的表示图标</span><br><span class="line"> categories: &#x2F;categories&#x2F; || th   #分类</span><br><span class="line"> tags: &#x2F;tags&#x2F; || tags       #标签</span><br><span class="line"> archives: &#x2F;archives&#x2F; || archive     #归档</span><br><span class="line"> about: &#x2F;about&#x2F; || user       #关于</span><br><span class="line"> #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line"> #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line"> #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure>
<p>4、创建相应的页面</p>
<p>（1）执行命令hexo s，本地预览我们的博客页面，会发现，点击分类、标签、关于这几个页面的时候，会显示404。</p>
<p>（2）在Git Bash命令窗口，输入以下命令来创建相应页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &#39;categories&#39;</span><br><span class="line">hexo new page &#39;tags&#39;</span><br><span class="line">hexo new page &#39;about&#39;</span><br></pre></td></tr></table></figure>
<p>（3）可以在hexo/source目录下看到创建的3个文件夹<br><img src="https://winney07.github.io/2018/08/01/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/source.png" alt></p>
<p>5、每一个分类菜单都生成了一个 index.md 初始文件（在刚创建的文件夹目录下），默认包含了 title 和 date 字段，我们需要给每一 index.md 文件添加上 type 字段<br>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-3-20 16:28:33</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-3-20 16:28:33</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2020-3-20 16:28:33</span><br><span class="line">type: about</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>6、配置搜索菜单：<br>（1）安装 hexo-generator-searchdb ，在 Git Bash 命令窗口，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>（2）打开全局配置文件（hexo/_config.yml），新增以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>（3）打开主题配置文件（hexo/themes/next/_config.yml），找到 local_search 属性，开启本地搜索功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>
<p>7、执行命令hexo s，本地预览我们的博客页面，发现刚才的配置已经完成</p>
<p>8、在命令窗口，输入以下命令，将修改后的本地hexo项目托管到GitHub上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>9、上传成功后，可以通过自己的博客域名访问修改主题和修改相关配置后的博客页面</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + GitHub Pages 搭建个人博客</title>
    <url>/2020/03/19/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><h4 id="1、安装Node-js"><a href="#1、安装Node-js" class="headerlink" title="1、安装Node.js"></a>1、安装Node.js</h4><p>(1) 下载Node.js：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener external nofollow noreferrer">官网下载地址</a> （这里以Windows 为例）;</p>
<p><img src="/images/node.png" alt></p>
<a id="more"></a>
<p>(2) 双击下载好的.msi文件，按下一步下一步，安装好就可以；</p>
<p>(3) 在cmd命令窗口，输入下面的这个命令，如果能够显示Node.js的版本，说明安装成功了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<p><img src="/images/node_v.png" alt></p>
<h4 id="2、安装Git"><a href="#2、安装Git" class="headerlink" title="2、安装Git"></a>2、安装Git</h4><p>(1) 下载Git：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener external nofollow noreferrer">官网下载</a></p>
<p>(2) 双击下载好的Git安装包，按下一步下一步，进行安装即可；</p>
<p>(3) 在cmd命令窗口，输入下面的这个命令，如果能够显示Git的版本，说明安装成功了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p><img src="/images/git_v.png" alt></p>
<h3 id="二、Hexo搭建博客"><a href="#二、Hexo搭建博客" class="headerlink" title="二、Hexo搭建博客"></a>二、Hexo搭建博客</h3><h4 id="1、安装Hexo"><a href="#1、安装Hexo" class="headerlink" title="1、安装Hexo"></a>1、安装Hexo</h4><p>（1）在计算机中，新建一个Blog文件夹，用于存放自己的博客内容。</p>
<p>（2）在Blog文件夹内，鼠标右键，选择Git Bash,进入到命令窗口</p>
<p><img src="/images/blog.png" alt></p>
<p>（3）在命令窗口中，输入下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h4 id="2、初始化Hexo"><a href="#2、初始化Hexo" class="headerlink" title="2、初始化Hexo"></a>2、初始化Hexo</h4><p>在命令窗口中，输入下面代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<h4 id="3、配置Hexo"><a href="#3、配置Hexo" class="headerlink" title="3、配置Hexo"></a>3、配置Hexo</h4><p>(1) 安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>(2) 部署形成的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g &#x2F;&#x2F;或者 hexo generate</span><br></pre></td></tr></table></figure>

<h4 id="4、启动服务器"><a href="#4、启动服务器" class="headerlink" title="4、启动服务器"></a>4、启动服务器</h4><p>(1) 在命令窗口执行下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s  &#x2F;&#x2F;或者 hexo server</span><br></pre></td></tr></table></figure>

<p>(2) 在浏览器地址栏中输入<a href="http://localhost:4000/" target="_blank" rel="noopener external nofollow noreferrer">http://localhost:4000/</a> （默认端口是4000），如果能够看到如图所示的效果，说明初始化的Hexo博客搭建成功了。<br>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-blog.png" alt></p>
<h4 id="三、将本地的-Hexo-博客部署到-GitHub-Pages上"><a href="#三、将本地的-Hexo-博客部署到-GitHub-Pages上" class="headerlink" title="三、将本地的 Hexo 博客部署到 GitHub Pages上"></a>三、将本地的 Hexo 博客部署到 GitHub Pages上</h4><p>（1）新建一个仓库，仓库名为bryceustc.github.io（这个仓库的名称必须严格按照 username.github.io 的格式来命名）【前提是你要有一个Github账号】<br>如图所示：（因为我已经创建过这个库了，所以会显示红色警告，只是后来为了截图，重新写一个同名的）</p>
<p><img src="/images/github.png" alt></p>
<p>（2）进入已经创建好的仓库（点击自己的头像，选择Your profile，点击刚创建好的那个仓库进去仓库里面），点击settings，找到GitHub Pages 选项，点击 Choose a theme 选择一个主题（可以选择也可以不选择，根据自己的需求决定是否操作这一步）<br>如图所示：</p>
<p><img src="/images/gitpages.png" alt></p>
<p>（3）配置Git个人信息，在winneyBlog目录下，鼠标右键，选择Git Bash，进入命令窗口，输入下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Github用户名&quot;       &#x2F;&#x2F;自己Github的账号名</span><br><span class="line">git config --global user.email &quot;Github邮箱&quot;        &#x2F;&#x2F;自己注册Github的邮箱地址</span><br></pre></td></tr></table></figure>

<p>（4）生成SSH KEY,意思是生成一个公钥和密钥，因为Github需要一个密钥才能与本地相连接。在命令窗口输入下面的命令，然后需要连续按3次回车生成密钥（每按一次回车你可以看到对应的信息） 【你也可以先查看是否已经有了ssh密钥：cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C  &quot;Github邮箱&quot;        &#x2F;&#x2F;自己注册Github的邮箱地址</span><br></pre></td></tr></table></figure>

<p>如图所示：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh-key.png" alt></p>
<p>（5）生成的SSH KEY会保存到 C:/Users/电脑名用户名/.ssh 目录中（根据你自己电脑用户名，打开对应的目录）</p>
<ul>
<li>打开.ssh 这个目录，打开 id_rsa.pub 文件，复制里面的全部内容（这些内容就是密钥）<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/user-ssh.png" alt></li>
</ul>
<p>（6）在GitHub中添加SSH keys</p>
<ul>
<li><p>打开Github，点击头像，选择Settings；</p>
</li>
<li><p>选择SSH and GPG keys项,点击右上角New SSH key按钮，将刚刚复制到的密钥粘贴到key输入框中，title自己给它命一个名就好<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/add-key.png" alt></p>
</li>
<li><p>最后点击Add Key，如果显示这样的界面，说明SSH KEY 配置成功：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh-keys.png" alt></p>
</li>
</ul>
<p>（7）修改全局配置文件</p>
<ul>
<li><p>在blog文件夹下，找到_config.yml文件；如图所示：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy.png" alt></p>
</li>
<li><p>复制仓库地址：如图所示：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/git-href.png" alt></p>
</li>
<li><p>修改_config.yml文件里的deploy属性(目的是将本地hexo项目放到Github上)如图所示：<br><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy.png" alt></p>
</li>
</ul>
<p><strong>注：</strong>【如果repository中填写的是https协议的，hexo d上传代码到Github时有下面类似错误，可以将repository改为ssh的链接】<br>如图所示：</p>
<p><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy-error.png" alt></p>
<p><img src="https://winney07.github.io/2018/08/01/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh-link.png" alt></p>
<p>（8）安装hexo-deployer-git 插件，目的是将代码快速托管到Github上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>（9）将hexo项目托管到GitHub上（命令可以分开写也可以一起写）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>备注:<br>hexo clean // 清除缓存文件 (db.json) 和已生成的静态文件 (public)</p>
<p>hexo generate // 部署之前预先生成静态文件，简写为hexo g</p>
<p>hexo deploy // 文件生成后立即部署网站，简写为hexo d</p>
<p>（10）在浏览器地址栏输入 <a href="https://username.github.io/" target="_blank" rel="noopener external nofollow noreferrer">https://username.github.io/</a> 即可访问，（username也就是你的Github账户名），如果能够正常访问，并且跟本地hexo项目显示的内容是一样的，那么说明你已经把本地hexo项目部署到Github上了。</p>
<h4 id="四、配置博客的个人信息"><a href="#四、配置博客的个人信息" class="headerlink" title="四、配置博客的个人信息"></a>四、配置博客的个人信息</h4><p>（1）在hexo目录中，找到全局配置文件_config.yml</p>
<p>（2）配置信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html</span><br><span class="line">## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: Bryce&#39;s Blog</span><br><span class="line">subtitle: Learn Everything.</span><br><span class="line">description: A Student From USTC.</span><br><span class="line">author: Bryce</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone: Asia&#x2F;Shanghai</span><br><span class="line"></span><br><span class="line"># URL 博客地址</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: https:&#x2F;&#x2F;bryceustc.github.io&#x2F;</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br><span class="line"></span><br><span class="line"># Directory 目录设置</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads&#x2F;code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link:</span><br><span class="line">  enable: true # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: &#39;&#39;</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: true</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace: &#39;&#39;</span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br><span class="line"></span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default &#x3D; &#39;&#39;)</span><br><span class="line"># per_page: Posts displayed per page. (0 &#x3D; disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#39;&#39;</span><br><span class="line">  per_page: 5 #每页文章数量</span><br><span class="line">  order_by: -date</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Metadata elements</span><br><span class="line">## https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTML&#x2F;Element&#x2F;meta</span><br><span class="line">meta_generator: true</span><br><span class="line"></span><br><span class="line"># Date &#x2F; Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F;</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">## Use post&#39;s date for updated date unless set in front-matter</span><br><span class="line">use_date_for_updated: false</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Include &#x2F; Exclude file(s)</span><br><span class="line">## include:&#x2F;exclude: options only apply to the &#39;source&#x2F;&#39; folder</span><br><span class="line">include:</span><br><span class="line">exclude:</span><br><span class="line">ignore:</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next</span><br><span class="line">plugins: hexo-generate-feed</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;bryceustc&#x2F;bryceustc.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>注意：.yml 文件有严格的格式要求，文件里所有的配置都是：冒号 空格 值，并且冒号是英文状态下的输入。想了解更多的可以前往官网。</p>
<p>（3）在博客目录下，右键点击Git Bash，进去命令窗口，输入下面的命令，即可在浏览器中看到刚刚设置的内容显示在页面中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server    &#x2F;&#x2F;简写为hexo s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/2020/03/18/3_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0~n-1范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2，3，1，0，2，5，3}，那么对应的输出是重复的数字2或者3</p>
<a id="more"></a>

<p>在一个长度为n+1的数组里的所有数字都在1~n范围内。所以数组中至少有一个数是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，输入长度为8的数组{2，3，5，4，3，2，6，7}，那么对应的输出是重复的数字2或者3。</p>
<h2 id="本题考点"><a href="#本题考点" class="headerlink" title="本题考点"></a>本题考点</h2><p>  1). 一维数组的理解，一维数组在内存中占据连续空间，可以根据下标定位对应的元素</p>
<p>  2). 二分查找算法的理解，快速正确实现二分查找</p>
<p>  3). 时间复杂度与空间复杂度的理解</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>  1). 把输入的数组进行排序，排序后再判断有无重复数字，时间复杂度为O(nlogn)</p>
<p>  2). 使用哈希表来解决，时间复杂度为O(n)，但空间复杂度也为O(n)</p>
<p>  3). 交换位置重排法，把每个数字放回对应位置的方法。如果出现一个数字无法放回（所在位置已经是对应数字了），那么说明该数字重复，时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>  4). 题目二可以依照题目一的思路来，不过由于不能修改输入数组，所以可以构建一个n+1大小的辅助数组，构建了辅助数组之后可以使用hash表也可以使用换位置的思路来做 </p>
<p>  5). 使用二分的思想来做，二分基数组，但这种方法不能找出所有重复的数字，时间复杂度为O(nlogn)，空间复杂度为O(1)，相当于用时间换取空间</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="方法一：排序后直接查找"><a href="#方法一：排序后直接查找" class="headerlink" title="方法一：排序后直接查找"></a>方法一：排序后直接查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Duplication</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums.empty()||n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> || nums[i] &gt; n - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(nums[i]);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：利用哈希表"><a href="#方法二：利用哈希表" class="headerlink" title="方法二：利用哈希表"></a>方法二：利用哈希表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Duplication</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums.empty() || n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> || nums[i] &gt; n<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                m[i]++;</span><br><span class="line">                <span class="keyword">if</span>(m[i]&gt;<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(i);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法三：交换位置重排"><a href="#方法三：交换位置重排" class="headerlink" title="方法三：交换位置重排"></a>方法三：交换位置重排</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Duplication</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums,<span class="keyword">int</span> n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//异常值检测</span></span><br><span class="line">            <span class="keyword">if</span> (nums.empty() || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//越界检测</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]&lt; <span class="number">0</span> || nums[i] &gt; n<span class="number">-1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//只要当前数值与索引不等，就要一直替换</span></span><br><span class="line">                <span class="keyword">while</span> (nums[i]!=i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//一旦遇到当前的数值与另外一个换位的值相等，就停止，说明找到了重复的数字</span></span><br><span class="line">                    <span class="keyword">if</span> (nums[i] == nums[nums[i]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(nums[i]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        flag = <span class="literal">true</span>;  <span class="comment">//return直接跳出所有循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                    nums[i] = nums[temp];</span><br><span class="line">                    nums[temp] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法四：二分法查找"><a href="#方法四：二分法查找" class="headerlink" title="方法四：二分法查找"></a>方法四：二分法查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ( nums.empty() || n &lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">end</span> = n;</span><br><span class="line">      <span class="keyword">while</span>(<span class="built_in">end</span> &gt; start)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;=start &amp;&amp; nums[i]&lt;=mid)</span><br><span class="line">            &#123;</span><br><span class="line">              m++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; mid - start+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">           start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://blog.csdn.net/hunanchenxingyu/article/details/8101795" target="_blank" rel="noopener external nofollow noreferrer">循环结构中break、continue、return和exit的区别</a></p>
</li>
<li><p><a href="https://blog.csdn.net/zolalad/article/details/11848739" target="_blank" rel="noopener external nofollow noreferrer">时间复杂度和空间复杂度</a></p>
</li>
<li><p><a href="https://github.com/bryceustc/LeetCode_Note/blob/master/cpp/Find-First-And-Last-Position-Of-Element-In-Sorted-Array/BinarySearch.md" target="_blank" rel="noopener external nofollow noreferrer">二分查找算法</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
