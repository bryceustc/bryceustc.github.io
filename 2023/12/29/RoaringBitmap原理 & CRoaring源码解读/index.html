<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bryceustc.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="RoaringBitMap原理Roaring Bitmap实现的主要思路是将32位无符号整数（0~4294967295）分成高16位和低16位两部分。通过高 16 位找到该数据存储在哪个桶中（高 16 位可以划分 216个桶），把剩余的低 16 位放入该桶对应的 Container 中。 每个桶都有对应的 Container，不同的 Container 存储方式不同。依据不同的场景，主要有 2 种">
<meta property="og:type" content="article">
<meta property="og:title" content="RoaringBitmap原理 &amp; CRoaring源码解读 &amp; 优化寻址">
<meta property="og:url" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/index.html">
<meta property="og:site_name" content="Bryce&#39;s Blog">
<meta property="og:description" content="RoaringBitMap原理Roaring Bitmap实现的主要思路是将32位无符号整数（0~4294967295）分成高16位和低16位两部分。通过高 16 位找到该数据存储在哪个桶中（高 16 位可以划分 216个桶），把剩余的低 16 位放入该桶对应的 Container 中。 每个桶都有对应的 Container，不同的 Container 存储方式不同。依据不同的场景，主要有 2 种">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/1.png">
<meta property="og:image" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/2.png">
<meta property="og:image" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/4.png">
<meta property="og:image" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/5.png">
<meta property="og:image" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/6.png">
<meta property="og:image" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/7.png">
<meta property="og:image" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/8.png">
<meta property="og:image" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/9.png">
<meta property="og:image" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/10.png">
<meta property="og:image" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/11.png">
<meta property="og:image" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/12.png">
<meta property="og:image" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/13.png">
<meta property="article:published_time" content="2023-12-29T14:53:22.000Z">
<meta property="article:modified_time" content="2023-12-29T14:53:22.000Z">
<meta property="article:author" content="Bryce">
<meta property="article:tag" content="RoaringBitmap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/1.png">

<link rel="canonical" href="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>RoaringBitmap原理 & CRoaring源码解读 & 优化寻址 | Bryce's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/bryceustc" class="github-corner" aria-label="View source on GitHub"><svg width="100" height="100" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bryce's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Learn Everything.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jfif">
      <meta itemprop="name" content="Bryce">
      <meta itemprop="description" content="书写是对思维的缓存">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bryce's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RoaringBitmap原理 & CRoaring源码解读 & 优化寻址
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-29 22:53:22" itemprop="dateCreated datePublished" datetime="2023-12-29T22:53:22+08:00">2023-12-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RoaringBitmap/" itemprop="url" rel="index"><span itemprop="name">RoaringBitmap</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>29k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="RoaringBitMap原理"><a href="#RoaringBitMap原理" class="headerlink" title="RoaringBitMap原理"></a>RoaringBitMap原理</h2><p>Roaring Bitmap实现的主要思路是将32位无符号整数（0~4294967295）分成高16位和低16位两部分。通过高 16 位找到该数据存储在哪个桶中（高 16 位可以划分 2<sup>16</sup>个桶），把剩余的低 16 位放入该桶对应的 Container 中。</p>
<p>每个桶都有对应的 Container，不同的 Container 存储方式不同。依据不同的场景，主要有 2 种不同的 Container，分别是 Array Container 和 Bitmap Container。Array Container 存放稀疏的数据，Bitmap Container 存放稠密的数据。若一个 Container 里面的元素数量小于 4096，使用 Array Container 来存储。当 Array Container 超过最大容量 4096 时，会转换为 Bitmap Container。<br><span id="more"></span><br>简单举2个例子，说明rbm是如何存储数据的。</p>
<p>例1：0x00020032（十进制131122）放入一个 RBM 的过程如下图所示：</p>
<p><img src="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/1.png" alt></p>
<p>131122 的高 16 位是 0002，找到对应的桶 0x0002。在桶对应的 Container 中存储低 16 位，因为 Container 元素个数不足 4096，因此是一个 Array Container。低 16 位为 0032（十进制为50）, 在 Array Container 中二分查找找到相应的位置插入即可（如上图50的位置）。相较于纯Bitmap 需要占用 16K (131122/8/1024) 内存来存储这个数，而这种存储实际只占用了4B（桶中占 2 B，Container中占 2 B，不考虑数组的初始容量）。</p>
<p>例2：0xFFFF3ACB（十进制4294916811）放入一个 RBM 的过程如下图所示：</p>
<p><img src="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/2.png" alt></p>
<p>4294916811 的高 16 位是 FFFF，找到对应的桶 0xFFFF。在桶对应的 Container 中存储低 16 位，因为 Container 中元素个数已经超过 4096，底层是一个 Bitmap Container。低 16 位为 3ACB（十进制为15051）, 因此在 Bitmap Container 中通过下标直接寻址找到相应的位置，将其置为 1 即可（如上图15051的位置）。</p>
<p>由于每个 Bitmap Container 需要处理低 16 位数据，使用 Bitmap 来存储需要 8192 Bytes（2^16/8）, 而一个 long 值占 8 个 Bytes，所以数组大小为 1024。因此一个 Bitmap Container 固定占用内存 8 KB。</p>
<h2 id="RoaringBitmap数据结构"><a href="#RoaringBitmap数据结构" class="headerlink" title="RoaringBitmap数据结构"></a>RoaringBitmap数据结构</h2><p>RoaringBitmap的基本构成如下:首先是一个RoaringArray，名字是high_low_container，该结构中存储了每个uint32整数的高16bit的索引keys以及具体存储数字的container。</p>
<h3 id="RoaringArray"><a href="#RoaringArray" class="headerlink" title="RoaringArray"></a>RoaringArray</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">roaring_bitmap_s</span> &#123;</span><br><span class="line">    <span class="type">roaring_array_t</span> high_low_container;</span><br><span class="line">&#125; <span class="type">roaring_bitmap_t</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">roaring_array_s</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> size;</span><br><span class="line">    <span class="type">int32_t</span> allocation_size;</span><br><span class="line">    ROARING_CONTAINER_T **containers;  <span class="comment">// Use container_t in non-API files!</span></span><br><span class="line">    <span class="type">uint16_t</span> *keys;</span><br><span class="line">    <span class="type">uint8_t</span> *typecodes;</span><br><span class="line">    <span class="type">uint8_t</span> flags;</span><br><span class="line">&#125; <span class="type">roaring_array_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>roaring_array：每个RBM都包含了一个roaring_array，名字是high_low_container，该结构主要有下面几个重要属性：<ul>
<li>keys：short数组，用来存储高16位作为索引</li>
<li>containers：container数组，用来存储低16位数据</li>
<li>typecodes：可理解为container type的数组，标识container的类型</li>
<li>size：可理解为rbm包含的key-value有效数量</li>
</ul>
</li>
</ul>
<p>PS：keys数组和containers数组是一一对应的，且keys永远保证有序，这是为了之后<strong>索引的二分查找</strong></p>
<h3 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h3><p>Container用于存储低16位的数据，根据数据量以及疏密程度分为以下3个容器：</p>
<ul>
<li>ArrayContainer</li>
<li>BitmapContainer</li>
<li>RunContainer</li>
</ul>
<h4 id="1、ArrayContainer"><a href="#1、ArrayContainer" class="headerlink" title="1、ArrayContainer"></a>1、ArrayContainer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayContainer允许的最大数据量</span></span><br><span class="line"><span class="keyword">enum</span> &#123; DEFAULT_MAX_SIZE = <span class="number">4096</span> &#125;;<span class="comment">/* Containers with DEFAULT_MAX_SIZE or less integers should be arrays */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct array_container - sparse representation of a bitmap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @cardinality: number of indices in `array` (and the bitmap)</span></span><br><span class="line"><span class="comment"> * @capacity:    allocated size of `array`</span></span><br><span class="line"><span class="comment"> * @array:       sorted list of integers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">STRUCT_CONTAINER</span>(array_container_s) &#123;</span><br><span class="line">    <span class="type">int32_t</span> cardinality;</span><br><span class="line">    <span class="type">int32_t</span> capacity;</span><br><span class="line">    <span class="type">uint16_t</span> *array;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Array Container 是 Roaring Bitmap 初始化默认的 Container。Array Container 适合存放稀疏的数据，其内部数据结构是一个<strong>有序的 short 数组</strong>。数组初始容量为 4，数组最大容量为 4096，存储元素始终有序，方便二分查找，<strong>查询复杂度O(logn)</strong></p>
<h4 id="2、BitmapContainer"><a href="#2、BitmapContainer" class="headerlink" title="2、BitmapContainer"></a>2、BitmapContainer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BITSET_CONTAINER_SIZE_IN_WORDS = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) / <span class="number">64</span>,</span><br><span class="line">    BITSET_UNKNOWN_CARDINALITY = <span class="number">-1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">STRUCT_CONTAINER</span>(bitset_container_s) &#123;</span><br><span class="line">    <span class="type">int32_t</span> cardinality;</span><br><span class="line">    <span class="type">uint64_t</span> *words;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BitmapContainer采用<strong>long数组</strong>存储低16位数据，这就是一个未压缩的普通Bitmap，每一个bit位置代表一个数字。每一个Container最多可以处理2<sup>16</sup>个数字，基于位图的原理需要2<sup>16</sup>个bit，每个long是8字节64bit，所以数组大小是2<sup>16</sup>/64=1024，始终<strong>占据8kb</strong>的空间，<strong>查询复杂度O(1)</strong></p>
<h4 id="3、RunContainer"><a href="#3、RunContainer" class="headerlink" title="3、RunContainer"></a>3、RunContainer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct rle16_s - run length pair</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @value:  start position of the run</span></span><br><span class="line"><span class="comment"> * @length: length of the run is `length + 1`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An RLE pair &#123;v, l&#125; would represent the integers between the interval</span></span><br><span class="line"><span class="comment"> * [v, v+l+1], e.g. &#123;3, 2&#125; = [3, 4, 5].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rle16_s</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> value;</span><br><span class="line">    <span class="type">uint16_t</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct run_container_s - run container bitmap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @n_runs:   number of rle_t pairs in `runs`.</span></span><br><span class="line"><span class="comment"> * @capacity: capacity in rle_t pairs `runs` can hold.</span></span><br><span class="line"><span class="comment"> * @runs:     pairs of rle_t.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">STRUCT_CONTAINER</span>(run_container_s) &#123;</span><br><span class="line">    <span class="type">int32_t</span> n_runs;</span><br><span class="line">    <span class="type">int32_t</span> capacity;</span><br><span class="line">    <span class="type">rle16_t</span> *runs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要解决了连续1的情况，例如15、16、17、18可以被优化成15,3。RunContainer中的关键变量为value，length，类型是short。其中，value是具体数值，length为value往后的连续个数。</p>
<p>例如：3,4,5,10,20,21,22,23这样一组数据会被优化成3,2,10,0,20,3，原理就是记录初始数字以及连续的数量，并把压缩后的数据记录在short数组中。这种压缩方式对于数据的疏密程度非常敏感，举两个最极端的例子：如果这个Container中所有数据都是连续的，也就是[0,1,2…..65535]，压缩后为0,65535，即2个short，4字节。若这个container中所有数据都是间断的（都是偶数或奇数），也就是[0,2,4,6….65532,65534]，压缩后为0,0,2,0…..65534,0，这不仅没有压缩反而膨胀了一倍，65536个short，即128kb</p>
<p>因此是否选择RunContainer是需要判断的，RBM提供了一个<strong>转化方法runOptimize()</strong>用于对比和其他两种Container的空间大小，若占据优势则会进行转化。</p>
<p><strong>各个Container之间比较如下</strong>：</p>
<p><strong>1. 读取时间</strong></p>
<p>只有BitmapContainer可根据下标直接寻址，复杂度为O(1)，ArrayContainer和RunContainer都需要二分查找，复杂度O(log n)</p>
<p><strong>2. 内存占用</strong><br> <img src="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/4.png" alt></p>
<h2 id="RoaringBitmap源码分析"><a href="#RoaringBitmap源码分析" class="headerlink" title="RoaringBitmap源码分析"></a>RoaringBitmap源码分析</h2><p>CRoaring源码：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/RoaringBitmap/CRoaring">https://github.com/RoaringBitmap/CRoaring</a></p>
<h3 id="1、Add"><a href="#1、Add" class="headerlink" title="1、Add"></a>1、Add</h3><p>Add大致流程：</p>
<ol>
<li><p>二分判断新加的Value的高16位是否存在，不存在新建一个ArrayContainer，然后添加低16位数值即可</p>
</li>
<li><p>若存在，确定低16位Container位置后，判断对应Container的类型：</p>
<ol>
<li><p>Array Container：</p>
<ul>
<li><p>通过二分查找Value低16位所在的ArrayContainer中的位置，若存在说明已经添加了则不处理</p>
</li>
<li><p>不存在则对元素容量Cardinality进行判断，决定是否需要扩容或者升级为BitmapContainer</p>
</li>
<li><p>将ArrayContainer中insert_idx之后的子数组后移一位，将数据插入，形成新的Array数组</p>
</li>
</ul>
</li>
<li><p>Bitmap Container</p>
<ul>
<li><p>通过pos/64找到bitmap中的long数组中的位置得到原值old_word</p>
</li>
<li><p>old_word | (1 &lt;&lt; (pos%64) ) 得到new_word并赋值</p>
</li>
<li><p>更新Cardinality</p>
<h4 id="高16位Add"><a href="#高16位Add" class="headerlink" title="高16位Add"></a>高16位Add</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">roaring_bitmap_add</span><span class="params">(<span class="type">roaring_bitmap_t</span> *r, <span class="type">uint32_t</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">roaring_array_t</span> *ra = &amp;r-&gt;high_low_container;</span><br><span class="line">		<span class="comment">// 获取待插入数val的高16位</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint16_t</span> hb = val &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 计算高16位对应的索引值的下标位置(底层是个二分查找)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i = <span class="built_in">ra_get_index</span>(ra, hb);</span><br><span class="line">    <span class="type">uint8_t</span> typecode;</span><br><span class="line"> 	  <span class="comment">// 索引下标大于0说明该索引已存在且创建了对应的Container，则将低16位存入该Container中</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ra_unshare_container_at_index</span>(ra, i);</span><br><span class="line">        <span class="type">container_t</span> *container =</span><br><span class="line">            <span class="built_in">ra_get_container_at_index</span>(ra, i, &amp;typecode);</span><br><span class="line">        <span class="type">uint8_t</span> newtypecode = typecode;</span><br><span class="line">        <span class="type">container_t</span> *container2 =</span><br><span class="line">            <span class="built_in">container_add</span>(container, val &amp; <span class="number">0xFFFF</span>, typecode, &amp;newtypecode);</span><br><span class="line">        <span class="keyword">if</span> (container2 != container) &#123;</span><br><span class="line">            <span class="built_in">container_free</span>(container, typecode);</span><br><span class="line">            <span class="built_in">ra_set_container_at_index</span>(&amp;r-&gt;high_low_container, i, container2,</span><br><span class="line">                                      newtypecode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 若索引下标小于0说明该索引不存在，则直接创建一个ArrayContainer并将低16位放入其中</span></span><br><span class="line">        <span class="type">array_container_t</span> *newac = <span class="built_in">array_container_create</span>();</span><br><span class="line">        <span class="type">container_t</span> *container = <span class="built_in">container_add</span>(newac, val &amp; <span class="number">0xFFFF</span>,</span><br><span class="line">                                        ARRAY_CONTAINER_TYPE, &amp;typecode);</span><br><span class="line">        <span class="comment">// we could just assume that it stays an array container</span></span><br><span class="line">        <span class="built_in">ra_insert_new_key_value_at</span>(&amp;r-&gt;high_low_container, -i - <span class="number">1</span>, hb,</span><br><span class="line">                                   container, typecode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="低16位Add"><a href="#低16位Add" class="headerlink" title="低16位Add"></a>低16位Add</h4><h5 id="Array-Container-Add"><a href="#Array-Container-Add" class="headerlink" title="Array Container Add"></a>Array Container Add</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add value to the set if final cardinality doesn&#x27;t exceed max_cardinality.</span></span><br><span class="line"><span class="comment"> * Return code:</span></span><br><span class="line"><span class="comment"> * 1  -- value was added</span></span><br><span class="line"><span class="comment"> * 0  -- value was already present</span></span><br><span class="line"><span class="comment"> * -1 -- value was not added because cardinality would exceed max_cardinality</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">array_container_try_add</span><span class="params">(<span class="type">array_container_t</span> *arr, <span class="type">uint16_t</span> value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">int32_t</span> max_cardinality)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int32_t</span> cardinality = arr-&gt;cardinality;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// best case, we can append.</span></span><br><span class="line">  	<span class="comment">// 两种场景可以不走二分查找：</span></span><br><span class="line">  	<span class="comment">// 1、基数为0 </span></span><br><span class="line">    <span class="comment">// 2、当前值大于容器中的最大值，因为array是有序的，最后一个即最大值</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">array_container_empty</span>(arr) || arr-&gt;array[cardinality - <span class="number">1</span>] &lt; value) &amp;&amp;</span><br><span class="line">        cardinality &lt; max_cardinality) &#123;</span><br><span class="line">        <span class="built_in">array_container_append</span>(arr, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 通过二分查找找到对应的插入位置</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int32_t</span> loc = <span class="built_in">binarySearch</span>(arr-&gt;array, cardinality, value);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 存在则不处理直接返回（去重效果）</span></span><br><span class="line">    <span class="keyword">if</span> (loc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cardinality &lt; max_cardinality) &#123;</span><br><span class="line">      	<span class="comment">// 判断是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array_container_full</span>(arr)) &#123;</span><br><span class="line">            <span class="built_in">array_container_grow</span>(arr, arr-&gt;capacity + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> <span class="type">int32_t</span> insert_idx = -loc - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 通过拷贝数组将val插入array数组</span></span><br><span class="line">        <span class="built_in">memmove</span>(arr-&gt;array + insert_idx + <span class="number">1</span>, arr-&gt;array + insert_idx,</span><br><span class="line">                (cardinality - insert_idx) * <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">        arr-&gt;array[insert_idx] = value;</span><br><span class="line">        arr-&gt;cardinality++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">//容量大于等于4096需转化为BitmapContainer，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>add流程：</strong></p>
<ol>
<li>通过二分查找找到val所在的array中的位置，若存在则不处理，不存在则进入下一步。</li>
<li>对cardinality进行判断，决定是否需要升级为BitmapContainer或者扩容。</li>
<li>将array中insert_idx之后的子数组后移一位，将数据插入，形成新的Array数组。</li>
</ol>
<h5 id="Bitmap-Container-Add"><a href="#Bitmap-Container-Add" class="headerlink" title="Bitmap Container Add"></a>Bitmap Container Add</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file contains grubby stuff that must know impl. details of all container</span></span><br><span class="line"><span class="comment">// types.</span></span><br><span class="line"><span class="function"><span class="type">bitset_container_t</span> *<span class="title">bitset_container_from_array</span><span class="params">(<span class="type">const</span> <span class="type">array_container_t</span> *ac)</span> </span>&#123;</span><br><span class="line">    <span class="type">bitset_container_t</span> *ans = <span class="built_in">bitset_container_create</span>();</span><br><span class="line">  	<span class="comment">// 获取array container的cardinality</span></span><br><span class="line">    <span class="type">int</span> limit = <span class="built_in">array_container_cardinality</span>(ac);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; ++i) <span class="built_in">bitset_container_set</span>(ans, ac-&gt;array[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Set the ith bit.  */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">bitset_container_set</span><span class="params">(<span class="type">bitset_container_t</span> *bitset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint16_t</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> shift = <span class="number">6</span>;</span><br><span class="line">    <span class="type">uint64_t</span> offset;</span><br><span class="line">    <span class="type">uint64_t</span> p = pos;</span><br><span class="line">    <span class="comment">// 利用汇编指令右移6位，相当于/64，目的是找到第几个long</span></span><br><span class="line">    <span class="built_in">ASM_SHIFT_RIGHT</span>(p, shift, offset);</span><br><span class="line">    <span class="type">uint64_t</span> load = bitset-&gt;words[offset];</span><br><span class="line">  	<span class="comment">// 找到对应的long的旧值，对应位置set为1后，与旧值取或得到新值</span></span><br><span class="line">    <span class="built_in">ASM_SET_BIT_INC_WAS_CLEAR</span>(load, p, bitset-&gt;cardinality);</span><br><span class="line">    bitset-&gt;words[offset] = load;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add `pos&#x27; to `bitset&#x27;. Returns true if `pos&#x27; was not present. Might be slower</span></span><br><span class="line"><span class="comment"> * than bitset_container_set.  */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">bitset_container_add</span><span class="params">(<span class="type">bitset_container_t</span> *bitset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint16_t</span> pos)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 右移6位，取到对应long数组的旧值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> old_word = bitset-&gt;words[pos &gt;&gt; <span class="number">6</span>];</span><br><span class="line">  	<span class="comment">// 相当于%63，取到是long的第几位</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> index = pos &amp; <span class="number">63</span>;</span><br><span class="line">  	<span class="comment">// 按位或得到新值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> new_word = old_word | (<span class="built_in">UINT64_C</span>(<span class="number">1</span>) &lt;&lt; index);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> increment = (old_word ^ new_word) &gt;&gt; index;</span><br><span class="line">    bitset-&gt;cardinality += (<span class="type">uint32_t</span>)increment;</span><br><span class="line">    bitset-&gt;words[pos &gt;&gt; <span class="number">6</span>] = new_word;</span><br><span class="line">    <span class="keyword">return</span> increment &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>add流程：</strong></p>
<ol>
<li>通过pos/64找到bitmap中的long数组中的位置得到原值old_word。</li>
<li>old_word | (1 &lt;&lt; (pos%64) ) 得到new_word。</li>
<li>改变cardinality。</li>
</ol>
<h3 id="2、And"><a href="#2、And" class="headerlink" title="2、And"></a>2、And</h3><p><strong>And流程：</strong></p>
<ol>
<li>获取high_low_container，判断keys数组中元素是否相等，即判断高16位</li>
<li>在高16位元素相等的情况下，去判断对应Container中存储的低16位元素：<ol>
<li>Bitmap Container &amp; Bitmap Container<ul>
<li>快速获取两个Bitmap求交后的元素个数（底层AVX2指令集优化）</li>
<li>若求交后元素个数大于4096，用Bitmap Container存储，否则用Array Container存储。</li>
</ul>
</li>
<li>Array Container &amp; Array Container<ul>
<li>计算结果集的cardinality的上限，并初始化</li>
<li>两个Array Container元素相差较大，差距大于64倍的时候，会调用intersect_skewed_uint16，步长为2的幂次方的形式递增，加速跳过不相交的元素。如果相差不大的时候，调用intersect_uint16步长为1进行比较（底层就是两个有序数组求交集） 或者intersect_vector16进行AVX2指令集加速</li>
</ul>
</li>
<li>Bitmap Container &amp; Array Container<ul>
<li>给结果数组dst申请扩容，初始长度为Array Container的array的长度</li>
<li>for循环遍历Array Container，依次其中的元素是否在Bitmap Container中存在，如果存在的话，则更新到结果answer中，并更新Cardinality。</li>
</ul>
</li>
<li>Array Container &amp; Bitmap Container<ul>
<li>同上</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="高16位-And"><a href="#高16位-And" class="headerlink" title="高16位 And"></a>高16位 And</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">roaring_bitmap_t</span> *<span class="title">roaring_bitmap_and</span><span class="params">(<span class="type">const</span> <span class="type">roaring_bitmap_t</span> *x1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> <span class="type">roaring_bitmap_t</span> *x2)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> result_type = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取两个rbm的对应high_low_container的size</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> length1 = x1-&gt;high_low_container.size,</span><br><span class="line">              length2 = x2-&gt;high_low_container.size;</span><br><span class="line">    <span class="comment">// 取两者较小的length</span></span><br><span class="line">    <span class="type">uint32_t</span> neededcap = length1 &gt; length2 ? length2 : length1;</span><br><span class="line">  	<span class="comment">// 构建一个新的answer rbm</span></span><br><span class="line">    <span class="type">roaring_bitmap_t</span> *answer = <span class="built_in">roaring_bitmap_create_with_capacity</span>(neededcap);</span><br><span class="line">    <span class="built_in">roaring_bitmap_set_copy_on_write</span>(answer, <span class="built_in">is_cow</span>(x1) &amp;&amp; <span class="built_in">is_cow</span>(x2));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pos1 &lt; length1 &amp;&amp; pos2 &lt; length2) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint16_t</span> s1 = <span class="built_in">ra_get_key_at_index</span>(&amp;x1-&gt;high_low_container, pos1);</span><br><span class="line">        <span class="type">const</span> <span class="type">uint16_t</span> s2 = <span class="built_in">ra_get_key_at_index</span>(&amp;x2-&gt;high_low_container, pos2);</span><br><span class="line">      	<span class="comment">// 高16位相等</span></span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> type1, type2;</span><br><span class="line">          	<span class="comment">// 获取对应的container</span></span><br><span class="line">            <span class="type">container_t</span> *c1 = <span class="built_in">ra_get_container_at_index</span>(</span><br><span class="line">                                    &amp;x1-&gt;high_low_container, pos1, &amp;type1);</span><br><span class="line">            <span class="type">container_t</span> *c2 = <span class="built_in">ra_get_container_at_index</span>(</span><br><span class="line">                                    &amp;x2-&gt;high_low_container, pos2, &amp;type2);</span><br><span class="line">            <span class="comment">// 两个container之间求and</span></span><br><span class="line">            <span class="type">container_t</span> *c = <span class="built_in">container_and</span>(c1, type1, c2, type2, &amp;result_type);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">container_nonzero_cardinality</span>(c, result_type)) &#123;</span><br><span class="line">                <span class="built_in">ra_append</span>(&amp;answer-&gt;high_low_container, s1, c, result_type);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">container_free</span>(c, result_type);  <span class="comment">// otherwise: memory leak!</span></span><br><span class="line">            &#125;</span><br><span class="line">            ++pos1;</span><br><span class="line">            ++pos2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s1 &lt; s2) &#123;  <span class="comment">// s1 &lt; s2</span></span><br><span class="line">          	<span class="comment">// 底层是二分查找，找到第一个x1中的第一个大于等于s2的位置</span></span><br><span class="line">            pos1 = <span class="built_in">ra_advance_until</span>(&amp;x1-&gt;high_low_container, s2, pos1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// s1 &gt; s2</span></span><br><span class="line">            pos2 = <span class="built_in">ra_advance_until</span>(&amp;x2-&gt;high_low_container, s1, pos2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="低16位And"><a href="#低16位And" class="headerlink" title="低16位And"></a>低16位And</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">container_t</span> *<span class="title">container_and</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">container_t</span> *c1, <span class="type">uint8_t</span> type1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">container_t</span> *c2, <span class="type">uint8_t</span> type2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint8_t</span> *result_type</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line">    c1 = <span class="built_in">container_unwrap_shared</span>(c1, &amp;type1);</span><br><span class="line">    c2 = <span class="built_in">container_unwrap_shared</span>(c2, &amp;type2);</span><br><span class="line">    <span class="type">container_t</span> *result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 不同container之间的组合</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">PAIR_CONTAINER_TYPES</span>(type1, type2)) &#123;</span><br><span class="line">    		<span class="comment">// 1、两个Bitmap Container 求交</span></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">CONTAINER_PAIR</span><span class="params">(BITSET,BITSET)</span>:</span></span><br><span class="line"><span class="function">            *result_type =</span> <span class="built_in">bitset_bitset_container_intersection</span>(</span><br><span class="line">                                <span class="built_in">const_CAST_bitset</span>(c1),</span><br><span class="line">                                <span class="built_in">const_CAST_bitset</span>(c2), &amp;result)</span><br><span class="line">                                    ? BITSET_CONTAINER_TYPE</span><br><span class="line">                                    : ARRAY_CONTAINER_TYPE;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">// 2、两个Array Container 求交</span></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">CONTAINER_PAIR</span><span class="params">(ARRAY,ARRAY)</span>:</span></span><br><span class="line"><span class="function">            result =</span> <span class="built_in">array_container_create</span>();</span><br><span class="line">            <span class="built_in">array_container_intersection</span>(<span class="built_in">const_CAST_array</span>(c1),</span><br><span class="line">                                         <span class="built_in">const_CAST_array</span>(c2),</span><br><span class="line">                                         <span class="built_in">CAST_array</span>(result));</span><br><span class="line">            *result_type = ARRAY_CONTAINER_TYPE;  <span class="comment">// never bitset</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">// 3、两个Run Container 求交</span></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">CONTAINER_PAIR</span><span class="params">(RUN,RUN)</span>:</span></span><br><span class="line"><span class="function">            result =</span> <span class="built_in">run_container_create</span>();</span><br><span class="line">            <span class="built_in">run_container_intersection</span>(<span class="built_in">const_CAST_run</span>(c1),</span><br><span class="line">                                       <span class="built_in">const_CAST_run</span>(c2),</span><br><span class="line">                                       <span class="built_in">CAST_run</span>(result));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">convert_run_to_efficient_container_and_free</span>(</span><br><span class="line">                        <span class="built_in">CAST_run</span>(result), result_type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、Bitmap Container 和 Array Container求交</span></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">CONTAINER_PAIR</span><span class="params">(BITSET,ARRAY)</span>:</span></span><br><span class="line"><span class="function">            result =</span> <span class="built_in">array_container_create</span>();</span><br><span class="line">            <span class="built_in">array_bitset_container_intersection</span>(<span class="built_in">const_CAST_array</span>(c2),</span><br><span class="line">                                                <span class="built_in">const_CAST_bitset</span>(c1),</span><br><span class="line">                                                <span class="built_in">CAST_array</span>(result));</span><br><span class="line">            *result_type = ARRAY_CONTAINER_TYPE;  <span class="comment">// never bitset</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">// 5、Array Container 和 Bitmap Container求交</span></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">CONTAINER_PAIR</span><span class="params">(ARRAY,BITSET)</span>:</span></span><br><span class="line"><span class="function">            result =</span> <span class="built_in">array_container_create</span>();</span><br><span class="line">            *result_type = ARRAY_CONTAINER_TYPE;  <span class="comment">// never bitset</span></span><br><span class="line">            <span class="built_in">array_bitset_container_intersection</span>(<span class="built_in">const_CAST_array</span>(c1),</span><br><span class="line">                                                <span class="built_in">const_CAST_bitset</span>(c2),</span><br><span class="line">                                                <span class="built_in">CAST_array</span>(result));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">            __builtin_unreachable();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Bitmap-Container-amp-Bitmap-Container"><a href="#Bitmap-Container-amp-Bitmap-Container" class="headerlink" title="Bitmap Container &amp; Bitmap Container"></a>Bitmap Container &amp; Bitmap Container</h5><p>两个Bitmap Container求And流程：</p>
<ol>
<li>快速获取两个Bitmap求交后的元素个数</li>
<li>若求交后元素个数大于4096，用Bitmap Container存储，否则用Array Container存储。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bitset_bitset_container_intersection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">bitset_container_t</span> *src_1, <span class="type">const</span> <span class="type">bitset_container_t</span> *src_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">container_t</span> **dst</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 计算两个bitmap求交后的元素个数（avx2指令集优化）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> newCardinality = <span class="built_in">bitset_container_and_justcard</span>(src_1, src_2);</span><br><span class="line">    <span class="comment">// 求交后元素个数大于4096</span></span><br><span class="line">    <span class="keyword">if</span> (newCardinality &gt; DEFAULT_MAX_SIZE) &#123;</span><br><span class="line">    		<span class="comment">// 创建一个新的bitmap container</span></span><br><span class="line">        *dst = <span class="built_in">bitset_container_create</span>();</span><br><span class="line">        <span class="keyword">if</span> (*dst != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        		<span class="comment">// 成为</span></span><br><span class="line">            <span class="built_in">bitset_container_and_nocard</span>(src_1, src_2, <span class="built_in">CAST_bitset</span>(*dst));</span><br><span class="line">            <span class="built_in">CAST_bitset</span>(*dst)-&gt;cardinality = newCardinality;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// it is a bitset</span></span><br><span class="line">    &#125;</span><br><span class="line">    *dst = <span class="built_in">array_container_create_given_capacity</span>(newCardinality);</span><br><span class="line">    <span class="keyword">if</span> (*dst != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">CAST_array</span>(*dst)-&gt;cardinality = newCardinality;</span><br><span class="line">        <span class="comment">// 两个Bitmap Container求交集，并输出到数组</span></span><br><span class="line">        <span class="built_in">bitset_extract_intersection_setbits_uint16</span>(</span><br><span class="line">            src_1-&gt;words, src_2-&gt;words, BITSET_CONTAINER_SIZE_IN_WORDS,</span><br><span class="line">            <span class="built_in">CAST_array</span>(*dst)-&gt;array, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// not a bitset</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个Bitmap的交集输出到数组，复杂度为二进制中1的位数。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">bitset_extract_intersection_setbits_uint16</span><span class="params">(<span class="type">const</span> <span class="type">uint64_t</span> * __restrict__ words1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">const</span> <span class="type">uint64_t</span> * __restrict__ words2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">size_t</span> length, <span class="type">uint16_t</span> *out,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">uint16_t</span> base)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> outpos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      	<span class="comment">// 求交</span></span><br><span class="line">        <span class="type">uint64_t</span> w = words1[i] &amp; words2[i];</span><br><span class="line">        <span class="keyword">while</span> (w != <span class="number">0</span>) &#123;</span><br><span class="line">          	<span class="comment">// 获取最低位的1</span></span><br><span class="line">            <span class="type">uint64_t</span> t = w &amp; (~w + <span class="number">1</span>);</span><br><span class="line">          	<span class="comment">// 获取有多少个0</span></span><br><span class="line">            <span class="type">int</span> r = __builtin_ctzll(w);</span><br><span class="line">          	<span class="comment">// 后边有几个0就表示真正的数字几</span></span><br><span class="line">            out[outpos++] = r + base;</span><br><span class="line">          	<span class="comment">// 异或，便于取下一个1</span></span><br><span class="line">            w ^= t;</span><br><span class="line">        &#125;</span><br><span class="line">        base += <span class="number">64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outpos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Array-Container-amp-Array-Container"><a href="#Array-Container-amp-Array-Container" class="headerlink" title="Array Container &amp; Array Container"></a>Array Container &amp; Array Container</h5><p>两个Array Container求And流程：</p>
<ol>
<li>首先计算结果集的cardinality的上限，并初始化</li>
<li>两个Array Container元素相差较大，差距大于64倍的时候，会调用intersect_skewed_uint16，步长为2的幂次方的形式递增，加速跳过不相交的元素。如果相差不大的时候，调用intersect_uint16步长为1进行比较（底层就是两个有序数组求交集） 或者intersect_vector16进行avx2指令集加速。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">array_container_intersection</span><span class="params">(<span class="type">const</span> <span class="type">array_container_t</span> *array1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> <span class="type">array_container_t</span> *array2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">array_container_t</span> *out)</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> card_1 = array1-&gt;cardinality, card_2 = array2-&gt;cardinality,</span><br><span class="line">            min_card = <span class="built_in">minimum_int32</span>(card_1, card_2);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> threshold = <span class="number">64</span>;  <span class="comment">// subject to tuning</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CROARING_IS_X64</span></span><br><span class="line">    <span class="keyword">if</span> (out-&gt;capacity &lt; min_card) &#123;</span><br><span class="line">      <span class="comment">// 申请扩容</span></span><br><span class="line">      <span class="built_in">array_container_grow</span>(out, min_card + <span class="built_in">sizeof</span>(__m128i) / <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>),</span><br><span class="line">        <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (out-&gt;capacity &lt; min_card) &#123;</span><br><span class="line">      <span class="built_in">array_container_grow</span>(out, min_card, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="comment">// 两个Array Container元素相差较大，64倍的时候</span></span><br><span class="line">  	<span class="comment">// 步长为2的幂次方的形式递增，可以加速跳过不相交的元素</span></span><br><span class="line">    <span class="keyword">if</span> (card_1 * threshold &lt; card_2) &#123;</span><br><span class="line">        out-&gt;cardinality = <span class="built_in">intersect_skewed_uint16</span>(</span><br><span class="line">            array1-&gt;array, card_1, array2-&gt;array, card_2, out-&gt;array);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (card_2 * threshold &lt; card_1) &#123;</span><br><span class="line">        out-&gt;cardinality = <span class="built_in">intersect_skewed_uint16</span>(</span><br><span class="line">            array2-&gt;array, card_2, array1-&gt;array, card_1, out-&gt;array);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果两个Array Container的元素相差不大的时候，</span></span><br><span class="line">      <span class="comment">// 调用intersect_uint16步长为1进行比较（底层就是两个有序数组求交集） </span></span><br><span class="line">      <span class="comment">// 或者intersect_vector16内部指令集加速</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CROARING_IS_X64</span></span><br><span class="line">       <span class="keyword">if</span>( <span class="built_in">croaring_avx2</span>() ) &#123;</span><br><span class="line">        out-&gt;cardinality = <span class="built_in">intersect_vector16</span>(</span><br><span class="line">            array1-&gt;array, card_1, array2-&gt;array, card_2, out-&gt;array);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        out-&gt;cardinality = <span class="built_in">intersect_uint16</span>(array1-&gt;array, card_1,</span><br><span class="line">                                            array2-&gt;array, card_2, out-&gt;array);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        out-&gt;cardinality = <span class="built_in">intersect_uint16</span>(array1-&gt;array, card_1,</span><br><span class="line">                                            array2-&gt;array, card_2, out-&gt;array);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Bitmap-Container-amp-Array-Container"><a href="#Bitmap-Container-amp-Array-Container" class="headerlink" title="Bitmap Container &amp; Array Container"></a>Bitmap Container &amp; Array Container</h5><p>Bitmap Container 和 Array Container And流程：</p>
<ol>
<li>首先，给dst申请扩容，初始长度为ArrayContainer的array的长度</li>
<li>然后for循环遍历ArrayContainer，依次其中的元素是否在BitmapContainer中存在，如果存在的话，则更新到结果answer中，并增加cardinality。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">array_bitset_container_intersection</span><span class="params">(<span class="type">const</span> <span class="type">array_container_t</span> *src_1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> <span class="type">bitset_container_t</span> *src_2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">array_container_t</span> *dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dst-&gt;capacity &lt; src_1-&gt;cardinality) &#123;</span><br><span class="line">        <span class="built_in">array_container_grow</span>(dst, src_1-&gt;cardinality, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int32_t</span> newcard = <span class="number">0</span>;  <span class="comment">// dst could be src_1</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int32_t</span> origcard = src_1-&gt;cardinality;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; origcard; ++i) &#123;</span><br><span class="line">        <span class="type">uint16_t</span> key = src_1-&gt;array[i];</span><br><span class="line">        dst-&gt;array[newcard] = key;</span><br><span class="line">        newcard += <span class="built_in">bitset_container_contains</span>(src_2, key);</span><br><span class="line">    &#125;</span><br><span class="line">    dst-&gt;cardinality = newcard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="Array-Container-amp-Bitmap-Container"><a href="#Array-Container-amp-Bitmap-Container" class="headerlink" title="Array Container &amp; Bitmap Container"></a>Array Container &amp; Bitmap Container</h5><p>同上Bitmap Container &amp; Array Container的原理。</p>
<p>同时还有iand，标识inplace的And操作，原理与上述基本类似。</p>
<h3 id="3、Or"><a href="#3、Or" class="headerlink" title="3、Or"></a>3、Or</h3><p><strong>Or流程：</strong></p>
<ol>
<li>获取high_low_container，while循环遍历判断keys数组中元素，在高16位相等的情况下，调用container_or求两个container的并集<ol>
<li>Bitmap Container | Bitmap Container<ul>
<li>两个Bitmap求并集（底层使用AVX2指令集加速批量处理）</li>
</ul>
</li>
<li>Array Container | Array Container<ul>
<li>预估取并集后的元素个数是否小于4096，<ol>
<li>是，则新建一个Array Container</li>
<li>否，则新建一个Bitmap Container</li>
</ol>
</li>
</ul>
</li>
<li>Bitmap Container | Array Container<ol>
<li>Copy一份Bitmap Container</li>
<li>遍历Array Container的元素，添加进新的Bitmap Container</li>
</ol>
</li>
<li>Array Container | Bitmap Container<ul>
<li>同上</li>
</ul>
</li>
</ol>
</li>
<li>高16位元素不相等，直接给answer添加对应的key及container</li>
</ol>
<h4 id="高16位-or"><a href="#高16位-or" class="headerlink" title="高16位 or"></a>高16位 or</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">roaring_bitmap_t</span> *<span class="title">roaring_bitmap_or</span><span class="params">(<span class="type">const</span> <span class="type">roaring_bitmap_t</span> *x1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> <span class="type">roaring_bitmap_t</span> *x2)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> result_type = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> length1 = x1-&gt;high_low_container.size,</span><br><span class="line">              length2 = x2-&gt;high_low_container.size;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == length1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">roaring_bitmap_copy</span>(x2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == length2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">roaring_bitmap_copy</span>(x1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">roaring_bitmap_t</span> *answer =</span><br><span class="line">        <span class="built_in">roaring_bitmap_create_with_capacity</span>(length1 + length2);</span><br><span class="line">    <span class="built_in">roaring_bitmap_set_copy_on_write</span>(answer, <span class="built_in">is_cow</span>(x1) &amp;&amp; <span class="built_in">is_cow</span>(x2));</span><br><span class="line">    <span class="type">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> type1, type2;</span><br><span class="line">    <span class="type">uint16_t</span> s1 = <span class="built_in">ra_get_key_at_index</span>(&amp;x1-&gt;high_low_container, pos1);</span><br><span class="line">    <span class="type">uint16_t</span> s2 = <span class="built_in">ra_get_key_at_index</span>(&amp;x2-&gt;high_low_container, pos2);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      	<span class="comment">// 高16位相等，底层container进行求or</span></span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">            <span class="type">container_t</span> *c1 = <span class="built_in">ra_get_container_at_index</span>(</span><br><span class="line">                                    &amp;x1-&gt;high_low_container, pos1, &amp;type1);</span><br><span class="line">            <span class="type">container_t</span> *c2 = <span class="built_in">ra_get_container_at_index</span>(</span><br><span class="line">                                    &amp;x2-&gt;high_low_container, pos2, &amp;type2);</span><br><span class="line">            <span class="type">container_t</span> *c = <span class="built_in">container_or</span>(c1, type1, c2, type2, &amp;result_type);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ra_append</span>(&amp;answer-&gt;high_low_container, s1, c, result_type);</span><br><span class="line">            ++pos1;</span><br><span class="line">            ++pos2;</span><br><span class="line">            <span class="keyword">if</span> (pos1 == length1) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos2 == length2) <span class="keyword">break</span>;</span><br><span class="line">            s1 = <span class="built_in">ra_get_key_at_index</span>(&amp;x1-&gt;high_low_container, pos1);</span><br><span class="line">            s2 = <span class="built_in">ra_get_key_at_index</span>(&amp;x2-&gt;high_low_container, pos2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s1 &lt; s2) &#123;  <span class="comment">// s1 &lt; s2</span></span><br><span class="line">          	<span class="comment">// 拷贝 s1 对应的container</span></span><br><span class="line">            <span class="type">container_t</span> *c1 = <span class="built_in">ra_get_container_at_index</span>(</span><br><span class="line">                                    &amp;x1-&gt;high_low_container, pos1, &amp;type1);</span><br><span class="line">            c1 = <span class="built_in">get_copy_of_container</span>(c1, &amp;type1, <span class="built_in">is_cow</span>(x1));</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_cow</span>(x1)) &#123;</span><br><span class="line">                <span class="built_in">ra_set_container_at_index</span>(&amp;x1-&gt;high_low_container, pos1, c1,</span><br><span class="line">                                          type1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ra_append</span>(&amp;answer-&gt;high_low_container, s1, c1, type1);</span><br><span class="line">            pos1++;</span><br><span class="line">            <span class="keyword">if</span> (pos1 == length1) <span class="keyword">break</span>;</span><br><span class="line">            s1 = <span class="built_in">ra_get_key_at_index</span>(&amp;x1-&gt;high_low_container, pos1);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// s1 &gt; s2</span></span><br><span class="line">            <span class="type">container_t</span> *c2 = <span class="built_in">ra_get_container_at_index</span>(</span><br><span class="line">                                    &amp;x2-&gt;high_low_container, pos2, &amp;type2);</span><br><span class="line">            <span class="comment">// c2 = container_clone(c2, type2);</span></span><br><span class="line">            c2 = <span class="built_in">get_copy_of_container</span>(c2, &amp;type2, <span class="built_in">is_cow</span>(x2));</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_cow</span>(x2)) &#123;</span><br><span class="line">                <span class="built_in">ra_set_container_at_index</span>(&amp;x2-&gt;high_low_container, pos2, c2,</span><br><span class="line">                                          type2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ra_append</span>(&amp;answer-&gt;high_low_container, s2, c2, type2);</span><br><span class="line">            pos2++;</span><br><span class="line">            <span class="keyword">if</span> (pos2 == length2) <span class="keyword">break</span>;</span><br><span class="line">            s2 = <span class="built_in">ra_get_key_at_index</span>(&amp;x2-&gt;high_low_container, pos2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos1 == length1) &#123;</span><br><span class="line">        <span class="built_in">ra_append_copy_range</span>(&amp;answer-&gt;high_low_container,</span><br><span class="line">                             &amp;x2-&gt;high_low_container, pos2, length2,</span><br><span class="line">                             <span class="built_in">is_cow</span>(x2));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos2 == length2) &#123;</span><br><span class="line">        <span class="built_in">ra_append_copy_range</span>(&amp;answer-&gt;high_low_container,</span><br><span class="line">                             &amp;x1-&gt;high_low_container, pos1, length1,</span><br><span class="line">                             <span class="built_in">is_cow</span>(x1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="低16位-Container-Or"><a href="#低16位-Container-Or" class="headerlink" title="低16位 Container Or"></a>低16位 Container Or</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">container_t</span> *<span class="title">container_or</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">container_t</span> *c1, <span class="type">uint8_t</span> type1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">container_t</span> *c2, <span class="type">uint8_t</span> type2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint8_t</span> *result_type</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line">    c1 = <span class="built_in">container_unwrap_shared</span>(c1, &amp;type1);</span><br><span class="line">    c2 = <span class="built_in">container_unwrap_shared</span>(c2, &amp;type2);</span><br><span class="line">    <span class="type">container_t</span> *result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">PAIR_CONTAINER_TYPES</span>(type1, type2)) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">CONTAINER_PAIR</span><span class="params">(BITSET,BITSET)</span>:</span></span><br><span class="line"><span class="function">            result =</span> <span class="built_in">bitset_container_create</span>();</span><br><span class="line">            <span class="comment">// 1、两个Bitmap Container求or，底层会用avx2指令集优化</span></span><br><span class="line">            <span class="built_in">bitset_container_or</span>(<span class="built_in">const_CAST_bitset</span>(c1),</span><br><span class="line">                                <span class="built_in">const_CAST_bitset</span>(c2),</span><br><span class="line">                                <span class="built_in">CAST_bitset</span>(result));</span><br><span class="line">            *result_type = BITSET_CONTAINER_TYPE;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">CONTAINER_PAIR</span><span class="params">(ARRAY,ARRAY)</span>:</span></span><br><span class="line"><span class="function">        		// <span class="number">2</span>、两个Array Container求or</span></span><br><span class="line"><span class="function">            *result_type =</span> <span class="built_in">array_array_container_union</span>(</span><br><span class="line">                                <span class="built_in">const_CAST_array</span>(c1),</span><br><span class="line">                                <span class="built_in">const_CAST_array</span>(c2), &amp;result)</span><br><span class="line">                                    ? BITSET_CONTAINER_TYPE</span><br><span class="line">                                    : ARRAY_CONTAINER_TYPE;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">CONTAINER_PAIR</span><span class="params">(RUN,RUN)</span>:</span></span><br><span class="line"><span class="function">        		// <span class="number">3</span>、两个Run Container求or</span></span><br><span class="line"><span class="function">            result =</span> <span class="built_in">run_container_create</span>();</span><br><span class="line">            <span class="built_in">run_container_union</span>(<span class="built_in">const_CAST_run</span>(c1),</span><br><span class="line">                                <span class="built_in">const_CAST_run</span>(c2),</span><br><span class="line">                                <span class="built_in">CAST_run</span>(result));</span><br><span class="line">            *result_type = RUN_CONTAINER_TYPE;</span><br><span class="line">            <span class="comment">// todo: could be optimized since will never convert to array</span></span><br><span class="line">            result = <span class="built_in">convert_run_to_efficient_container_and_free</span>(</span><br><span class="line">                            <span class="built_in">CAST_run</span>(result), result_type);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">            <span class="comment">// 4、Array Container 和 求or</span></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">CONTAINER_PAIR</span><span class="params">(BITSET,ARRAY)</span>:</span></span><br><span class="line"><span class="function">            result =</span> <span class="built_in">bitset_container_create</span>();</span><br><span class="line">            <span class="built_in">array_bitset_container_union</span>(<span class="built_in">const_CAST_array</span>(c2),</span><br><span class="line">                                         <span class="built_in">const_CAST_bitset</span>(c1),</span><br><span class="line">                                         <span class="built_in">CAST_bitset</span>(result));</span><br><span class="line">            *result_type = BITSET_CONTAINER_TYPE;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">CONTAINER_PAIR</span><span class="params">(ARRAY,BITSET)</span>:</span></span><br><span class="line"><span class="function">            result =</span> <span class="built_in">bitset_container_create</span>();</span><br><span class="line">            <span class="built_in">array_bitset_container_union</span>(<span class="built_in">const_CAST_array</span>(c1),</span><br><span class="line">                                         <span class="built_in">const_CAST_bitset</span>(c2),</span><br><span class="line">                                         <span class="built_in">CAST_bitset</span>(result));</span><br><span class="line">            *result_type = BITSET_CONTAINER_TYPE;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">            __builtin_unreachable();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// unreached</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="两个Array-Container求Or"><a href="#两个Array-Container求Or" class="headerlink" title="两个Array Container求Or"></a>两个Array Container求Or</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">array_array_container_union</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">array_container_t</span> *src_1, <span class="type">const</span> <span class="type">array_container_t</span> *src_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">container_t</span> **dst</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> totalCardinality = src_1-&gt;cardinality + src_2-&gt;cardinality;</span><br><span class="line">    <span class="comment">// 预估or的元素个数还是小于4096，则还是新建一个Array Container</span></span><br><span class="line">    <span class="comment">// 用于存储并集结果</span></span><br><span class="line">    <span class="keyword">if</span> (totalCardinality &lt;= DEFAULT_MAX_SIZE) &#123;</span><br><span class="line">        *dst = <span class="built_in">array_container_create_given_capacity</span>(totalCardinality);</span><br><span class="line">        <span class="keyword">if</span> (*dst != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        		<span class="comment">// 该函数底层会调用fast_union_uint16，进行avx2指令集优化加速</span></span><br><span class="line">            <span class="built_in">array_container_union</span>(src_1, src_2, <span class="built_in">CAST_array</span>(*dst));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// otherwise failure won&#x27;t be caught</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// not a bitset</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预估or元素个数大于4096，则创建一个Bitmap Container</span></span><br><span class="line">    *dst = <span class="built_in">bitset_container_create</span>();</span><br><span class="line">    <span class="type">bool</span> returnval = <span class="literal">true</span>;  <span class="comment">// expect a bitset</span></span><br><span class="line">    <span class="keyword">if</span> (*dst != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">bitset_container_t</span> *ourbitset = <span class="built_in">CAST_bitset</span>(*dst);</span><br><span class="line">        <span class="comment">// 这里底层会调用_asm_bitset_set_list，使用avx2指令集优化</span></span><br><span class="line">        <span class="built_in">bitset_set_list</span>(ourbitset-&gt;words, src_1-&gt;array, src_1-&gt;cardinality);</span><br><span class="line">        ourbitset-&gt;cardinality = (<span class="type">int32_t</span>)<span class="built_in">bitset_set_list_withcard</span>(</span><br><span class="line">            ourbitset-&gt;words, src_1-&gt;cardinality, src_2-&gt;array,</span><br><span class="line">            src_2-&gt;cardinality);</span><br><span class="line">        <span class="comment">//如果最终求or发现元素个数小于4096，还会转成ArrayContainer</span></span><br><span class="line">        <span class="keyword">if</span> (ourbitset-&gt;cardinality &lt;= DEFAULT_MAX_SIZE) &#123;</span><br><span class="line">            <span class="comment">// need to convert!</span></span><br><span class="line">            *dst = <span class="built_in">array_container_from_bitset</span>(ourbitset);</span><br><span class="line">            <span class="built_in">bitset_container_free</span>(ourbitset);</span><br><span class="line">            returnval = <span class="literal">false</span>;  <span class="comment">// not going to be a bitset</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Array-Container-和-Bitmap-Container求-Or"><a href="#Array-Container-和-Bitmap-Container求-Or" class="headerlink" title="Array Container 和 Bitmap Container求 Or"></a>Array Container 和 Bitmap Container求 Or</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">array_bitset_container_union</span><span class="params">(<span class="type">const</span> <span class="type">array_container_t</span> *src_1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> <span class="type">bitset_container_t</span> *src_2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">bitset_container_t</span> *dst)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 先copy一份Bitmap Container个answer</span></span><br><span class="line">    <span class="keyword">if</span> (src_2 != dst) <span class="built_in">bitset_container_copy</span>(src_2, dst);</span><br><span class="line">  	<span class="comment">// 调用bitset_set_list_withcard，底层可以调用avx2指令集优化</span></span><br><span class="line">    dst-&gt;cardinality = (<span class="type">int32_t</span>)<span class="built_in">bitset_set_list_withcard</span>(</span><br><span class="line">        dst-&gt;words, dst-&gt;cardinality, src_1-&gt;array, src_1-&gt;cardinality);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">bitset_set_list_withcard</span><span class="params">(<span class="type">uint64_t</span> *words, <span class="type">uint64_t</span> card,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> <span class="type">uint16_t</span> *list, <span class="type">uint64_t</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> offset, load, newload, pos, index;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint16_t</span> *end = list + length;</span><br><span class="line">    <span class="keyword">while</span> (list != end) &#123;</span><br><span class="line">        pos = *list;</span><br><span class="line">        offset = pos &gt;&gt; <span class="number">6</span>;</span><br><span class="line">        index = pos % <span class="number">64</span>;</span><br><span class="line">        load = words[offset];</span><br><span class="line">        newload = load | (<span class="built_in">UINT64_C</span>(<span class="number">1</span>) &lt;&lt; index);</span><br><span class="line">        card += (load ^ newload) &gt;&gt; index;</span><br><span class="line">        words[offset] = newload;</span><br><span class="line">        list++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> card;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、FastUnion"><a href="#4、FastUnion" class="headerlink" title="4、FastUnion"></a>4、FastUnion</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Roaring <span class="title">fastunion</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> Roaring **inputs)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">roaring_bitmap_t</span> **x =</span><br><span class="line">            (<span class="type">const</span> <span class="type">roaring_bitmap_t</span> **)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">roaring_bitmap_t</span> *));</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">ROARING_TERMINATE</span>(<span class="string">&quot;failed memory alloc in fastunion&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; n; ++k) x[k] = &amp;inputs[k]-&gt;roaring;</span><br><span class="line">  			<span class="comment">// 调用roaring_bitmap_or_many</span></span><br><span class="line">        <span class="type">roaring_bitmap_t</span> *c_ans = api::<span class="built_in">roaring_bitmap_or_many</span>(n, x);</span><br><span class="line">  			<span class="comment">// 调用堆结构实现的有时效率会更快些</span></span><br><span class="line">  			<span class="comment">// roaring_bitmap_t *c_ans = api::roaring_bitmap_or_many_heap(n, x);</span></span><br><span class="line">        <span class="keyword">if</span> (c_ans == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(x);</span><br><span class="line">            <span class="built_in">ROARING_TERMINATE</span>(<span class="string">&quot;failed memory alloc in fastunion&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">Roaring <span class="title">ans</span><span class="params">(c_ans)</span></span>;</span><br><span class="line">        <span class="built_in">free</span>(x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">roaring_bitmap_t</span> *<span class="title">roaring_bitmap_or_many</span><span class="params">(<span class="type">size_t</span> number,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> <span class="type">roaring_bitmap_t</span> **x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">roaring_bitmap_create</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (number == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">roaring_bitmap_copy</span>(x[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 先前两个求或</span></span><br><span class="line">    <span class="type">roaring_bitmap_t</span> *answer =</span><br><span class="line">        <span class="built_in">roaring_bitmap_lazy_or</span>(x[<span class="number">0</span>], x[<span class="number">1</span>], LAZY_OR_BITSET_CONVERSION);</span><br><span class="line">    <span class="comment">// 两两求或</span></span><br><span class="line">  	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">2</span>; i &lt; number; i++) &#123;</span><br><span class="line">        <span class="built_in">roaring_bitmap_lazy_or_inplace</span>(answer, x[i], LAZY_OR_BITSET_CONVERSION);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// lazy or的方式是会将array_contianer 转成 bitmap_container</span></span><br><span class="line">  	<span class="comment">// 此处会修复把可以转成ArrayContainer的再转回来</span></span><br><span class="line">    <span class="built_in">roaring_bitmap_repair_after_lazy</span>(answer);</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">roaring_bitmap_t</span> *<span class="title">roaring_bitmap_lazy_or</span><span class="params">(<span class="type">const</span> <span class="type">roaring_bitmap_t</span> *x1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> <span class="type">roaring_bitmap_t</span> *x2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> <span class="type">bool</span> bitsetconversion)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> result_type = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> length1 = x1-&gt;high_low_container.size,</span><br><span class="line">              length2 = x2-&gt;high_low_container.size;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == length1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">roaring_bitmap_copy</span>(x2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == length2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">roaring_bitmap_copy</span>(x1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">roaring_bitmap_t</span> *answer =</span><br><span class="line">        <span class="built_in">roaring_bitmap_create_with_capacity</span>(length1 + length2);</span><br><span class="line">    <span class="built_in">roaring_bitmap_set_copy_on_write</span>(answer, <span class="built_in">is_cow</span>(x1) &amp;&amp; <span class="built_in">is_cow</span>(x2));</span><br><span class="line">    <span class="type">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> type1, type2;</span><br><span class="line">    <span class="type">uint16_t</span> s1 = <span class="built_in">ra_get_key_at_index</span>(&amp;x1-&gt;high_low_container, pos1);</span><br><span class="line">    <span class="type">uint16_t</span> s2 = <span class="built_in">ra_get_key_at_index</span>(&amp;x2-&gt;high_low_container, pos2);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">            <span class="type">container_t</span> *c1 = <span class="built_in">ra_get_container_at_index</span>(</span><br><span class="line">                                    &amp;x1-&gt;high_low_container, pos1, &amp;type1);</span><br><span class="line">            <span class="type">container_t</span> *c2 = <span class="built_in">ra_get_container_at_index</span>(</span><br><span class="line">                                    &amp;x2-&gt;high_low_container, pos2, &amp;type2);</span><br><span class="line">            <span class="type">container_t</span> *c;</span><br><span class="line">          	<span class="comment">// 转成bitmap container</span></span><br><span class="line">            <span class="keyword">if</span> (bitsetconversion &amp;&amp;</span><br><span class="line">                (<span class="built_in">get_container_type</span>(c1, type1) != BITSET_CONTAINER_TYPE) &amp;&amp;</span><br><span class="line">                (<span class="built_in">get_container_type</span>(c2, type2) != BITSET_CONTAINER_TYPE)</span><br><span class="line">            )&#123;</span><br><span class="line">                <span class="type">container_t</span> *newc1 =</span><br><span class="line">                    <span class="built_in">container_mutable_unwrap_shared</span>(c1, &amp;type1);</span><br><span class="line">                newc1 = <span class="built_in">container_to_bitset</span>(newc1, type1);</span><br><span class="line">                type1 = BITSET_CONTAINER_TYPE;</span><br><span class="line">              	<span class="comment">// 根据container的类型，底层是去调用 bitset_container_or </span></span><br><span class="line">              	<span class="comment">// array_bitset_container_lazy_union</span></span><br><span class="line">                c = <span class="built_in">container_lazy_ior</span>(newc1, type1, c2, type2,</span><br><span class="line">                                       &amp;result_type);</span><br><span class="line">                <span class="keyword">if</span> (c != newc1) &#123;  <span class="comment">// should not happen</span></span><br><span class="line">                    <span class="built_in">container_free</span>(newc1, type1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = <span class="built_in">container_lazy_or</span>(c1, type1, c2, type2, &amp;result_type);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// since we assume that the initial containers are non-empty,</span></span><br><span class="line">            <span class="comment">// the</span></span><br><span class="line">            <span class="comment">// result here</span></span><br><span class="line">            <span class="comment">// can only be non-empty</span></span><br><span class="line">            <span class="built_in">ra_append</span>(&amp;answer-&gt;high_low_container, s1, c, result_type);</span><br><span class="line">            ++pos1;</span><br><span class="line">            ++pos2;</span><br><span class="line">            <span class="keyword">if</span> (pos1 == length1) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos2 == length2) <span class="keyword">break</span>;</span><br><span class="line">            s1 = <span class="built_in">ra_get_key_at_index</span>(&amp;x1-&gt;high_low_container, pos1);</span><br><span class="line">            s2 = <span class="built_in">ra_get_key_at_index</span>(&amp;x2-&gt;high_low_container, pos2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s1 &lt; s2) &#123;  <span class="comment">// s1 &lt; s2</span></span><br><span class="line">            <span class="type">container_t</span> *c1 = <span class="built_in">ra_get_container_at_index</span>(</span><br><span class="line">                                    &amp;x1-&gt;high_low_container, pos1, &amp;type1);</span><br><span class="line">            c1 = <span class="built_in">get_copy_of_container</span>(c1, &amp;type1, <span class="built_in">is_cow</span>(x1));</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_cow</span>(x1)) &#123;</span><br><span class="line">                <span class="built_in">ra_set_container_at_index</span>(&amp;x1-&gt;high_low_container, pos1, c1,</span><br><span class="line">                                          type1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ra_append</span>(&amp;answer-&gt;high_low_container, s1, c1, type1);</span><br><span class="line">            pos1++;</span><br><span class="line">            <span class="keyword">if</span> (pos1 == length1) <span class="keyword">break</span>;</span><br><span class="line">            s1 = <span class="built_in">ra_get_key_at_index</span>(&amp;x1-&gt;high_low_container, pos1);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// s1 &gt; s2</span></span><br><span class="line">            <span class="type">container_t</span> *c2 = <span class="built_in">ra_get_container_at_index</span>(</span><br><span class="line">                                    &amp;x2-&gt;high_low_container, pos2, &amp;type2);</span><br><span class="line">            c2 = <span class="built_in">get_copy_of_container</span>(c2, &amp;type2, <span class="built_in">is_cow</span>(x2));</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_cow</span>(x2)) &#123;</span><br><span class="line">                <span class="built_in">ra_set_container_at_index</span>(&amp;x2-&gt;high_low_container, pos2, c2,</span><br><span class="line">                                          type2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ra_append</span>(&amp;answer-&gt;high_low_container, s2, c2, type2);</span><br><span class="line">            pos2++;</span><br><span class="line">            <span class="keyword">if</span> (pos2 == length2) <span class="keyword">break</span>;</span><br><span class="line">            s2 = <span class="built_in">ra_get_key_at_index</span>(&amp;x2-&gt;high_low_container, pos2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos1 == length1) &#123;</span><br><span class="line">        <span class="built_in">ra_append_copy_range</span>(&amp;answer-&gt;high_low_container,</span><br><span class="line">                             &amp;x2-&gt;high_low_container, pos2, length2,</span><br><span class="line">                             <span class="built_in">is_cow</span>(x2));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos2 == length2) &#123;</span><br><span class="line">        <span class="built_in">ra_append_copy_range</span>(&amp;answer-&gt;high_low_container,</span><br><span class="line">                             &amp;x1-&gt;high_low_container, pos1, length1,</span><br><span class="line">                             <span class="built_in">is_cow</span>(x1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="EXPERIMENTS"><a href="#EXPERIMENTS" class="headerlink" title="EXPERIMENTS"></a>EXPERIMENTS</h2><p>参考论文：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://arxiv.org/pdf/1709.07821.pdf">https://arxiv.org/pdf/1709.07821.pdf</a></p>
<p>内存使用：<br><img src="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/5.png" alt></p>
<p>遍历一遍所使用的耗时：<br><img src="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/6.png" alt></p>
<p>随机获取某个元素的耗时：<br><img src="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/7.png" alt></p>
<p>两两求交集：<br><img src="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/8.png" alt></p>
<p>两两求并集：<br><img src="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/9.png" alt></p>
<p>多个集合求并集：<br><img src="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/10.png" alt></p>
<h2 id="RoaringBitmap优化寻址"><a href="#RoaringBitmap优化寻址" class="headerlink" title="RoaringBitmap优化寻址"></a>RoaringBitmap优化寻址</h2><p>利用 RBM 结构特性去计算某个 doc 对应的下标，即计算某个数是 RBM 中的第几个 1，在此基础上我针对CRoaring源码实现部分，做了一些小小的优化，现将优化思路简单分享一下。</p>
<p>CRoaring原生的提供两个接口<code>contains</code> 和 <code>rank</code>，一个是判断某个数是否存在，一个是计算集合中小于等于某个数的个数，接口函数代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if value x is present</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">uint32_t</span> x)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> api::<span class="built_in">roaring_bitmap_contains</span>(&amp;roaring, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of integers that are smaller or equal to x.</span></span><br><span class="line"><span class="comment"> * Thus the rank of the smallest element is one.  If</span></span><br><span class="line"><span class="comment"> * x is smaller than the smallest element, this function will return 0.</span></span><br><span class="line"><span class="comment"> * The rank and select functions differ in convention: this function returns</span></span><br><span class="line"><span class="comment"> * 1 when ranking the smallest value, but the select function returns the</span></span><br><span class="line"><span class="comment"> * smallest value when using index 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">rank</span><span class="params">(<span class="type">uint32_t</span> x)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> api::<span class="built_in">roaring_bitmap_rank</span>(&amp;roaring, x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>针对一些数据，写了一个benchmark的工具</p>
<p><img src="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/11.png" alt></p>
<p>核心的优化思路是充分利用LocalDocID的有序性，尽可能缓存上一次的计算结果，减少重复计算。</p>
<p>优化图例介绍：</p>
<p><img src="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/12.png" alt></p>
<p>其中 exp2的这部分的寻址优化工作也向CRoaring开源库提交一次<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/RoaringBitmap/CRoaring/pull/470">PR</a>，已由开源项目维护者审核通过并发布。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of x in the set, index start from 0.</span></span><br><span class="line"><span class="comment"> * If the set doesn&#x27;t contain x , this function will return -1.</span></span><br><span class="line"><span class="comment"> * The difference with rank function is that this function will return -1</span></span><br><span class="line"><span class="comment"> * when x isn&#x27;t in the set, but the rank function will return a</span></span><br><span class="line"><span class="comment"> * non-negative number.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">getIndex</span><span class="params">(<span class="type">uint32_t</span> x)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> api::<span class="built_in">roaring_bitmap_get_index</span>(&amp;roaring, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/13.png" alt></p>

    </div>

    
    
    
      

        <div class="reward-container">
  <div>喜欢你就打赏一下</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Bryce 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Bryce
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://bryceustc.github.io/2023/12/29/RoaringBitmap%E5%8E%9F%E7%90%86%20&%20CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" title="RoaringBitmap原理 &amp; CRoaring源码解读 &amp; 优化寻址">https://bryceustc.github.io/2023/12/29/RoaringBitmap原理 & CRoaring源码解读/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/RoaringBitmap/" rel="tag"><i class="fa fa-tag"></i> RoaringBitmap</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/12/23/HBase-API%E6%93%8D%E4%BD%9C/" rel="prev" title="HBase API操作">
      <i class="fa fa-chevron-left"></i> HBase API操作
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/13/C-%E5%AE%9E%E7%8E%B0memcpy%E3%80%81memmove%E5%87%BD%E6%95%B0/" rel="next" title="C++ 实现memcpy、memmove函数">
      C++ 实现memcpy、memmove函数 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#RoaringBitMap%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">RoaringBitMap原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RoaringBitmap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">RoaringBitmap数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RoaringArray"><span class="nav-number">2.1.</span> <span class="nav-text">RoaringArray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Containers"><span class="nav-number">2.2.</span> <span class="nav-text">Containers</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81ArrayContainer"><span class="nav-number">2.2.1.</span> <span class="nav-text">1、ArrayContainer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81BitmapContainer"><span class="nav-number">2.2.2.</span> <span class="nav-text">2、BitmapContainer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81RunContainer"><span class="nav-number">2.2.3.</span> <span class="nav-text">3、RunContainer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RoaringBitmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">RoaringBitmap源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Add"><span class="nav-number">3.1.</span> <span class="nav-text">1、Add</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%9816%E4%BD%8DAdd"><span class="nav-number">3.1.1.</span> <span class="nav-text">高16位Add</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8E16%E4%BD%8DAdd"><span class="nav-number">3.1.2.</span> <span class="nav-text">低16位Add</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Array-Container-Add"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">Array Container Add</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bitmap-Container-Add"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">Bitmap Container Add</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81And"><span class="nav-number">3.2.</span> <span class="nav-text">2、And</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%9816%E4%BD%8D-And"><span class="nav-number">3.2.1.</span> <span class="nav-text">高16位 And</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8E16%E4%BD%8DAnd"><span class="nav-number">3.2.2.</span> <span class="nav-text">低16位And</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Bitmap-Container-amp-Bitmap-Container"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">Bitmap Container &amp; Bitmap Container</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Array-Container-amp-Array-Container"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">Array Container &amp; Array Container</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bitmap-Container-amp-Array-Container"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">Bitmap Container &amp; Array Container</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Array-Container-amp-Bitmap-Container"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">Array Container &amp; Bitmap Container</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Or"><span class="nav-number">3.3.</span> <span class="nav-text">3、Or</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%9816%E4%BD%8D-or"><span class="nav-number">3.3.1.</span> <span class="nav-text">高16位 or</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8E16%E4%BD%8D-Container-Or"><span class="nav-number">3.3.2.</span> <span class="nav-text">低16位 Container Or</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AAArray-Container%E6%B1%82Or"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">两个Array Container求Or</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Array-Container-%E5%92%8C-Bitmap-Container%E6%B1%82-Or"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">Array Container 和 Bitmap Container求 Or</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81FastUnion"><span class="nav-number">3.4.</span> <span class="nav-text">4、FastUnion</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EXPERIMENTS"><span class="nav-number">4.</span> <span class="nav-text">EXPERIMENTS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RoaringBitmap%E4%BC%98%E5%8C%96%E5%AF%BB%E5%9D%80"><span class="nav-number">5.</span> <span class="nav-text">RoaringBitmap优化寻址</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bryce"
      src="/images/touxiang.jfif">
  <p class="site-author-name" itemprop="name">Bryce</p>
  <div class="site-description" itemprop="description">书写是对思维的缓存</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">96</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bryceustc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bryceustc" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:bryceustc@mail.ustc.edu.cn" title="E-Mail → mailto:bryceustc@mail.ustc.edu.cn" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bryce</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">299k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:32</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'xl0dCw4B0ewo6hdaDLfUhpQ2-9Nh9j0Va',
      appKey     : 'To4mX7CgnCwpmrdnshxRlVPm',
      placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
