<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bryceustc.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="RoaringBitMap原理Roaring Bitmap实现的主要思路是将32位无符号整数（0~4294967295）分成高16位和低16位两部分。通过高 16 位找到该数据存储在哪个桶中（高 16 位可以划分 216个桶），把剩余的低 16 位放入该桶对应的 Container 中。每个桶都有对应的 Container，不同的 Container 存储方式不同。依据不同的场景，主要有 2 种不">
<meta property="og:type" content="article">
<meta property="og:title" content="RoaringBitmap原理 &amp; CRoaring源码解读">
<meta property="og:url" content="https://bryceustc.github.io/2023/12/29/CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/index.html">
<meta property="og:site_name" content="Bryce&#39;s Blog">
<meta property="og:description" content="RoaringBitMap原理Roaring Bitmap实现的主要思路是将32位无符号整数（0~4294967295）分成高16位和低16位两部分。通过高 16 位找到该数据存储在哪个桶中（高 16 位可以划分 216个桶），把剩余的低 16 位放入该桶对应的 Container 中。每个桶都有对应的 Container，不同的 Container 存储方式不同。依据不同的场景，主要有 2 种不">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-12-29T14:53:22.000Z">
<meta property="article:modified_time" content="2023-12-29T14:53:22.000Z">
<meta property="article:author" content="Bryce">
<meta property="article:tag" content="RoaringBitmap">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bryceustc.github.io/2023/12/29/CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>RoaringBitmap原理 & CRoaring源码解读 | Bryce's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/bryceustc" class="github-corner" aria-label="View source on GitHub"><svg width="100" height="100" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bryce's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Learn Everything.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bryceustc.github.io/2023/12/29/CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jfif">
      <meta itemprop="name" content="Bryce">
      <meta itemprop="description" content="书写是对思维的缓存">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bryce's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RoaringBitmap原理 & CRoaring源码解读
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-29 22:53:22" itemprop="dateCreated datePublished" datetime="2023-12-29T22:53:22+08:00">2023-12-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RoaringBitmap/" itemprop="url" rel="index"><span itemprop="name">RoaringBitmap</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/12/29/CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/12/29/CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>26k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="RoaringBitMap原理"><a href="#RoaringBitMap原理" class="headerlink" title="RoaringBitMap原理"></a>RoaringBitMap原理</h2><p>Roaring Bitmap实现的主要思路是将32位无符号整数（0~4294967295）分成高16位和低16位两部分。通过高 16 位找到该数据存储在哪个桶中（高 16 位可以划分 2<sup>16</sup>个桶），把剩余的低 16 位放入该桶对应的 Container 中。<br>每个桶都有对应的 Container，不同的 Container 存储方式不同。依据不同的场景，主要有 2 种不同的 Container，分别是 Array Container 和 Bitmap Container。Array Container 存放稀疏的数据，Bitmap Container 存放稠密的数据。若一个 Container 里面的元素数量小于 4096，使用 Array Container 来存储。当 Array Container 超过最大容量 4096 时，会转换为 Bitmap Container。<br><span id="more"></span><br>简单举2个例子，说明rbm是如何存储数据的。</p>
<p>例1：0x00020032（十进制131122）放入一个 RBM 的过程如下图所示：</p>
<p>131122 的高 16 位是 0002，找到对应的桶 0x0002。在桶对应的 Container 中存储低 16 位，因为 Container 元素个数不足 4096，因此是一个 Array Container。低 16 位为 0032（十进制为50）, 在 Array Container 中二分查找找到相应的位置插入即可（如上图50的位置）。相较于纯Bitmap 需要占用 16K (131122/8/1024) 内存来存储这个数，而这种存储实际只占用了4B（桶中占 2 B，Container中占 2 B，不考虑数组的初始容量）。</p>
<p>例2：0xFFFF3ACB（十进制4294916811）放入一个 RBM 的过程如下图所示：</p>
<p>4294916811 的高 16 位是 FFFF，找到对应的桶 0xFFFF。在桶对应的 Container 中存储低 16 位，因为 Container 中元素个数已经超过 4096，底层是一个 Bitmap Container。低 16 位为 3ACB（十进制为15051）, 因此在 Bitmap Container 中通过下标直接寻址找到相应的位置，将其置为 1 即可（如上图15051的位置）。由于每个 Bitmap Container 需要处理低 16 位数据，使用 Bitmap 来存储需要 8192 Bytes（2^16/8）, 而一个 long 值占 8 个 Bytes，所以数组大小为 1024。因此一个 Bitmap Container 固定占用内存 8 KB。</p>
<h2 id="RoaringBitmap数据结构"><a href="#RoaringBitmap数据结构" class="headerlink" title="RoaringBitmap数据结构"></a>RoaringBitmap数据结构</h2><p>RoaringBitmap的基本构成如下:首先是一个RoaringArray，名字是high_low_container，该结构中存储了每个uint32整数的高16bit的索引keys以及具体存储数字的container。</p>
<h3 id="RoaringArray"><a href="#RoaringArray" class="headerlink" title="RoaringArray"></a>RoaringArray</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">roaring_bitmap_s</span> &#123;</span><br><span class="line">    <span class="type">roaring_array_t</span> high_low_container;</span><br><span class="line">&#125; <span class="type">roaring_bitmap_t</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">roaring_array_s</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> size;</span><br><span class="line">    <span class="type">int32_t</span> allocation_size;</span><br><span class="line">    ROARING_CONTAINER_T **containers;  <span class="comment">// Use container_t in non-API files!</span></span><br><span class="line">    <span class="type">uint16_t</span> *keys;</span><br><span class="line">    <span class="type">uint8_t</span> *typecodes;</span><br><span class="line">    <span class="type">uint8_t</span> flags;</span><br><span class="line">&#125; <span class="type">roaring_array_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>roaring_array：每个RBM都包含了一个roaring_array，名字是high_low_container，该结构主要有下面几个重要属性：<ul>
<li>keys：short数组，用来存储高16位作为索引</li>
<li>containers：container数组，用来存储低16位数据</li>
<li>typecodes：可理解为container type的数组，标识container的类型</li>
<li>size：可理解为rbm包含的key-value有效数量</li>
</ul>
</li>
</ul>
<p>PS：keys数组和containers数组是一一对应的，且keys永远保证有序，这是为了之后索引的二分查找</p>
<h3 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h3><p>Container用于存储低16位的数据，根据数据量以及疏密程度分为以下3个容器：</p>
<ul>
<li>ArrayContainer</li>
<li>BitmapContainer</li>
<li>RunContainer</li>
</ul>
<h4 id="1、ArrayContainer"><a href="#1、ArrayContainer" class="headerlink" title="1、ArrayContainer"></a>1、ArrayContainer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayContainer允许的最大数据量</span></span><br><span class="line"><span class="keyword">enum</span> &#123; DEFAULT_MAX_SIZE = <span class="number">4096</span> &#125;;<span class="comment">/* Containers with DEFAULT_MAX_SIZE or less integers should be arrays */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct array_container - sparse representation of a bitmap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @cardinality: number of indices in `array` (and the bitmap)</span></span><br><span class="line"><span class="comment"> * @capacity:    allocated size of `array`</span></span><br><span class="line"><span class="comment"> * @array:       sorted list of integers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">STRUCT_CONTAINER</span>(array_container_s) &#123;</span><br><span class="line">    <span class="type">int32_t</span> cardinality;</span><br><span class="line">    <span class="type">int32_t</span> capacity;</span><br><span class="line">    <span class="type">uint16_t</span> *array;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Array Container 是 Roaring Bitmap 初始化默认的 Container。Array Container 适合存放稀疏的数据，其内部数据结构是一个<strong>有序的 short 数组</strong>。数组初始容量为 4，数组最大容量为 4096，存储元素始终有序，方便二分查找，<strong>查询复杂度O(logn)</strong></p>
<h4 id="2、BitmapContainer"><a href="#2、BitmapContainer" class="headerlink" title="2、BitmapContainer"></a>2、BitmapContainer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BITSET_CONTAINER_SIZE_IN_WORDS = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) / <span class="number">64</span>,</span><br><span class="line">    BITSET_UNKNOWN_CARDINALITY = <span class="number">-1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">STRUCT_CONTAINER</span>(bitset_container_s) &#123;</span><br><span class="line">    <span class="type">int32_t</span> cardinality;</span><br><span class="line">    <span class="type">uint64_t</span> *words;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BitmapContainer采用<strong>long数组</strong>存储低16位数据，这就是一个未压缩的普通Bitmap，每一个bit位置代表一个数字。每一个Container最多可以处理2<sup>16</sup>个数字，基于位图的原理需要2<sup>16</sup>个bit，每个long是8字节64bit，所以数组大小是2<sup>16</sup>/64=1024，始终<strong>占据8kb</strong>的空间，<strong>查询复杂度O(1)</strong></p>
<h4 id="3、RunContainer"><a href="#3、RunContainer" class="headerlink" title="3、RunContainer"></a>3、RunContainer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct rle16_s - run length pair</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @value:  start position of the run</span></span><br><span class="line"><span class="comment"> * @length: length of the run is `length + 1`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An RLE pair &#123;v, l&#125; would represent the integers between the interval</span></span><br><span class="line"><span class="comment"> * [v, v+l+1], e.g. &#123;3, 2&#125; = [3, 4, 5].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rle16_s</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> value;</span><br><span class="line">    <span class="type">uint16_t</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct run_container_s - run container bitmap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @n_runs:   number of rle_t pairs in `runs`.</span></span><br><span class="line"><span class="comment"> * @capacity: capacity in rle_t pairs `runs` can hold.</span></span><br><span class="line"><span class="comment"> * @runs:     pairs of rle_t.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">STRUCT_CONTAINER</span>(run_container_s) &#123;</span><br><span class="line">    <span class="type">int32_t</span> n_runs;</span><br><span class="line">    <span class="type">int32_t</span> capacity;</span><br><span class="line">    <span class="type">rle16_t</span> *runs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要解决了连续1的情况，例如15、16、17、18可以被优化成15,3。RunContainer中的关键变量为value，length，类型是short。其中，value是具体数值，length为value往后的连续个数。</p>
<p>例如：3,4,5,10,20,21,22,23这样一组数据会被优化成3,2,10,0,20,3，原理就是记录初始数字以及连续的数量，并把压缩后的数据记录在short数组中。这种压缩方式对于数据的疏密程度非常敏感，举两个最极端的例子：如果这个Container中所有数据都是连续的，也就是[0,1,2…..65535]，压缩后为0,65535，即2个short，4字节。若这个container中所有数据都是间断的（都是偶数或奇数），也就是[0,2,4,6….65532,65534]，压缩后为0,0,2,0…..65534,0，这不仅没有压缩反而膨胀了一倍，65536个short，即128kb</p>
<p>因此是否选择RunContainer是需要判断的，RBM提供了一个转化方法runOptimize()用于对比和其他两种Container的空间大小，若占据优势则会进行转化。</p>
<p><strong>各个Container之间比较如下</strong>：</p>
<p><strong>1. 读取时间</strong></p>
<p>只有BitmapContainer可根据下标直接寻址，复杂度为O(1)，ArrayContainer和RunContainer都需要二分查找，复杂度O(log n)</p>
<p><strong>2. 内存占用</strong></p>
<h3 id="RoaringBitmap源码分析"><a href="#RoaringBitmap源码分析" class="headerlink" title="RoaringBitmap源码分析"></a>RoaringBitmap源码分析</h3><p>CRoaring源码：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/RoaringBitmap/CRoaring">https://github.com/RoaringBitmap/CRoaring</a></p>
<h4 id="1、Add"><a href="#1、Add" class="headerlink" title="1、Add"></a>1、Add</h4><p>Add大致流程：</p>
<ol>
<li>二分判断新加的Value的高16位是否存在，不存在新建一个ArrayContainer，然后添加低16位数值即可</li>
<li><p>若存在，确定低16位Container位置后，判断对应Container的类型：<br> a. Array Container：</p>
<pre><code> i. 通过二分查找Value低16位所在的ArrayContainer中的位置，若存在说明已经添加了则不处理
 ii. 不存在则对元素容量Cardinality进行判断，决定是否需要扩容或者升级为BitmapContainer
 iii. 将ArrayContainer中insert_idx之后的子数组后移一位，将数据插入，形成新的Array数组
</code></pre><p> b. Bitmap Container</p>
<pre><code> i. 通过pos/64找到bitmap中的long数组中的位置得到原值old_word
 ii. old_word | (1 &lt;&lt; (pos%64) ) 得到new_word并赋值
 iii. 更新Cardinality
</code></pre><p>高16位<br>void roaring_bitmap_add(roaring_bitmap_t <em>r, uint32_t val) {<br> roaring_array_t </em>ra = &amp;r-&gt;high_low_container;</p>
<pre><code> // 获取待插入数val的高16位
</code></pre><p> const uint16_t hb = val &gt;&gt; 16;<br> // 计算高16位对应的索引值的下标位置(底层是个二分查找)<br> const int i = ra_get_index(ra, hb);<br> uint8_t typecode;</p>
<pre><code>// 索引下标大于0说明该索引已存在且创建了对应的Container，则将低16位存入该Container中
</code></pre><p> if (i &gt;= 0) {</p>
<pre><code> ra_unshare_container_at_index(ra, i);
 container_t *container =
     ra_get_container_at_index(ra, i, &amp;typecode);
 uint8_t newtypecode = typecode;
 container_t *container2 =
     container_add(container, val &amp; 0xFFFF, typecode, &amp;newtypecode);
 if (container2 != container) &#123;
     container_free(container, typecode);
     ra_set_container_at_index(&amp;r-&gt;high_low_container, i, container2,
                               newtypecode);
 &#125;
</code></pre><p> } else {</p>
<pre><code>   // 若索引下标小于0说明该索引不存在，则直接创建一个ArrayContainer并将低16位放入其中
 array_container_t *newac = array_container_create();
 container_t *container = container_add(newac, val &amp; 0xFFFF,
                                 ARRAY_CONTAINER_TYPE, &amp;typecode);
 // we could just assume that it stays an array container
 ra_insert_new_key_value_at(&amp;r-&gt;high_low_container, -i - 1, hb,
                            container, typecode);
</code></pre><p> }<br>}<br>Array Container Add<br>/**</p>
<ul>
<li>Add value to the set if final cardinality doesn’t exceed max_cardinality.</li>
<li>Return code:</li>
<li>1  — value was added</li>
<li>0  — value was already present</li>
<li><p>-1 — value was not added because cardinality would exceed max_cardinality<br><em>/<br>static inline int array_container_try_add(array_container_t </em>arr, uint16_t value,</p>
<pre><code>                                 int32_t max_cardinality) &#123;
</code></pre><p>const int32_t cardinality = arr-&gt;cardinality;</p>
<p>// best case, we can append.<br> // 两种场景可以不走二分查找：<br> // 1、基数为0<br>// 2、当前值大于容器中的最大值，因为array是有序的，最后一个即最大值<br>if ((array_container_empty(arr) || arr-&gt;array[cardinality - 1] &lt; value) &amp;&amp;<br>   cardinality &lt; max_cardinality) {<br>   array_container_append(arr, value);<br>   return 1;<br>}</p>
<p>   // 通过二分查找找到对应的插入位置<br>const int32_t loc = binarySearch(arr-&gt;array, cardinality, value);</p>
<p>// 存在则不处理直接返回（去重效果）<br>if (loc &gt;= 0) {<br>   return 0;<br>} else if (cardinality &lt; max_cardinality) {</p>
<pre><code> // 判断是否需要扩容
</code></pre><p>   if (array_container_full(arr)) {</p>
<pre><code>   array_container_grow(arr, arr-&gt;capacity + 1, true);
</code></pre><p>   }<br>   const int32_t insert_idx = -loc - 1;<br>   // 通过拷贝数组将val插入array数组<br>   memmove(arr-&gt;array + insert_idx + 1, arr-&gt;array + insert_idx,</p>
<pre><code>       (cardinality - insert_idx) * sizeof(uint16_t));
</code></pre><p>   arr-&gt;array[insert_idx] = value;<br>   arr-&gt;cardinality++;<br>   return 1;<br>} else {</p>
<pre><code> //容量大于等于4096需转化为BitmapContainer，返回-1
</code></pre><p>   return -1;<br>}<br>}<br>add流程：<br>1、通过二分查找找到val所在的array中的位置，若存在则不处理，不存在则进入下一步。<br>2、对cardinality进行判断，决定是否需要升级为BitmapContainer或者扩容。<br>3、将array中insert_idx之后的子数组后移一位，将数据插入，形成新的Array数组。<br>Bitmap Container Add<br>// file contains grubby stuff that must know impl. details of all container<br>// types.<br>bitset_container_t <em>bitset_container_from_array(const array_container_t </em>ac) {<br>bitset_container_t *ans = bitset_container_create();<br> // 获取array container的cardinality<br>int limit = array_container_cardinality(ac);<br>for (int i = 0; i &lt; limit; ++i) bitset_container_set(ans, ac-&gt;array[i]);<br>return ans;<br>}</p>
</li>
</ul>
</li>
</ol>
<p>…</p>
<p>/<em> Set the ith bit.  </em>/<br>static inline void bitset_container_set(bitset_container_t *bitset,<br>                                        uint16_t pos) {<br>    uint64_t shift = 6;<br>    uint64_t offset;<br>    uint64_t p = pos;<br>    // 利用汇编指令右移6位，相当于/64，目的是找到第几个long<br>    ASM_SHIFT_RIGHT(p, shift, offset);<br>    uint64_t load = bitset-&gt;words[offset];<br>      // 找到对应的long的旧值，对应位置set为1后，与旧值取或得到新值<br>    ASM_SET_BIT_INC_WAS_CLEAR(load, p, bitset-&gt;cardinality);<br>    bitset-&gt;words[offset] = load;<br>}</p>
<p>/* Add <code>pos&#39; to</code>bitset’. Returns true if `pos’ was not present. Might be slower</p>
<ul>
<li>than bitset_container_set.  <em>/<br>static inline bool bitset_container_add(bitset_container_t </em>bitset,<pre><code>                                 uint16_t pos) &#123;
</code></pre>   // 右移6位，取到对应long数组的旧值<br> const uint64_t old_word = bitset-&gt;words[pos &gt;&gt; 6];<br>   // 相当于%63，取到是long的第几位<br> const int index = pos &amp; 63;<br>   // 按位或得到新值<br> const uint64_t new_word = old_word | (UINT64_C(1) &lt;&lt; index);<br> const uint64_t increment = (old_word ^ new_word) &gt;&gt; index;<br> bitset-&gt;cardinality += (uint32_t)increment;<br> bitset-&gt;words[pos &gt;&gt; 6] = new_word;<br> return increment &gt; 0;<br>}</li>
</ul>
<p>add流程：<br>1、通过pos/64找到bitmap中的long数组中的位置得到原值old_word。<br>2、old_word | (1 &lt;&lt; (pos%64) ) 得到new_word。<br>3、改变cardinality。<br>2、And<br>And流程：</p>
<ol>
<li>获取high_low_container，判断keys数组中元素是否相等，即判断高16位</li>
<li><p>在高16位元素相等的情况下，去判断对应Container中存储的低16位元素：<br> a. Bitmap Container &amp; Bitmap Container</p>
<pre><code> i. 快速获取两个Bitmap求交后的元素个数（底层AVX2指令集优化）
 ii. 若求交后元素个数大于4096，用Bitmap Container存储，否则用Array Container存储。
</code></pre><p> b. Array Container &amp; Array Container</p>
<pre><code> i. 计算结果集的cardinality的上限，并初始化
 ii. 两个Array Container元素相差较大，差距大于64倍的时候，会调用intersect_skewed_uint16，步长为2的幂次方的形式递增，加速跳过不相交的元素。如果相差不大的时候，调用intersect_uint16步长为1进行比较（底层就是两个有序数组求交集） 或者intersect_vector16进行AVX2指令集加速
</code></pre><p> c. Bitmap Container &amp; Array Container</p>
<pre><code> i. 给结果数组dst申请扩容，初始长度为Array Container的array的长度
 ii. for循环遍历Array Container，依次其中的元素是否在Bitmap Container中存在，如果存在的话，则更新到结果answer中，并更新Cardinality。
</code></pre><p> d. Array Container &amp; Bitmap Container</p>
<pre><code> i. 同上
</code></pre><p>高16位<br>roaring_bitmap_t <em>roaring_bitmap_and(const roaring_bitmap_t </em>x1,</p>
<pre><code>                              const roaring_bitmap_t *x2) &#123;
</code></pre><p> uint8_t result_type = 0;<br> // 获取两个rbm的对应high_low_container的size<br> const int length1 = x1-&gt;high_low_container.size,</p>
<pre><code>       length2 = x2-&gt;high_low_container.size;
</code></pre><p> // 取两者较小的length<br> uint32_t neededcap = length1 &gt; length2 ? length2 : length1;<br>   // 构建一个新的answer rbm<br> roaring_bitmap_t *answer = roaring_bitmap_create_with_capacity(neededcap);<br> roaring_bitmap_set_copy_on_write(answer, is_cow(x1) &amp;&amp; is_cow(x2));</p>
<p> int pos1 = 0, pos2 = 0;</p>
<p> while (pos1 &lt; length1 &amp;&amp; pos2 &lt; length2) {</p>
<pre><code> const uint16_t s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);
 const uint16_t s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);
   // 高16位相等
 if (s1 == s2) &#123;
     uint8_t type1, type2;
       // 获取对应的container
     container_t *c1 = ra_get_container_at_index(
                             &amp;x1-&gt;high_low_container, pos1, &amp;type1);
     container_t *c2 = ra_get_container_at_index(
                             &amp;x2-&gt;high_low_container, pos2, &amp;type2);
     // 两个container之间求and
     container_t *c = container_and(c1, type1, c2, type2, &amp;result_type);

     if (container_nonzero_cardinality(c, result_type)) &#123;
         ra_append(&amp;answer-&gt;high_low_container, s1, c, result_type);
     &#125; else &#123;
         container_free(c, result_type);  // otherwise: memory leak!
     &#125;
     ++pos1;
     ++pos2;
 &#125; else if (s1 &lt; s2) &#123;  // s1 &lt; s2
       // 底层是二分查找，找到第一个x1中的第一个大于等于s2的位置
     pos1 = ra_advance_until(&amp;x1-&gt;high_low_container, s2, pos1);
 &#125; else &#123;  // s1 &gt; s2
     pos2 = ra_advance_until(&amp;x2-&gt;high_low_container, s1, pos2);
 &#125;
</code></pre><p> }<br> return answer;<br>}<br>低16位<br>static inline container_t <em>container_and(<br> const container_t </em>c1, uint8_t type1,<br> const container_t <em>c2, uint8_t type2,<br> uint8_t </em>result_type<br>){<br> c1 = container_unwrap_shared(c1, &amp;type1);<br> c2 = container_unwrap_shared(c2, &amp;type2);<br> container_t *result = NULL;<br> // 不同container之间的组合<br> switch (PAIR_CONTAINER_TYPES(type1, type2)) {</p>
<pre><code>     // 1、两个Bitmap Container 求交
 case CONTAINER_PAIR(BITSET,BITSET):
     *result_type = bitset_bitset_container_intersection(
                         const_CAST_bitset(c1),
                         const_CAST_bitset(c2), &amp;result)
                             ? BITSET_CONTAINER_TYPE
                             : ARRAY_CONTAINER_TYPE;
     return result;
 // 2、两个Array Container 求交
 case CONTAINER_PAIR(ARRAY,ARRAY):
     result = array_container_create();
     array_container_intersection(const_CAST_array(c1),
                                  const_CAST_array(c2),
                                  CAST_array(result));
     *result_type = ARRAY_CONTAINER_TYPE;  // never bitset
     return result;
 // 3、两个Run Container 求交
 case CONTAINER_PAIR(RUN,RUN):
     result = run_container_create();
     run_container_intersection(const_CAST_run(c1),
                                const_CAST_run(c2),
                                CAST_run(result));
     return convert_run_to_efficient_container_and_free(
                 CAST_run(result), result_type);

 // 4、Bitmap Container 和 Array Container求交
 case CONTAINER_PAIR(BITSET,ARRAY):
     result = array_container_create();
     array_bitset_container_intersection(const_CAST_array(c2),
                                         const_CAST_bitset(c1),
                                         CAST_array(result));
     *result_type = ARRAY_CONTAINER_TYPE;  // never bitset
     return result;
 // 5、Array Container 和 Bitmap Container求交
 case CONTAINER_PAIR(ARRAY,BITSET):
     result = array_container_create();
     *result_type = ARRAY_CONTAINER_TYPE;  // never bitset
     array_bitset_container_intersection(const_CAST_array(c1),
                                         const_CAST_bitset(c2),
                                         CAST_array(result));
     return result;
 ...

 default:
     assert(false);
     __builtin_unreachable();
     return NULL;
</code></pre><p> }<br>}<br>Bitmap Container &amp; Bitmap Container<br>两个Bitmap Container求And流程：<br>1、快速获取两个Bitmap求交后的元素个数<br>2、若求交后元素个数大于4096，用Bitmap Container存储，否则用Array Container存储。<br>bool bitset_bitset_container_intersection(<br> const bitset_container_t <em>src_1, const bitset_container_t </em>src_2,<br> container_t **dst<br>){</p>
<pre><code> // 计算两个bitmap求交后的元素个数（avx2指令集优化）
</code></pre><p> const int newCardinality = bitset_container_and_justcard(src_1, src_2);<br> // 求交后元素个数大于4096<br> if (newCardinality &gt; DEFAULT_MAX_SIZE) {</p>
<pre><code>     // 创建一个新的bitmap container
 *dst = bitset_container_create();
 if (*dst != NULL) &#123;
         // 成为
     bitset_container_and_nocard(src_1, src_2, CAST_bitset(*dst));
     CAST_bitset(*dst)-&gt;cardinality = newCardinality;
 &#125;
 return true;  // it is a bitset
</code></pre><p> }<br> <em>dst = array_container_create_given_capacity(newCardinality);<br> if (</em>dst != NULL) {</p>
<pre><code> CAST_array(*dst)-&gt;cardinality = newCardinality;
 // 两个Bitmap Container求交集，并输出到数组
 bitset_extract_intersection_setbits_uint16(
     src_1-&gt;words, src_2-&gt;words, BITSET_CONTAINER_SIZE_IN_WORDS,
     CAST_array(*dst)-&gt;array, 0);
</code></pre><p> }<br> return false;  // not a bitset<br>}</p>
</li>
</ol>
<p>// 将两个Bitmap的交集输出到数组，复杂度为二进制中1的位数。<br>size<em>t bitset<em>extract<em>intersection<em>setbits_uint16(const uint64_t * __restrict</em></em> words1,<br>                                                  const uint64_t * __restrict</em></em> words2,<br>                                                  size_t length, uint16_t <em>out,<br>                                                  uint16_t base) {<br>    int outpos = 0;<br>    for (size_t i = 0; i &lt; length; ++i) {<br>          // 求交<br>        uint64_t w = words1[i] &amp; words2[i];<br>        while (w != 0) {<br>              // 获取最低位的1<br>            uint64_t t = w &amp; (~w + 1);<br>              // 获取有多少个0<br>            int r = __builtin_ctzll(w);<br>              // 后边有几个0就表示真正的数字几<br>            out[outpos++] = r + base;<br>              // 异或，便于取下一个1<br>            w ^= t;<br>        }<br>        base += 64;<br>    }<br>    return outpos;<br>}<br>Array Container &amp; Array Container<br>两个Array Container求And流程：<br>1、首先计算结果集的cardinality的上限，并初始化<br>2、两个Array Container元素相差较大，差距大于64倍的时候，会调用intersect_skewed_uint16，步长为2的幂次方的形式递增，加速跳过不相交的元素。如果相差不大的时候，调用intersect_uint16步长为1进行比较（底层就是两个有序数组求交集） 或者intersect_vector16进行avx2指令集加速。<br>void array_container_intersection(const array_container_t </em>array1,<br>                                  const array_container_t <em>array2,<br>                                  array_container_t </em>out) {<br>    int32_t card_1 = array1-&gt;cardinality, card_2 = array2-&gt;cardinality,<br>            min_card = minimum_int32(card_1, card_2);<br>    const int threshold = 64;  // subject to tuning</p>
<h1 id="ifdef-CROARING-IS-X64"><a href="#ifdef-CROARING-IS-X64" class="headerlink" title="ifdef CROARING_IS_X64"></a>ifdef CROARING_IS_X64</h1><pre><code>if (out-&gt;capacity &lt; min_card) &#123;
  // 申请扩容
  array_container_grow(out, min_card + sizeof(__m128i) / sizeof(uint16_t),
    false);
&#125;
</code></pre><h1 id="else"><a href="#else" class="headerlink" title="else"></a>else</h1><pre><code>if (out-&gt;capacity &lt; min_card) &#123;
  array_container_grow(out, min_card, false);
&#125;
</code></pre><h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><pre><code>    // 两个Array Container元素相差较大，64倍的时候
  // 步长为2的幂次方的形式递增，可以加速跳过不相交的元素
if (card_1 * threshold &lt; card_2) &#123;
    out-&gt;cardinality = intersect_skewed_uint16(
        array1-&gt;array, card_1, array2-&gt;array, card_2, out-&gt;array);
&#125; else if (card_2 * threshold &lt; card_1) &#123;
    out-&gt;cardinality = intersect_skewed_uint16(
        array2-&gt;array, card_2, array1-&gt;array, card_1, out-&gt;array);
&#125; else &#123;
  // 如果两个Array Container的元素相差不大的时候，
  // 调用intersect_uint16步长为1进行比较（底层就是两个有序数组求交集） 
  // 或者intersect_vector16内部指令集加速
</code></pre><h1 id="ifdef-CROARING-IS-X64-1"><a href="#ifdef-CROARING-IS-X64-1" class="headerlink" title="ifdef CROARING_IS_X64"></a>ifdef CROARING_IS_X64</h1><pre><code>   if( croaring_avx2() ) &#123;
    out-&gt;cardinality = intersect_vector16(
        array1-&gt;array, card_1, array2-&gt;array, card_2, out-&gt;array);
   &#125; else &#123;
    out-&gt;cardinality = intersect_uint16(array1-&gt;array, card_1,
                                        array2-&gt;array, card_2, out-&gt;array);
   &#125;
</code></pre><h1 id="else-1"><a href="#else-1" class="headerlink" title="else"></a>else</h1><pre><code>    out-&gt;cardinality = intersect_uint16(array1-&gt;array, card_1,
                                        array2-&gt;array, card_2, out-&gt;array);
</code></pre><h1 id="endif-1"><a href="#endif-1" class="headerlink" title="endif"></a>endif</h1><pre><code>&#125;
</code></pre><p>}<br>Bitmap Container &amp; Array Container<br>Bitmap Container 和 Array Container And流程：<br>1、首先，给dst申请扩容，初始长度为ArrayContainer的array的长度<br>2、然后for循环遍历ArrayContainer，依次其中的元素是否在BitmapContainer中存在，如果存在的话，则更新到结果answer中，并增加cardinality。void array_bitset_container_intersection(const array_container_t <em>src_1,<br>                                         const bitset_container_t </em>src_2,<br>                                         array_container_t *dst) {<br>    if (dst-&gt;capacity &lt; src_1-&gt;cardinality) {<br>        array_container_grow(dst, src_1-&gt;cardinality, false);<br>    }<br>    int32_t newcard = 0;  // dst could be src_1<br>    const int32_t origcard = src_1-&gt;cardinality;<br>    for (int i = 0; i &lt; origcard; ++i) {<br>        uint16_t key = src_1-&gt;array[i];<br>        dst-&gt;array[newcard] = key;<br>        newcard += bitset_container_contains(src_2, key);<br>    }<br>    dst-&gt;cardinality = newcard;<br>}<br>Array Container &amp; Bitmap Container<br>同上Bitmap Container &amp; Array Container的原理。<br>同时还有iand，标识inplace的And操作，原理与上述基本类似。<br>3、Or<br>Or流程：</p>
<ol>
<li>获取high_low_container，while循环遍历判断keys数组中元素，在高16位相等的情况下，调用container_or求两个container的并集<br> a. Bitmap Container | Bitmap Container<pre><code> i. 两个Bitmap求并集（底层使用AVX2指令集加速批量处理）
</code></pre> b. Array Container | Array Container<pre><code> i. 预估取并集后的元素个数是否小于4096，
     1. 是，则新建一个Array Container
     2. 否，则新建一个Bitmap Container
</code></pre> c. Bitmap Container | Array Container<pre><code> i. Copy一份Bitmap Container
 i. 遍历Array Container的元素，添加进新的Bitmap Container
</code></pre> b. Array Container | Bitmap Container<pre><code> i. 同上
</code></pre></li>
<li><p>高16位元素不相等，直接给answer添加对应的key及container<br>roaring_bitmap_t <em>roaring_bitmap_or(const roaring_bitmap_t </em>x1,</p>
<pre><code>                             const roaring_bitmap_t *x2) &#123;
</code></pre><p> uint8_t result_type = 0;<br> const int length1 = x1-&gt;high_low_container.size,</p>
<pre><code>       length2 = x2-&gt;high_low_container.size;
</code></pre><p> if (0 == length1) {</p>
<pre><code> return roaring_bitmap_copy(x2);
</code></pre><p> }<br> if (0 == length2) {</p>
<pre><code> return roaring_bitmap_copy(x1);
</code></pre><p> }<br> roaring_bitmap_t *answer =</p>
<pre><code> roaring_bitmap_create_with_capacity(length1 + length2);
</code></pre><p> roaring_bitmap_set_copy_on_write(answer, is_cow(x1) &amp;&amp; is_cow(x2));<br> int pos1 = 0, pos2 = 0;<br> uint8_t type1, type2;<br> uint16_t s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);<br> uint16_t s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);<br> while (true) {</p>
<pre><code>   // 高16位相等，底层container进行求or
 if (s1 == s2) &#123;
     container_t *c1 = ra_get_container_at_index(
                             &amp;x1-&gt;high_low_container, pos1, &amp;type1);
     container_t *c2 = ra_get_container_at_index(
                             &amp;x2-&gt;high_low_container, pos2, &amp;type2);
     container_t *c = container_or(c1, type1, c2, type2, &amp;result_type);

     ra_append(&amp;answer-&gt;high_low_container, s1, c, result_type);
     ++pos1;
     ++pos2;
     if (pos1 == length1) break;
     if (pos2 == length2) break;
     s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);
     s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);

 &#125; else if (s1 &lt; s2) &#123;  // s1 &lt; s2
       // 拷贝 s1 对应的container
     container_t *c1 = ra_get_container_at_index(
                             &amp;x1-&gt;high_low_container, pos1, &amp;type1);
     c1 = get_copy_of_container(c1, &amp;type1, is_cow(x1));
     if (is_cow(x1)) &#123;
         ra_set_container_at_index(&amp;x1-&gt;high_low_container, pos1, c1,
                                   type1);
     &#125;
     ra_append(&amp;answer-&gt;high_low_container, s1, c1, type1);
     pos1++;
     if (pos1 == length1) break;
     s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);

 &#125; else &#123;  // s1 &gt; s2
     container_t *c2 = ra_get_container_at_index(
                             &amp;x2-&gt;high_low_container, pos2, &amp;type2);
     // c2 = container_clone(c2, type2);
     c2 = get_copy_of_container(c2, &amp;type2, is_cow(x2));
     if (is_cow(x2)) &#123;
         ra_set_container_at_index(&amp;x2-&gt;high_low_container, pos2, c2,
                                   type2);
     &#125;
     ra_append(&amp;answer-&gt;high_low_container, s2, c2, type2);
     pos2++;
     if (pos2 == length2) break;
     s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);
 &#125;
</code></pre><p> }<br> if (pos1 == length1) {</p>
<pre><code> ra_append_copy_range(&amp;answer-&gt;high_low_container,
                      &amp;x2-&gt;high_low_container, pos2, length2,
                      is_cow(x2));
</code></pre><p> } else if (pos2 == length2) {</p>
<pre><code> ra_append_copy_range(&amp;answer-&gt;high_low_container,
                      &amp;x1-&gt;high_low_container, pos1, length1,
                      is_cow(x1));
</code></pre><p> }<br> return answer;<br>}<br>ContainerOr<br>static inline container_t <em>container_or(<br> const container_t </em>c1, uint8_t type1,<br> const container_t <em>c2, uint8_t type2,<br> uint8_t </em>result_type<br>){<br> c1 = container_unwrap_shared(c1, &amp;type1);<br> c2 = container_unwrap_shared(c2, &amp;type2);<br> container_t *result = NULL;<br> switch (PAIR_CONTAINER_TYPES(type1, type2)) {</p>
<pre><code> case CONTAINER_PAIR(BITSET,BITSET):
     result = bitset_container_create();
     // 1、两个Bitmap Container求or，底层会用avx2指令集优化
     bitset_container_or(const_CAST_bitset(c1),
                         const_CAST_bitset(c2),
                         CAST_bitset(result));
     *result_type = BITSET_CONTAINER_TYPE;
     return result;

 case CONTAINER_PAIR(ARRAY,ARRAY):
         // 2、两个Array Container求or
     *result_type = array_array_container_union(
                         const_CAST_array(c1),
                         const_CAST_array(c2), &amp;result)
                             ? BITSET_CONTAINER_TYPE
                             : ARRAY_CONTAINER_TYPE;
     return result;

 case CONTAINER_PAIR(RUN,RUN):
         // 3、两个Run Container求or
     result = run_container_create();
     run_container_union(const_CAST_run(c1),
                         const_CAST_run(c2),
                         CAST_run(result));
     *result_type = RUN_CONTAINER_TYPE;
     // todo: could be optimized since will never convert to array
     result = convert_run_to_efficient_container_and_free(
                     CAST_run(result), result_type);
     return result;
     // 4、Array Container 和 求or
 case CONTAINER_PAIR(BITSET,ARRAY):
     result = bitset_container_create();
     array_bitset_container_union(const_CAST_array(c2),
                                  const_CAST_bitset(c1),
                                  CAST_bitset(result));
     *result_type = BITSET_CONTAINER_TYPE;
     return result;

 case CONTAINER_PAIR(ARRAY,BITSET):
     result = bitset_container_create();
     array_bitset_container_union(const_CAST_array(c1),
                                  const_CAST_bitset(c2),
                                  CAST_bitset(result));
     *result_type = BITSET_CONTAINER_TYPE;
     return result;
 ...

 default:
     assert(false);
     __builtin_unreachable();
     return NULL;  // unreached
</code></pre><p> }<br>}<br>两个Array Container求Or<br>bool array_array_container_union(<br> const array_container_t <em>src_1, const array_container_t </em>src_2,<br> container_t **dst<br>){<br> int totalCardinality = src_1-&gt;cardinality + src_2-&gt;cardinality;<br> // 预估or的元素个数还是小于4096，则还是新建一个Array Container<br> // 用于存储并集结果<br> if (totalCardinality &lt;= DEFAULT_MAX_SIZE) {</p>
<pre><code> *dst = array_container_create_given_capacity(totalCardinality);
 if (*dst != NULL) &#123;
         // 该函数底层会调用fast_union_uint16，进行avx2指令集优化加速
     array_container_union(src_1, src_2, CAST_array(*dst));
 &#125; else &#123;
     return true; // otherwise failure won&#39;t be caught
 &#125;
 return false;  // not a bitset
</code></pre><p> }<br> // 预估or元素个数大于4096，则创建一个Bitmap Container<br> <em>dst = bitset_container_create();<br> bool returnval = true;  // expect a bitset<br> if (</em>dst != NULL) {</p>
<pre><code> bitset_container_t *ourbitset = CAST_bitset(*dst);
 // 这里底层会调用_asm_bitset_set_list，使用avx2指令集优化
 bitset_set_list(ourbitset-&gt;words, src_1-&gt;array, src_1-&gt;cardinality);
 ourbitset-&gt;cardinality = (int32_t)bitset_set_list_withcard(
     ourbitset-&gt;words, src_1-&gt;cardinality, src_2-&gt;array,
     src_2-&gt;cardinality);
 //如果最终求or发现元素个数小于4096，还会转成ArrayContainer
 if (ourbitset-&gt;cardinality &lt;= DEFAULT_MAX_SIZE) &#123;
     // need to convert!
     *dst = array_container_from_bitset(ourbitset);
     bitset_container_free(ourbitset);
     returnval = false;  // not going to be a bitset
 &#125;
</code></pre><p> }<br> return returnval;<br>}<br>Array Container 和 Bitmap Container求 Or<br>void array_bitset_container_union(const array_container_t *src_1,</p>
<pre><code>                           const bitset_container_t *src_2,
                           bitset_container_t *dst) &#123;
</code></pre><p>   // 先copy一份Bitmap Container个answer<br> if (src_2 != dst) bitset_container_copy(src_2, dst);<br>   // 调用bitset_set_list_withcard，底层可以调用avx2指令集优化<br> dst-&gt;cardinality = (int32_t)bitset_set_list_withcard(</p>
<pre><code> dst-&gt;words, dst-&gt;cardinality, src_1-&gt;array, src_1-&gt;cardinality);
</code></pre><p>}</p>
</li>
</ol>
<p>…</p>
<p>uint64_t bitset_set_list_withcard(uint64_t <em>words, uint64_t card,<br>                                  const uint16_t </em>list, uint64_t length) {<br>    uint64_t offset, load, newload, pos, index;<br>    const uint16_t <em>end = list + length;<br>    while (list != end) {<br>        pos = </em>list;<br>        offset = pos &gt;&gt; 6;<br>        index = pos % 64;<br>        load = words[offset];<br>        newload = load | (UINT64_C(1) &lt;&lt; index);<br>        card += (load ^ newload) &gt;&gt; index;<br>        words[offset] = newload;<br>        list++;<br>    }<br>    return card;<br>}<br>4、FastUnion<br>static Roaring fastunion(size_t n, const Roaring <strong>inputs) {<br>        const roaring_bitmap_t </strong>x =<br>            (const roaring_bitmap_t <em>*)malloc(n </em> sizeof(roaring_bitmap_t <em>));<br>        if (x == NULL) {<br>            ROARING_TERMINATE(“failed memory alloc in fastunion”);<br>        }<br>        for (size_t k = 0; k &lt; n; ++k) x[k] = &amp;inputs[k]-&gt;roaring;<br>              // 调用roaring_bitmap_or_many<br>        roaring_bitmap_t </em>c_ans = api::roaring_bitmap_or_many(n, x);<br>              // 调用堆结构实现的有时效率会更快些<br>              // roaring_bitmap_t *c_ans = api::roaring_bitmap_or_many_heap(n, x);<br>        if (c_ans == NULL) {<br>            free(x);<br>            ROARING_TERMINATE(“failed memory alloc in fastunion”);<br>        }<br>        Roaring ans(c_ans);<br>        free(x);<br>        return ans;<br>    }</p>
<p>…<br>roaring_bitmap_t <em>roaring_bitmap_or_many(size_t number,<br>                                         const roaring_bitmap_t **x) {<br>    if (number == 0) {<br>        return roaring_bitmap_create();<br>    }<br>    if (number == 1) {<br>        return roaring_bitmap_copy(x[0]);<br>    }<br>      // 先前两个求或<br>    roaring_bitmap_t </em>answer =<br>        roaring_bitmap_lazy_or(x[0], x[1], LAZY_OR_BITSET_CONVERSION);<br>    // 两两求或<br>      for (size_t i = 2; i &lt; number; i++) {<br>        roaring_bitmap_lazy_or_inplace(answer, x[i], LAZY_OR_BITSET_CONVERSION);<br>    }<br>      // lazy or的方式是会将array_contianer 转成 bitmap_container<br>      // 此处会修复把可以转成ArrayContainer的再转回来<br>    roaring_bitmap_repair_after_lazy(answer);<br>    return answer;<br>}</p>
<p>…</p>
<p>roaring_bitmap_t <em>roaring_bitmap_lazy_or(const roaring_bitmap_t </em>x1,<br>                                         const roaring_bitmap_t <em>x2,<br>                                         const bool bitsetconversion) {<br>    uint8_t result_type = 0;<br>    const int length1 = x1-&gt;high_low_container.size,<br>              length2 = x2-&gt;high_low_container.size;<br>    if (0 == length1) {<br>        return roaring_bitmap_copy(x2);<br>    }<br>    if (0 == length2) {<br>        return roaring_bitmap_copy(x1);<br>    }<br>    roaring_bitmap_t </em>answer =<br>        roaring_bitmap_create_with_capacity(length1 + length2);<br>    roaring_bitmap_set_copy_on_write(answer, is_cow(x1) &amp;&amp; is_cow(x2));<br>    int pos1 = 0, pos2 = 0;<br>    uint8_t type1, type2;<br>    uint16_t s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);<br>    uint16_t s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);<br>    while (true) {<br>        if (s1 == s2) {<br>            container_t <em>c1 = ra_get_container_at_index(<br>                                    &amp;x1-&gt;high_low_container, pos1, &amp;type1);<br>            container_t </em>c2 = ra_get_container_at_index(<br>                                    &amp;x2-&gt;high_low_container, pos2, &amp;type2);<br>            container_t <em>c;<br>              // 转成bitmap container<br>            if (bitsetconversion &amp;&amp;<br>                (get_container_type(c1, type1) != BITSET_CONTAINER_TYPE) &amp;&amp;<br>                (get_container_type(c2, type2) != BITSET_CONTAINER_TYPE)<br>            ){<br>                container_t </em>newc1 =<br>                    container_mutable_unwrap_shared(c1, &amp;type1);<br>                newc1 = container_to_bitset(newc1, type1);<br>                type1 = BITSET_CONTAINER_TYPE;<br>                  // 根据container的类型，底层是去调用 bitset_container_or<br>                  // array_bitset_container_lazy_union<br>                c = container_lazy_ior(newc1, type1, c2, type2,<br>                                       &amp;result_type);<br>                if (c != newc1) {  // should not happen<br>                    container_free(newc1, type1);<br>                }<br>            } else {<br>                c = container_lazy_or(c1, type1, c2, type2, &amp;result_type);<br>            }<br>            // since we assume that the initial containers are non-empty,<br>            // the<br>            // result here<br>            // can only be non-empty<br>            ra_append(&amp;answer-&gt;high_low_container, s1, c, result_type);<br>            ++pos1;<br>            ++pos2;<br>            if (pos1 == length1) break;<br>            if (pos2 == length2) break;<br>            s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);<br>            s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);</p>
<pre><code>    &#125; else if (s1 &lt; s2) &#123;  // s1 &lt; s2
        container_t *c1 = ra_get_container_at_index(
                                &amp;x1-&gt;high_low_container, pos1, &amp;type1);
        c1 = get_copy_of_container(c1, &amp;type1, is_cow(x1));
        if (is_cow(x1)) &#123;
            ra_set_container_at_index(&amp;x1-&gt;high_low_container, pos1, c1,
                                      type1);
        &#125;
        ra_append(&amp;answer-&gt;high_low_container, s1, c1, type1);
        pos1++;
        if (pos1 == length1) break;
        s1 = ra_get_key_at_index(&amp;x1-&gt;high_low_container, pos1);

    &#125; else &#123;  // s1 &gt; s2
        container_t *c2 = ra_get_container_at_index(
                                &amp;x2-&gt;high_low_container, pos2, &amp;type2);
        c2 = get_copy_of_container(c2, &amp;type2, is_cow(x2));
        if (is_cow(x2)) &#123;
            ra_set_container_at_index(&amp;x2-&gt;high_low_container, pos2, c2,
                                      type2);
        &#125;
        ra_append(&amp;answer-&gt;high_low_container, s2, c2, type2);
        pos2++;
        if (pos2 == length2) break;
        s2 = ra_get_key_at_index(&amp;x2-&gt;high_low_container, pos2);
    &#125;
&#125;
if (pos1 == length1) &#123;
    ra_append_copy_range(&amp;answer-&gt;high_low_container,
                         &amp;x2-&gt;high_low_container, pos2, length2,
                         is_cow(x2));
&#125; else if (pos2 == length2) &#123;
    ra_append_copy_range(&amp;answer-&gt;high_low_container,
                         &amp;x1-&gt;high_low_container, pos1, length1,
                         is_cow(x1));
&#125;
return answer;
</code></pre><p>}</p>
<p>EXPERIMENTS<br>参考论文：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://arxiv.org/pdf/1709.07821.pdf">https://arxiv.org/pdf/1709.07821.pdf</a><br>内存使用：</p>
<p>遍历一遍所使用的耗时：</p>
<p>随机获取某个元素的耗时：</p>
<p>两两求交集：</p>
<p>两两求并集：</p>
<p>多个集合求并集： </p>

    </div>

    
    
    
      

        <div class="reward-container">
  <div>喜欢你就打赏一下</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Bryce 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Bryce
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://bryceustc.github.io/2023/12/29/CRoaring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" title="RoaringBitmap原理 &amp; CRoaring源码解读">https://bryceustc.github.io/2023/12/29/CRoaring源码解读/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/RoaringBitmap/" rel="tag"><i class="fa fa-tag"></i> RoaringBitmap</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/12/23/HBase-API%E6%93%8D%E4%BD%9C/" rel="prev" title="HBase API操作">
      <i class="fa fa-chevron-left"></i> HBase API操作
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#RoaringBitMap%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">RoaringBitMap原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RoaringBitmap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">RoaringBitmap数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RoaringArray"><span class="nav-number">2.1.</span> <span class="nav-text">RoaringArray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Containers"><span class="nav-number">2.2.</span> <span class="nav-text">Containers</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81ArrayContainer"><span class="nav-number">2.2.1.</span> <span class="nav-text">1、ArrayContainer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81BitmapContainer"><span class="nav-number">2.2.2.</span> <span class="nav-text">2、BitmapContainer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81RunContainer"><span class="nav-number">2.2.3.</span> <span class="nav-text">3、RunContainer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RoaringBitmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.3.</span> <span class="nav-text">RoaringBitmap源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Add"><span class="nav-number">2.3.1.</span> <span class="nav-text">1、Add</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ifdef-CROARING-IS-X64"><span class="nav-number"></span> <span class="nav-text">ifdef CROARING_IS_X64</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#else"><span class="nav-number"></span> <span class="nav-text">else</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#endif"><span class="nav-number"></span> <span class="nav-text">endif</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ifdef-CROARING-IS-X64-1"><span class="nav-number"></span> <span class="nav-text">ifdef CROARING_IS_X64</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#else-1"><span class="nav-number"></span> <span class="nav-text">else</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#endif-1"><span class="nav-number"></span> <span class="nav-text">endif</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bryce"
      src="/images/touxiang.jfif">
  <p class="site-author-name" itemprop="name">Bryce</p>
  <div class="site-description" itemprop="description">书写是对思维的缓存</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bryceustc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bryceustc" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:bryceustc@mail.ustc.edu.cn" title="E-Mail → mailto:bryceustc@mail.ustc.edu.cn" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bryce</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">293k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:26</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'xl0dCw4B0ewo6hdaDLfUhpQ2-9Nh9j0Va',
      appKey     : 'To4mX7CgnCwpmrdnshxRlVPm',
      placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
